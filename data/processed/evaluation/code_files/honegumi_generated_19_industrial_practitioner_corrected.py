# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


obj1_name = "branin"


def branin(x1, x2):
    y = float(
        (x2 - 5.1 / (4 * np.pi**2) * x1**2 + 5.0 / np.pi * x1 - 6.0) ** 2
        + 10 * (1 - 1.0 / (8 * np.pi)) * np.cos(x1)
        + 10
    )

    return y


ax_client = AxClient()

ax_client.create_experiment(
    parameters=[
        {"name": "x1", "type": "range", "bounds": [-5.0, 10.0]},
        {"name": "x2", "type": "range", "bounds": [0.0, 10.0]},
    ],
    objectives={
        obj1_name: ObjectiveProperties(minimize=True),
    },
)


for i in range(19):

    parameterization, trial_index = ax_client.get_next_trial()

    # extract parameters
    x1 = parameterization["x1"]
    x2 = parameterization["x2"]

    results = branin(x1, x2)
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)

best_parameters, metrics = ax_client.get_best_parameters()


# Plot results
objectives = ax_client.objective_names
df = ax_client.get_trials_data_frame()

fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
ax.scatter(df.index, df[objectives], ec="k", fc="none", label="Observed")
ax.plot(
    df.index,
    np.minimum.accumulate(df[objectives]),
    color="#0033FF",
    lw=2,
    label="Best to Trial",
)
ax.set_xlabel("Trial Number")
ax.set_ylabel(objectives[0])

ax.legend()
plt.show()

# Generated for reactor yield optimization with Ax Platform
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from ax.service.ax_client import AxClient, ObjectiveProperties


# Metric name for the single objective
YIELD_METRIC = "yield"

# Global RNG for reproducibility of the synthetic measurement noise in this demo
rng = np.random.default_rng(2025)


def _sigmoid(x: float) -> float:
    return 1.0 / (1.0 + np.exp(-x))


def simulate_reactor_yield(
    temperature_c: float, pressure_bar: float, residence_time_min: float
) -> tuple[float, float]:
    """
    Synthetic, physically-inspired single-pass reactor yield model (in %).

    This function approximates a realistic response surface:
    - Yield increases toward an optimal temperature, pressure, and residence time.
    - There is a synergy between temperature and residence time.
    - Excessively high temperature and long residence time cause degradation.
    - Pressure shifts the optimal temperature and residence time slightly.
    - Heteroscedastic measurement noise (larger at harsher conditions).

    Returns:
        (observed_yield_percent, measurement_sem_percent)
    """
    T = float(temperature_c)
    P = float(pressure_bar)
    R = float(residence_time_min)

    # Pressure-dependent optimal conditions (mild coupling)
    T_opt = 112.0 + 2.0 * (P - 3.0)        # Â°C
    R_opt = 38.0 - 2.0 * (P - 3.0)         # min
    P_opt = 3.0                             # bar

    # Characteristic widths around optima
    sigma_T = 15.0
    sigma_P = 0.8
    sigma_R = 10.0

    # Smooth bell-shaped responses around optima
    gT = np.exp(-0.5 * ((T - T_opt) / sigma_T) ** 2)
    gP = np.exp(-0.5 * ((P - P_opt) / sigma_P) ** 2)
    gR = np.exp(-0.5 * ((R - R_opt) / sigma_R) ** 2)

    # Base yield model with a synergy term between temperature and residence time
    base = 15.0 + 55.0 * (0.5 * gT + 0.3 * gP + 0.2 * gR) + 20.0 * (gT * gR)

    # Degradation penalty at high T and long R
    degrade = 15.0 * _sigmoid((T - 135.0) / 5.0) * _sigmoid((R - 45.0) / 5.0)
    true_yield = base - degrade

    # Bound yield to [0, 100]
    true_yield = float(np.clip(true_yield, 0.0, 100.0))

    # Heteroscedastic measurement noise: higher noise at harsher conditions
    harshness = 0.5 * _sigmoid((T - 120.0) / 10.0) + 0.5 * _sigmoid((R - 40.0) / 10.0)
    sem = 0.6 + 1.2 * harshness  # standard error in percentage points, ~0.6% to ~1.8%

    # Simulated observed measurement
    observed = float(true_yield + rng.normal(0.0, sem))

    # Clip observed measurement to physical bounds
    observed = float(np.clip(observed, 0.0, 100.0))

    return observed, sem


def evaluate_reactor_run(parameterization: dict) -> dict:
    """
    Ax evaluation wrapper.

    Args:
        parameterization: Dict with keys:
            - "temperature_c"
            - "pressure_bar"
            - "residence_time_min"

    Returns:
        Dict mapping metric name to (mean, sem) tuple for noisy observation.
    """
    T = float(parameterization["temperature_c"])
    P = float(parameterization["pressure_bar"])
    R = float(parameterization["residence_time_min"])

    observed_yield, sem = simulate_reactor_yield(T, P, R)
    return {YIELD_METRIC: (observed_yield, sem)}


# Set up Ax optimization client
ax_client = AxClient()

# Define the experiment: maximize yield (%) over temperature, pressure, residence time
ax_client.create_experiment(
    name="reactor_yield_optimization",
    parameters=[
        {"name": "temperature_c", "type": "range", "bounds": [50.0, 150.0]},
        {"name": "pressure_bar", "type": "range", "bounds": [1.0, 5.0]},
        {"name": "residence_time_min", "type": "range", "bounds": [10.0, 60.0]},
    ],
    objectives={YIELD_METRIC: ObjectiveProperties(minimize=False)},
)

# Optimization budget
n_trials = 35

for _ in range(n_trials):
    parameterization, trial_index = ax_client.get_next_trial()

    # Evaluate the reactor run
    raw_data = evaluate_reactor_run(parameterization)

    # Complete the trial with noisy measurement (mean, sem)
    ax_client.complete_trial(trial_index=trial_index, raw_data=raw_data)

# Retrieve best found parameters and corresponding metric
best_parameters, best_metrics = ax_client.get_best_parameters()
best_yield = best_metrics[YIELD_METRIC]["mean"]
best_sem = best_metrics[YIELD_METRIC]["sem"]

print("Best parameters found:")
print(best_parameters)
print(f"Best observed yield: {best_yield:.2f}% (SEM: {best_sem:.2f}%)")

# Plot results: observed yields and best-so-far over trials
objective_names = ax_client.objective_names
df = ax_client.get_trials_data_frame()

# Ensure the metric column exists and is numeric
y_series = pd.to_numeric(df[YIELD_METRIC], errors="coerce")
best_so_far = np.maximum.accumulate(y_series.fillna(-np.inf))

fig, ax = plt.subplots(figsize=(7, 4), dpi=150)
ax.scatter(df.index, y_series, ec="k", fc="none", label="Observed yield")
ax.plot(df.index, best_so_far, color="#0033FF", lw=2, label="Best to trial")
ax.set_xlabel("Trial number")
ax.set_ylabel("Yield (%)")
ax.set_title("Reactor yield optimization")
ax.legend()
plt.tight_layout()
plt.show()