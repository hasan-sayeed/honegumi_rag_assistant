# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


# Domain-specific metric and parameter names
metric_name = "yield_percent"


def evaluate_reactor_yield(temperature_celsius: float, pressure_bar: float, residence_time_min: float) -> dict:
    """
    Simulate chemical reactor yield (%) for given operating conditions.

    This stub uses a simplified kinetic/selectivity model to generate a realistic,
    noisy yield measurement. Replace this with actual experimental or simulation logic.

    Inputs:
      - temperature_celsius: Reactor temperature in °C (50-150)
      - pressure_bar: Reactor pressure in bar (1-5)
      - residence_time_min: Residence time in minutes (10-60)

    Returns:
      dict: {"yield_percent": (measured_yield, standard_error)}
    """
    # Physical constants and model parameters
    R = 8.314  # J/mol-K
    T_K = temperature_celsius + 273.15

    # Pseudo-kinetics for conversion: k = k0 * exp(-Ea/RT) * P^alpha
    k0 = 1.2e7  # 1/min
    Ea = 5.5e4  # J/mol
    alpha_p = 0.6

    k = k0 * np.exp(-Ea / (R * T_K)) * (pressure_bar ** alpha_p)
    conversion = 1.0 - np.exp(-k * residence_time_min)
    conversion = np.clip(conversion, 0.0, 1.0)

    # Selectivity effects:
    # - Temperature has an optimum around ~110 °C (Gaussian penalty away from optimum)
    # - Longer residence times slightly increase overreaction (exponential penalty)
    # - High pressure mildly reduces selectivity away from ~3 bar (Gaussian penalty)
    t_opt_c = 110.0
    temp_scale = 20.0
    selectivity_T = np.exp(-((temperature_celsius - t_opt_c) / temp_scale) ** 2)

    selectivity_t = np.exp(-residence_time_min / 80.0)

    p_opt_bar = 3.0
    p_scale = 2.5
    selectivity_P = np.exp(-0.3 * ((pressure_bar - p_opt_bar) / p_scale) ** 2)

    selectivity = selectivity_T * selectivity_t * selectivity_P
    selectivity = np.clip(selectivity, 0.0, 1.0)

    # Overall yield fraction (cap theoretical max at 90%)
    yield_fraction = 0.90 * conversion * selectivity
    yield_percent_true = 100.0 * np.clip(yield_fraction, 0.0, 1.0)

    # Measurement noise (simulate experimental variance)
    measurement_sigma = 1.5  # percentage points (typical lab repeatability)
    measured_yield = float(np.clip(yield_percent_true + np.random.normal(0.0, measurement_sigma), 0.0, 100.0))

    # Standard error estimate (could be computed from replicates in real experiments)
    sem_estimate = float(measurement_sigma)

    return {metric_name: (measured_yield, sem_estimate)}


# Reproducibility for the synthetic evaluation
np.random.seed(123)


ax_client = AxClient()

# Create the optimization experiment
ax_client.create_experiment(
    name="chemical_reactor_yield_optimization",
    parameters=[
        {
            "name": "temperature_celsius",
            "type": "range",
            "bounds": [50.0, 150.0],
        },
        {
            "name": "pressure_bar",
            "type": "range",
            "bounds": [1.0, 5.0],
        },
        {
            "name": "residence_time_min",
            "type": "range",
            "bounds": [10.0, 60.0],
        },
    ],
    objectives={
        metric_name: ObjectiveProperties(minimize=False),
    },
    # No constraints specified for this problem
    parameter_constraints=[],
)

# Optimization budget
total_trials = 35

for i in range(total_trials):
    parameterization, trial_index = ax_client.get_next_trial()

    # Extract parameters
    temperature_celsius = float(parameterization["temperature_celsius"])
    pressure_bar = float(parameterization["pressure_bar"])
    residence_time_min = float(parameterization["residence_time_min"])

    # Evaluate experiment (replace with real measurement in production)
    results = evaluate_reactor_yield(temperature_celsius, pressure_bar, residence_time_min)

    # Report results (mean and SEM) back to Ax
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)

# Retrieve best found parameters and associated metric
best_parameters, best_metrics = ax_client.get_best_parameters()
print("Best parameters found:")
for k, v in best_parameters.items():
    print(f"  {k}: {v}")

print("Best observed metrics:")
for m, val in best_metrics.items():
    # val is a dict with keys 'mean' and 'sem' in AxClient API
    print(f"  {m}: mean={val['mean']:.3f}, sem={val.get('sem', float('nan')):.3f}")

# Plot results
df = ax_client.get_trials_data_frame()
metric_col = metric_name

fig, axis = plt.subplots(figsize=(7, 4), dpi=150)
axis.scatter(df.index.values, df[metric_col].values, ec="k", fc="none", label="Observed")
axis.plot(
    df.index.values,
    np.maximum.accumulate(df[metric_col].values),
    color="#0033FF",
    lw=2,
    label="Best so far",
)
axis.set_xlabel("Trial Number")
axis.set_ylabel(f"{metric_name} (%)")
axis.set_title("Chemical Reactor Yield Optimization")
axis.legend()
plt.tight_layout()
plt.show()