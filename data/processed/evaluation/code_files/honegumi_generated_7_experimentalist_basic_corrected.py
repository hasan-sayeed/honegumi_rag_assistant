# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


# Metric names
strength_metric = "strength"           # MPa, maximize
corrosion_metric = "corrosion_rate"    # mpy, minimize


# Seed for reproducibility of the noisy stub
rng = np.random.default_rng(42)


def evaluate_alloy(Cr: float, Ni: float, Mo: float):
    """
    Evaluate a steel alloy defined by weight percentages of Cr, Ni, Mo.
    Fe is the balance (not explicitly modeled).

    This is a realistic stub. Replace with actual measurement or simulation logic:
      - Run tensile test to measure yield/ultimate strength (MPa)
      - Perform corrosion test (e.g., ASTM G48) to measure corrosion rate (mpy)
      - Return mean and SEM for each metric

    Returns:
      dict:
        {
          "strength": (mean_strength_MPa, sem_strength_MPa),
          "corrosion_rate": (mean_corrosion_mpy, sem_corrosion_mpy),
        }
    """

    # Physical-inspired surrogate for demonstration
    # Strength model (MPa): additive effects + interactions + mild curvature penalties
    strength_base = 500.0
    strength = (
        strength_base
        + 18.0 * Cr
        + 8.0 * Ni
        + 35.0 * Mo
        + 0.8 * Cr * Mo
        - 0.5 * (Cr - 16.0) ** 2
        - 0.3 * (Ni - 10.0) ** 2
        - 1.5 * (Mo - 3.0) ** 2
    )

    # Corrosion model (mpy): exponential decay with alloying, slight penalty away from Mo~3%
    # Lower mpy is better
    corrosion = 12.0 * np.exp(-0.09 * Cr - 0.28 * Mo - 0.03 * Ni) + 0.02 * (Mo - 3.0) ** 2
    corrosion = max(corrosion, 0.001)

    # Add measurement noise to simulate experimental uncertainty
    noise_strength_sd = 8.0    # MPa
    noise_corr_sd = 0.05       # mpy

    measured_strength = strength + rng.normal(0.0, noise_strength_sd)
    measured_corrosion = max(corrosion + rng.normal(0.0, noise_corr_sd), 0.001)

    # Standard errors (SEM) for Ax; if unknown, set to None
    sem_strength = noise_strength_sd
    sem_corrosion = noise_corr_sd

    return {
        strength_metric: (float(measured_strength), float(sem_strength)),
        corrosion_metric: (float(measured_corrosion), float(sem_corrosion)),
    }


def is_nondominated(points: np.ndarray) -> np.ndarray:
    """
    Compute non-dominated mask for a set of points where all objectives are to be minimized.
    points: (N, M) array, lower is better for all M objectives.
    Returns:
      mask: (N,) bool array, True if non-dominated.
    """
    N = points.shape[0]
    mask = np.ones(N, dtype=bool)
    for i in range(N):
        if not mask[i]:
            continue
        dominates = np.all(points <= points[i], axis=1) & np.any(points < points[i], axis=1)
        mask[dominates] = False
        mask[i] = True
    return mask


def compute_observed_pareto(df: pd.DataFrame, maximize_cols, minimize_cols):
    """
    Compute Pareto-optimal set from observed data in df.
    maximize_cols: list of metric names to maximize
    minimize_cols: list of metric names to minimize
    Returns:
      Pareto DataFrame sorted by the first metric in maximize_cols (descending).
    """
    # Build an array where all objectives are cast to "minimize" space
    cols = list(maximize_cols) + list(minimize_cols)
    vals = df[cols].to_numpy(dtype=float)

    # Flip sign for metrics we want to maximize so that we minimize all
    for j, col in enumerate(cols):
        if col in maximize_cols:
            vals[:, j] = -vals[:, j]

    # Compute non-dominated observations
    mask = is_nondominated(vals)
    pareto_df = df.loc[mask, cols].copy()

    # Sort for plotting: by first maximize metric descending, then by first minimize metric ascending
    primary_max = maximize_cols[0]
    primary_min = minimize_cols[0]
    pareto_df = pareto_df.sort_values(by=[primary_max, primary_min], ascending=[False, True])
    return pareto_df


ax_client = AxClient()

ax_client.create_experiment(
    name="steel_alloy_strength_corrosion_moo",
    parameters=[
        {"name": "Cr", "type": "range", "bounds": [10.0, 20.0], "value_type": "float"},
        {"name": "Ni", "type": "range", "bounds": [5.0, 15.0], "value_type": "float"},
        {"name": "Mo", "type": "range", "bounds": [1.0, 5.0], "value_type": "float"},
    ],
    objectives={
        strength_metric: ObjectiveProperties(minimize=False),
        corrosion_metric: ObjectiveProperties(minimize=True),
    },
    parameter_constraints=[
        "Cr + Ni + Mo <= 100.0",  # Fe is balance; composition must be feasible
    ],
)


# Budget: 40 evaluations
NUM_TRIALS = 40
for _ in range(NUM_TRIALS):
    parameterization, trial_index = ax_client.get_next_trial()
    Cr = float(parameterization["Cr"])
    Ni = float(parameterization["Ni"])
    Mo = float(parameterization["Mo"])

    results = evaluate_alloy(Cr=Cr, Ni=Ni, Mo=Mo)
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)


# Collect observed data and compute Pareto frontier from observations
df = ax_client.get_trials_data_frame()

# Filter to completed trials with both metrics present
df = df.dropna(subset=[strength_metric, corrosion_metric])

# Compute Pareto frontier based on observed data
pareto_df = compute_observed_pareto(
    df=df,
    maximize_cols=[strength_metric],
    minimize_cols=[corrosion_metric],
)

# Plot observed points and Pareto frontier
fig, ax = plt.subplots(figsize=(7, 5), dpi=150)
ax.scatter(
    df[strength_metric],
    df[corrosion_metric],
    fc="None",
    ec="k",
    label="Observed",
)
if len(pareto_df) > 1:
    ax.plot(
        pareto_df[strength_metric],
        pareto_df[corrosion_metric],
        color="#0033FF",
        lw=2,
        label="Observed Pareto Front",
        marker="o",
    )
else:
    ax.scatter(
        pareto_df[strength_metric],
        pareto_df[corrosion_metric],
        color="#0033FF",
        label="Observed Pareto Point",
        marker="o",
    )

ax.set_xlabel(f"{strength_metric} (MPa)")
ax.set_ylabel(f"{corrosion_metric} (mpy)")
ax.set_title("Steel Alloy Optimization: Strength vs. Corrosion Rate")
ax.grid(True, alpha=0.3)
ax.legend()
plt.tight_layout()
plt.show()