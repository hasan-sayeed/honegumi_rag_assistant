# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


obj1_name = "branin"
obj2_name = "branin_swapped"


def branin_moo(x1, x2):
    y = float(
        (x2 - 5.1 / (4 * np.pi**2) * x1**2 + 5.0 / np.pi * x1 - 6.0) ** 2
        + 10 * (1 - 1.0 / (8 * np.pi)) * np.cos(x1)
        + 10
    )

    # second objective has x1 and x2 swapped
    y2 = float(
        (x1 - 5.1 / (4 * np.pi**2) * x2**2 + 5.0 / np.pi * x2 - 6.0) ** 2
        + 10 * (1 - 1.0 / (8 * np.pi)) * np.cos(x2)
        + 10
    )

    return {obj1_name: y, obj2_name: y2}


ax_client = AxClient()

ax_client.create_experiment(
    parameters=[
        {"name": "x1", "type": "range", "bounds": [-5.0, 10.0]},
        {"name": "x2", "type": "range", "bounds": [0.0, 10.0]},
    ],
    objectives={
        obj1_name: ObjectiveProperties(minimize=True),
        obj2_name: ObjectiveProperties(minimize=True),
    },
)


for i in range(19):

    parameterization, trial_index = ax_client.get_next_trial()

    # extract parameters
    x1 = parameterization["x1"]
    x2 = parameterization["x2"]

    results = branin_moo(x1, x2)
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)
pareto_results = ax_client.get_pareto_optimal_parameters()


# Plot results
objectives = ax_client.objective_names
df = ax_client.get_trials_data_frame()

fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
pareto = ax_client.get_pareto_optimal_parameters(use_model_predictions=False)
pareto_data = [p[1][0] for p in pareto.values()]
pareto = pd.DataFrame(pareto_data).sort_values(objectives[0])

ax.scatter(df[objectives[0]], df[objectives[1]], fc="None", ec="k", label="Observed")
ax.plot(
    pareto[objectives[0]],
    pareto[objectives[1]],
    color="#0033FF",
    lw=2,
    label="Pareto Front",
)
ax.set_xlabel(objectives[0])
ax.set_ylabel(objectives[1])

ax.legend()
plt.show()

# Battery charging protocol optimization (charge time vs. cycle life)
# %pip install ax-platform==0.4.3 matplotlib
import math
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from typing import Dict, Tuple, Any

from ax.service.ax_client import AxClient, ObjectiveProperties


# Metric names
METRIC_CHARGE_TIME = "charge_time_min"       # minimize
METRIC_CYCLE_LIFE = "cycle_life_cycles"      # maximize

# Parameter names
PARAM_CURRENT = "current_c_rate"             # 0.5C–3C
PARAM_VOLTAGE_LIMIT = "voltage_limit_v"      # 4.1V–4.3V
PARAM_TEMPERATURE = "ambient_temperature_c"  # 10–40C

# Reproducibility
rng = np.random.default_rng(20251031)


def simulate_charging_protocol(
    current_c_rate: float,
    voltage_limit_v: float,
    ambient_temperature_c: float,
) -> Tuple[float, float]:
    """
    Physics-inspired surrogate for Li-ion CC-CV fast charging outcomes.

    Returns:
        charge_time_min (float): Lower is better.
        cycle_life_cycles (float): Higher is better.
    """

    # --------- Charge time model (lower is better) ----------
    # CC duration scales ~ inversely with C-rate.
    cc_time_min = 60.0 / max(1e-6, current_c_rate)

    # CV tail: higher V-limit shortens CC-CV transition but also shortens CV tail.
    # Map 4.1V -> longer tail, 4.3V -> shorter tail.
    v_span = 0.2  # 4.1 to 4.3
    v_rel = (voltage_limit_v - 4.1) / v_span  # 0..1
    v_rel = float(np.clip(v_rel, 0.0, 1.0))
    # Tail time decreases with V; range roughly 14 -> 2 minutes across [4.1, 4.3] V
    cv_tail_min = 14.0 - 12.0 * v_rel

    # Temperature effect: higher T accelerates kinetics, reducing time.
    # Approximate Q10-like behavior with moderate effect.
    # Factor ~ 0.7 at 40C vs 25C, ~ 1.3 at 10C vs 25C.
    t_delta = ambient_temperature_c - 25.0
    temp_factor_time = 2.0 ** (-(t_delta) / 20.0)
    temp_factor_time = float(np.clip(temp_factor_time, 0.6, 1.4))

    # Aggregate time
    charge_time_min = (cc_time_min + cv_tail_min) * temp_factor_time

    # Add measurement noise (e.g., variability in cutoff criteria, sensors)
    charge_time_min += rng.normal(0.0, 0.8)
    charge_time_min = float(max(5.0, charge_time_min))  # lower bound for realism

    # --------- Cycle life model (higher is better) ----------
    # Baseline at 1C, 4.2V, 25C
    base_cycles = 1000.0

    # Current increases stress: exponential reduction with C-rate above 1C.
    # At 3C, factor ~ e^(-0.6*(3-1)) ~ 0.30
    current_factor = math.exp(-0.6 * (current_c_rate - 1.0))

    # Voltage limit: raising 0.1V from 4.2V is very damaging.
    # At 4.3V, factor ~ e^(-1.1) ~ 0.33; at 4.1V, factor ~ e^(+1.1) ~ 3.0 (beneficial).
    voltage_factor = math.exp(-11.0 * (voltage_limit_v - 4.2))

    # Temperature: higher T accelerates aging; lower T can extend life (within 10–40C).
    # Per +10C, ~ e^(-0.5) ~ 0.61 factor; at 40C vs 25C -> factor ~ 0.46.
    temp_factor_life = math.exp(-0.5 * (ambient_temperature_c - 25.0) / 10.0)

    cycle_life_cycles = base_cycles * current_factor * voltage_factor * temp_factor_life

    # Mild diminishing returns for very low stress regions to avoid unbounded values
    cycle_life_cycles = float(np.clip(cycle_life_cycles, 100.0, 4000.0))

    # Add measurement/process noise
    cycle_life_cycles += rng.normal(0.0, 40.0)
    cycle_life_cycles = float(np.clip(cycle_life_cycles, 50.0, 5000.0))

    return charge_time_min, cycle_life_cycles


def evaluate_protocol(parameters: Dict[str, Any]) -> Dict[str, Tuple[float, float]]:
    """
    Ax evaluation function for multi-objective experiments.

    Returns dict mapping metric name -> (mean, SEM). Use SEM=None to indicate unknown noise.
    """
    current = float(parameters[PARAM_CURRENT])
    v_limit = float(parameters[PARAM_VOLTAGE_LIMIT])
    temp_c = float(parameters[PARAM_TEMPERATURE])

    charge_time_min, cycle_life_cycles = simulate_charging_protocol(
        current_c_rate=current,
        voltage_limit_v=v_limit,
        ambient_temperature_c=temp_c,
    )

    # Unknown noise -> SEM=None so Ax will infer observation noise
    return {
        METRIC_CHARGE_TIME: (charge_time_min, None),
        METRIC_CYCLE_LIFE: (cycle_life_cycles, None),
    }


def compute_observed_pareto(df_wide: pd.DataFrame) -> pd.DataFrame:
    """
    Compute observed Pareto-optimal set for:
      - METRIC_CHARGE_TIME: minimize
      - METRIC_CYCLE_LIFE: maximize
    Returns a DataFrame of Pareto points sorted by increasing charge time.
    """
    if df_wide.empty:
        return df_wide

    points = df_wide[[METRIC_CHARGE_TIME, METRIC_CYCLE_LIFE]].values
    is_dominated = np.zeros(len(points), dtype=bool)

    # For each point, check if there exists another point that is strictly better in both objectives.
    for i, (t_i, life_i) in enumerate(points):
        if is_dominated[i]:
            continue
        for j, (t_j, life_j) in enumerate(points):
            if i == j:
                continue
            # j dominates i if:
            # t_j <= t_i (since we minimize time)
            # life_j >= life_i (since we maximize life)
            # and at least one strict inequality
            if (t_j <= t_i and life_j >= life_i) and (t_j < t_i or life_j > life_i):
                is_dominated[i] = True
                break

    pareto_df = df_wide.loc[~is_dominated].copy()
    pareto_df = pareto_df.sort_values(by=METRIC_CHARGE_TIME, ascending=True)
    return pareto_df


def main():
    # Set up Ax experiment
    ax_client = AxClient()

    ax_client.create_experiment(
        name="battery_charging_protocol_moo",
        parameters=[
            {
                "name": PARAM_CURRENT,
                "type": "range",
                "bounds": [0.5, 3.0],
                "value_type": "float",
            },
            {
                "name": PARAM_VOLTAGE_LIMIT,
                "type": "range",
                "bounds": [4.1, 4.3],
                "value_type": "float",
            },
            {
                "name": PARAM_TEMPERATURE,
                "type": "range",
                "bounds": [10.0, 40.0],
                "value_type": "float",
            },
        ],
        objectives={
            METRIC_CHARGE_TIME: ObjectiveProperties(minimize=True),
            METRIC_CYCLE_LIFE: ObjectiveProperties(minimize=False),
        },
    )

    # Budget: 35 trials (cells)
    N_TRIALS = 35
    for _ in range(N_TRIALS):
        parameters, trial_index = ax_client.get_next_trial()
        result = evaluate_protocol(parameters)
        ax_client.complete_trial(trial_index=trial_index, raw_data=result)

    # Fetch observed data and compute Pareto frontier
    df = ax_client.get_trials_data_frame()
    # Pivot to wide format with metrics as columns
    wide = (
        df.pivot_table(
            index=["trial_index", "arm_name"],
            columns="metric_name",
            values="mean",
            aggfunc="mean",
        )
        .reset_index()
        .rename_axis(None, axis=1)
    )

    # Attach parameter values to the wide df for reference
    # Parameters columns already exist in df; group to get unique per arm/trial
    param_cols = [PARAM_CURRENT, PARAM_VOLTAGE_LIMIT, PARAM_TEMPERATURE]
    params_wide = (
        df.dropna(subset=param_cols)
        .groupby(["trial_index", "arm_name"], as_index=False)[param_cols]
        .first()
    )
    wide = pd.merge(wide, params_wide, on=["trial_index", "arm_name"], how="left")

    pareto_df = compute_observed_pareto(wide)

    # Plot observed points and observed Pareto front
    fig, ax = plt.subplots(figsize=(7, 5), dpi=150)
    ax.scatter(
        wide[METRIC_CHARGE_TIME],
        wide[METRIC_CYCLE_LIFE],
        fc="None",
        ec="k",
        label="Observed",
        alpha=0.7,
    )
    if not pareto_df.empty:
        ax.plot(
            pareto_df[METRIC_CHARGE_TIME],
            pareto_df[METRIC_CYCLE_LIFE],
            color="#0033FF",
            lw=2,
            label="Observed Pareto Front",
        )

    ax.set_xlabel("Charge time [min] (lower is better)")
    ax.set_ylabel("Cycle life [cycles] (higher is better)")
    ax.set_title("Charging protocol optimization: charge time vs cycle life")
    ax.legend()
    plt.tight_layout()
    plt.show()

    # Print top Pareto protocols
    if not pareto_df.empty:
        print("Top Pareto-optimal charging protocols (first 5):")
        print(
            pareto_df[
                [
                    METRIC_CHARGE_TIME,
                    METRIC_CYCLE_LIFE,
                    PARAM_CURRENT,
                    PARAM_VOLTAGE_LIMIT,
                    PARAM_TEMPERATURE,
                ]
            ]
            .head(5)
            .to_string(index=False, float_format=lambda x: f"{x:0.2f}")
        )


if __name__ == "__main__":
    main()