# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


# Objective names for this optical glass design problem
REFRACTIVE_INDEX = "refractive_index"  # maximize
DISPERSION = "dispersion"  # minimize (e.g., inverse Abbe number proxy)


def evaluate_glass_properties(siO2: float, na2o: float, cao: float, rng: np.random.Generator) -> dict:
    """
    Synthetic but physically-inspired property model for a ternary soda-lime-silica glass.
    - refractive_index: approximate via additive refractivity with weak interaction terms
    - dispersion: proxy via mixture of Abbe numbers; return inverse (lower is better dispersion)

    Inputs are oxide fractions that sum to 1.0.
    """
    # Basic checks to avoid invalid regions due to numeric imprecision
    if siO2 < 0 or na2o < 0 or cao < 0 or abs((siO2 + na2o + cao) - 1.0) > 1e-8:
        # Heavy penalty if violated; shouldn't happen given constraints
        return {REFRACTIVE_INDEX: 1.0, DISPERSION: 1.0}

    # Approximate mixture refractive index (n_d) using additive contributions
    # Representative component contributions (n - 1) for silica, soda, lime
    # plus mild interaction nonlinearity to create trade-offs.
    n_minus_1 = (
        0.458 * siO2  # SiO2 ~1.458
        + 0.520 * na2o  # Na2O raises n more strongly
        + 0.620 * cao   # CaO also increases n
    )
    # Interaction terms to introduce curvature and realistic trade-offs
    interaction = 0.030 * na2o * cao + 0.010 * na2o * siO2 - 0.005 * siO2 * cao
    refractive_index = 1.0 + n_minus_1 + interaction
    refractive_index += 0.020 * na2o * (1.0 - siO2)  # amplify sodium effect when silica decreases

    # Add small measurement noise to refractive index
    refractive_index += rng.normal(0.0, 1e-3)

    # Dispersion proxy via Abbe number mixture:
    # Higher SiO2 -> higher Abbe (lower dispersion), Na2O lowers Abbe, CaO moderate.
    # Use inverse of Abbe as a "dispersion" metric to minimize.
    abbe_mix = 67.0 * siO2 + 30.0 * na2o + 40.0 * cao - 5.0 * na2o * cao
    abbe_mix = float(np.clip(abbe_mix, 20.0, 80.0))  # keep within plausible range
    dispersion = 1.0 / abbe_mix

    # Add small measurement noise to dispersion
    dispersion += rng.normal(0.0, 5e-4)
    dispersion = max(dispersion, 1e-4)  # prevent negative due to noise

    return {REFRACTIVE_INDEX: refractive_index, DISPERSION: dispersion}


# Total composition fraction for SiO2 + Na2O + CaO = 1.0
TOTAL_FRACTION = 1.0

# Bounds from the problem statement
SIO2_BOUNDS = (0.50, 0.70)
NA2O_BOUNDS = (0.15, 0.25)
CAO_BOUNDS = (0.10, 0.20)

# Reparameterize composition constraint by optimizing SiO2 and Na2O only.
# Enforce CaO bounds via linear sum constraints on SiO2 + Na2O:
# CaO = 1 - SiO2 - Na2O ∈ [0.10, 0.20] -> SiO2 + Na2O ∈ [0.80, 0.90]
SUM_LOWER = 1.0 - CAO_BOUNDS[1]  # 0.80
SUM_UPPER = 1.0 - CAO_BOUNDS[0]  # 0.90

rng = np.random.default_rng(seed=12345)

ax_client = AxClient(random_seed=12345, verbose_logging=False)

ax_client.create_experiment(
    name="optical_glass_moo",
    parameters=[
        {"name": "SiO2", "type": "range", "bounds": [SIO2_BOUNDS[0], SIO2_BOUNDS[1]]},
        {"name": "Na2O", "type": "range", "bounds": [NA2O_BOUNDS[0], NA2O_BOUNDS[1]]},
    ],
    objectives={
        REFRACTIVE_INDEX: ObjectiveProperties(minimize=False),  # maximize refractive index
        DISPERSION: ObjectiveProperties(minimize=True),         # minimize dispersion
    },
    parameter_constraints=[
        f"SiO2 + Na2O <= {SUM_UPPER}",
        f"SiO2 + Na2O >= {SUM_LOWER}",
    ],
)

# Budget: 38 melts (sequential, batch size 1)
N_TRIALS = 38

for i in range(N_TRIALS):
    parameters, trial_index = ax_client.get_next_trial()

    siO2 = parameters["SiO2"]
    na2o = parameters["Na2O"]
    cao = TOTAL_FRACTION - (siO2 + na2o)  # composition closure

    results = evaluate_glass_properties(siO2, na2o, cao, rng)
    # Provide dict of means; Ax will infer observation noise (noise model: True)
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)

# Retrieve observed Pareto-optimal parameterizations
pareto = ax_client.get_pareto_optimal_parameters(use_model_predictions=False)

# Plot observed points and empirical Pareto front in objective space
objective_names = ax_client.objective_names
df = ax_client.get_trials_data_frame()

fig, ax = plt.subplots(figsize=(6, 4), dpi=150)

# Observed scatter
ax.scatter(
    df[objective_names[0]],
    df[objective_names[1]],
    fc="None",
    ec="k",
    label="Observed",
)

# Extract Pareto front (observed) for plotting
# In Ax 0.4.3, values() yields tuples; the metrics dict is at index [0] of the second tuple item
pareto_data = []
for v in pareto.values():
    # v is (param_dict, (metrics_dict, arm)) or similar; align with template approach
    try:
        metrics_dict = v[1][0]  # metrics dict
    except Exception:
        # Fallback if structure differs
        metrics_dict = v[0] if isinstance(v[0], dict) else {}
    pareto_data.append(metrics_dict)

if len(pareto_data) > 0:
    pareto_df = pd.DataFrame(pareto_data).sort_values(objective_names[0])
    ax.plot(
        pareto_df[objective_names[0]],
        pareto_df[objective_names[1]],
        color="#0033FF",
        lw=2,
        label="Pareto Front (observed)",
    )

ax.set_xlabel(objective_names[0])
ax.set_ylabel(objective_names[1])
ax.set_title("Optical Glass Design: Refractive Index vs. Dispersion")
ax.legend()
plt.tight_layout()
plt.show()