# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# Robust imports for Ax ObjectiveProperties across versions
try:
    from ax.service.ax_client import AxClient
    from ax.service.utils.instantiation import ObjectiveProperties
except Exception:
    from ax.service.ax_client import AxClient, ObjectiveProperties  # type: ignore


# Domain-specific objective names
OBJ_CONTAM = "contaminant_level_ppb"
OBJ_COST = "treatment_cost_usd_per_m3"

# Domain-specific parameter names
P_COAG = "coagulant_mg_per_L"
P_FLOC = "flocculant_mg_per_L"
P_DISINF = "disinfectant_mg_per_L"

# Random generator for reproducibility
_rng = np.random.default_rng(seed=42)


def evaluate_water_treatment(parameters: dict) -> dict:
    """
    Simulated evaluation of a water treatment step.
    Inputs are chemical dosages in mg/L. Outputs:
      - contaminant_level_ppb (minimize)
      - treatment_cost_usd_per_m3 (minimize)

    This function mimics realistic, noisy treatment behavior:
    - Diminishing returns with increasing dose (Hill/Langmuir-like)
    - Synergy between coagulant and flocculant
    - Disinfectant slightly increases measured byproducts (small ppb penalty)
    - Cost scales with chemical usage plus handling/overhead

    Replace with actual lab/sensor measurement integration for production use.
    """
    # Extract parameter values (mg/L)
    c = float(parameters[P_COAG])
    f = float(parameters[P_FLOC])
    d = float(parameters[P_DISINF])

    # Influent contaminant baseline (ppb)
    c_in_ppb = 120.0

    # Removal efficiencies using saturating response (Hill-like)
    Kc, Kf, Kd = 7.0, 2.5, 4.0
    rc = 0.75 * (c / (Kc + c))  # coagulant removal fraction
    rf = 0.50 * (f / (Kf + f))  # flocculant removal fraction
    rd = 0.25 * (d / (Kd + d))  # disinfectant removal fraction

    # Synergy between coagulant and flocculant
    synergy = 0.10 * (c / (Kc + c)) * (f / (Kf + f))

    # Combine removals multiplicatively with synergy (keeps total < 1)
    base_removal = 1.0 - (1.0 - rc) * (1.0 - rf) * (1.0 - rd)
    total_removal = min(0.97, base_removal + synergy)

    # Disinfection byproducts add small ppb penalty
    byproduct_ppb = 0.05 * (d ** 1.05)

    # Effluent concentration (ensure a small physical floor)
    contaminant_ppb_true = max(0.3, c_in_ppb * (1.0 - total_removal) + byproduct_ppb)

    # Measurement/process noise (ppb)
    contaminant_noise_sd = 1.5
    contaminant_ppb_obs = float(contaminant_ppb_true + _rng.normal(0.0, contaminant_noise_sd))

    # Cost model ($/m^3): mg/L == g/m^3; price per kg => per g
    price_coag_per_g = 0.50 / 1000.0      # $/g
    price_floc_per_g = 3.00 / 1000.0      # $/g
    price_disinf_per_g = 1.20 / 1000.0    # $/g

    chem_cost = (
        c * price_coag_per_g
        + f * price_floc_per_g
        + d * price_disinf_per_g
    )

    # Handling/overhead and sludge cost (mild nonlinearity)
    overhead = 0.010  # $/m^3
    sludge_handling = 0.00020 * (c + f)
    surcharge = 0.00002 * max(0.0, (c + f - 20.0)) ** 2

    cost_true = chem_cost + overhead + sludge_handling + surcharge

    # Cost measurement noise ($/m^3)
    cost_noise_sd = 0.0015
    cost_obs = float(cost_true + _rng.normal(0.0, cost_noise_sd))

    # Return mean and SEM (noise model known => provide SEM)
    return {
        OBJ_CONTAM: (contaminant_ppb_obs, contaminant_noise_sd),
        OBJ_COST: (cost_obs, cost_noise_sd),
    }


def _compute_pareto_front(df: pd.DataFrame, x_col: str, y_col: str) -> pd.DataFrame:
    """Compute observed Pareto front for two objectives to minimize."""
    pts = df[[x_col, y_col]].to_numpy()
    n = pts.shape[0]
    is_nondom = np.ones(n, dtype=bool)
    for i in range(n):
        if not is_nondom[i]:
            continue
        # A point j dominates i if j is no worse in both and strictly better in at least one
        dominates_i = (pts[:, 0] <= pts[i, 0]) & (pts[:, 1] <= pts[i, 1]) & (
            (pts[:, 0] < pts[i, 0]) | (pts[:, 1] < pts[i, 1])
        )
        # Exclude self
        dominates_i[i] = False
        if np.any(dominates_i):
            is_nondom[i] = False
    pareto_df = df[is_nondom].copy()
    pareto_df = pareto_df.sort_values(by=[x_col, y_col])
    return pareto_df


def main():
    ax_client = AxClient()

    ax_client.create_experiment(
        name="water_treatment_multiobjective",
        parameters=[
            {
                "name": P_COAG,
                "type": "range",
                "bounds": [5.0, 20.0],
                "value_type": "float",
            },
            {
                "name": P_FLOC,
                "type": "range",
                "bounds": [1.0, 8.0],
                "value_type": "float",
            },
            {
                "name": P_DISINF,
                "type": "range",
                "bounds": [2.0, 10.0],
                "value_type": "float",
            },
        ],
        objectives={
            OBJ_CONTAM: ObjectiveProperties(minimize=True),  # thresholds inferred
            OBJ_COST: ObjectiveProperties(minimize=True),
        },
    )

    # Run optimization for the given budget
    N_TRIALS = 32
    for _ in range(N_TRIALS):
        parameterization, trial_index = ax_client.get_next_trial()
        results = evaluate_water_treatment(parameterization)
        ax_client.complete_trial(trial_index=trial_index, raw_data=results)

    # Fetch observed data and plot observed Pareto front
    df = ax_client.get_trials_data_frame()
    # Keep only completed trials with metrics present
    df = df.dropna(subset=[OBJ_CONTAM, OBJ_COST])

    # Compute observed Pareto front
    pareto_df = _compute_pareto_front(df, OBJ_CONTAM, OBJ_COST)

    # Plot observed points and Pareto front
    fig, ax = plt.subplots(figsize=(7, 5), dpi=150)
    ax.scatter(df[OBJ_CONTAM], df[OBJ_COST], fc="None", ec="k", label="Observed")
    ax.plot(
        pareto_df[OBJ_CONTAM],
        pareto_df[OBJ_COST],
        color="#0033FF",
        lw=2,
        marker="o",
        ms=4,
        label="Observed Pareto Front",
    )
    ax.set_xlabel("Effluent contaminant level (ppb)")
    ax.set_ylabel("Treatment cost ($/mÂ³)")
    ax.set_title("Water Treatment Optimization: Cost vs. Effluent Contaminant")
    ax.legend()
    plt.tight_layout()
    plt.show()


if __name__ == "__main__":
    main()