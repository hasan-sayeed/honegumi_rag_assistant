# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


obj1_name = "branin"
obj2_name = "branin_swapped"


def branin_moo(x1, x2):
    y = float(
        (x2 - 5.1 / (4 * np.pi**2) * x1**2 + 5.0 / np.pi * x1 - 6.0) ** 2
        + 10 * (1 - 1.0 / (8 * np.pi)) * np.cos(x1)
        + 10
    )

    # second objective has x1 and x2 swapped
    y2 = float(
        (x1 - 5.1 / (4 * np.pi**2) * x2**2 + 5.0 / np.pi * x2 - 6.0) ** 2
        + 10 * (1 - 1.0 / (8 * np.pi)) * np.cos(x2)
        + 10
    )

    return {obj1_name: y, obj2_name: y2}


ax_client = AxClient()

ax_client.create_experiment(
    parameters=[
        {"name": "x1", "type": "range", "bounds": [-5.0, 10.0]},
        {"name": "x2", "type": "range", "bounds": [0.0, 10.0]},
    ],
    objectives={
        obj1_name: ObjectiveProperties(minimize=True),
        obj2_name: ObjectiveProperties(minimize=True),
    },
    parameter_constraints=[
        "x1 + x2 <= 15.0",  # example of a sum constraint
    ],
)


for i in range(19):

    parameterization, trial_index = ax_client.get_next_trial()

    # extract parameters
    x1 = parameterization["x1"]
    x2 = parameterization["x2"]

    results = branin_moo(x1, x2)
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)
pareto_results = ax_client.get_pareto_optimal_parameters()


# Plot results
objectives = ax_client.objective_names
df = ax_client.get_trials_data_frame()

fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
pareto = ax_client.get_pareto_optimal_parameters(use_model_predictions=False)
pareto_data = [p[1][0] for p in pareto.values()]
pareto = pd.DataFrame(pareto_data).sort_values(objectives[0])

ax.scatter(df[objectives[0]], df[objectives[1]], fc="None", ec="k", label="Observed")
ax.plot(
    pareto[objectives[0]],
    pareto[objectives[1]],
    color="#0033FF",
    lw=2,
    label="Pareto Front",
)
ax.set_xlabel(objectives[0])
ax.set_ylabel(objectives[1])

ax.legend()
plt.show()

# Generated from a Honegumi skeleton and adapted for steel alloy multi-objective optimization
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt
from typing import Dict, Tuple


# Problem-specific objective names
strength_metric = "strength"  # MPa, higher is better
corrosion_metric = "corrosion_resistance"  # score proxy, higher is better


def evaluate_alloy(Cr: float, Ni: float, Mo: float, rng: np.random.Generator) -> Dict[str, Tuple[float, float]]:
    """Evaluate steel alloy performance given Chromium, Nickel, Molybdenum contents (wt%).
    
    This is a realistic simulation stub capturing plausible metallurgical trends:
    - Strength increases with Mo and Cr, with diminishing returns and an optimal region.
    - Corrosion resistance improves with Cr and Mo; Ni provides secondary benefits.
    - Includes interaction terms and curvature to create trade-offs.
    - Adds measurement noise and returns (mean, SEM) for each objective.
    
    NOTE: Replace this with actual experimental measurement or high-fidelity simulation:
      - Run melt + heat treatment, measure tensile strength (MPa) and corrosion resistance metric.
      - If your corrosion measurement is a corrosion rate in mpy (lower is better), invert it
        or define a resistance score where higher is better to match the objective direction.
    """
    total = Cr + Ni + Mo

    # Base models with interactions and curvature (plausible but synthetic)
    # Strength model (MPa)
    strength_det = (
        400.0
        + 28.0 * Cr
        + 18.0 * Ni
        + 55.0 * Mo
        + 0.9 * Cr * Mo
        - 0.45 * (Cr - 17.0) ** 2
        - 0.30 * (Ni - 10.0) ** 2
        - 1.20 * (Mo - 3.2) ** 2
    )
    # Mild processing penalty if total alloying is very low (less strengthening)
    strength_det += 0.5 * (total - 25.0)

    # Corrosion resistance score (higher is better); proxy for passive film stability
    corrosion_det = (
        50.0
        + 3.8 * Cr
        + 6.5 * Mo
        + 1.2 * Ni
        + 0.55 * Cr * Mo
        - 0.22 * (Cr - 18.0) ** 2
        - 0.65 * (Mo - 3.6) ** 2
        - 0.12 * (Ni - 9.0) ** 2
    )
    # Benefit for higher total alloying up to the cap (passivation tendency)
    corrosion_det += 0.4 * min(total, 40.0)

    # Reasonable clipping to avoid negative artifacts
    strength_det = float(np.clip(strength_det, 200.0, 2000.0))
    corrosion_det = float(np.clip(corrosion_det, 1.0, 200.0))

    # Add experimental noise (simulate process + measurement noise)
    strength_noise_sd = 15.0  # MPa
    corrosion_noise_sd = 1.5  # score units

    strength_obs = strength_det + rng.normal(0.0, strength_noise_sd)
    corrosion_obs = corrosion_det + rng.normal(0.0, corrosion_noise_sd)

    # Standard error of measurement (SEM) placeholders; adjust per your lab
    strength_sem = 5.0
    corrosion_sem = 0.5

    return {
        strength_metric: (float(strength_obs), float(strength_sem)),
        corrosion_metric: (float(corrosion_obs), float(corrosion_sem)),
    }


# Set reproducibility seed for the simulation stub (does not affect Ax optimization randomness)
rng = np.random.default_rng(12345)

# Initialize Ax client for multi-objective Bayesian optimization
ax_client = AxClient()

# Define the experiment with composition parameters and a sum constraint
ax_client.create_experiment(
    name="steel_alloy_moo",
    parameters=[
        {"name": "Cr", "type": "range", "bounds": [10.0, 20.0]},  # Chromium (wt%)
        {"name": "Ni", "type": "range", "bounds": [5.0, 15.0]},   # Nickel (wt%)
        {"name": "Mo", "type": "range", "bounds": [1.0, 5.0]},    # Molybdenum (wt%)
    ],
    objectives={
        strength_metric: ObjectiveProperties(minimize=False),
        corrosion_metric: ObjectiveProperties(minimize=False),
    },
    parameter_constraints=[
        "Cr + Ni + Mo <= 40.0",  # Total alloying addition cap (wt%)
    ],
    # Let Ax infer thresholds; using default GP-based EHVI for multi-objective
)

# Budget: 40 melts (trials)
num_trials = 40

for _ in range(num_trials):
    parameterization, trial_index = ax_client.get_next_trial()
    Cr = float(parameterization["Cr"])
    Ni = float(parameterization["Ni"])
    Mo = float(parameterization["Mo"])

    try:
        results = evaluate_alloy(Cr=Cr, Ni=Ni, Mo=Mo, rng=rng)
    except Exception as e:
        # Mark trial as failed on error
        ax_client.log_trial_failure(trial_index=trial_index)
        print(f"Trial {trial_index} failed: {e}")
        continue

    ax_client.complete_trial(trial_index=trial_index, raw_data=results)

# Retrieve Pareto-optimal observed points
pareto_mapping = ax_client.get_pareto_optimal_parameters(use_model_predictions=False)

# Plot results
metrics = [strength_metric, corrosion_metric]
df = ax_client.get_trials_data_frame()

fig, ax = plt.subplots(figsize=(7, 5), dpi=150)

# Observed scatter
if all(m in df.columns for m in metrics):
    ax.scatter(
        df[metrics[0]],
        df[metrics[1]],
        fc="None",
        ec="k",
        label="Observed",
        alpha=0.7,
    )

# Extract Pareto front for plotting
# pareto_mapping: Dict[ArmParameterization, Tuple[Dict[metric -> (mean, sem)], metadata]]
pareto_points = []
for values_meta in pareto_mapping.values():
    values_dict = values_meta[0]  # metric -> (mean, sem)
    if metrics[0] in values_dict and metrics[1] in values_dict:
        pareto_points.append(
            {metrics[0]: values_dict[metrics[0]][0], metrics[1]: values_dict[metrics[1]][0]}
        )

if len(pareto_points) > 0:
    pareto_df = pd.DataFrame(pareto_points).sort_values(metrics[0])
    ax.plot(
        pareto_df[metrics[0]],
        pareto_df[metrics[1]],
        color="#0033FF",
        lw=2,
        label="Pareto Front (observed)",
    )

ax.set_xlabel(f"{metrics[0]} (MPa)")
ax.set_ylabel(f"{metrics[1]} (arb. score)")
ax.set_title("Steel Alloy Optimization: Strength vs. Corrosion Resistance")
ax.legend()
plt.tight_layout()
plt.show()