# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


# Domain-specific objective names
bond_strength_metric = "bond_strength"  # MPa, to maximize
cure_time_metric = "cure_time"          # hours, to minimize

# Compositional total for resin components + hardener
composition_total = 1.0

# Noise levels (SEM) for simulated measurements
STRENGTH_NOISE_SD = 1.0  # MPa
CURETIME_NOISE_SD = 0.10  # hours


def evaluate_adhesive_formulation(resin_A: float, resin_B: float, resin_C: float, hardener: float):
    """
    Simulate evaluation of an adhesive formulation.
    Inputs are fractions that sum to 1.0:
      resin_A, resin_B, resin_C in [0.10, 0.40]
      hardener in [0.20, 0.50]
    Returns:
      - bond_strength (MPa), to maximize
      - cure_time (hours), to minimize

    This is a realistic stub:
      - Bond strength is maximized when hardener ~ 0.30 and resin ratios ~ A:B:C = 50:30:20
      - Cure time is shorter with more hardener and more A, and longer with more C
      - Adds Gaussian measurement noise with known SEMs
    """
    # Guard against floating point drift
    eps = 1e-9
    total = resin_A + resin_B + resin_C + hardener
    if abs(total - 1.0) > 1e-6:
        # Re-normalize defensively (should not happen with our constraints)
        scale = composition_total / total
        resin_A *= scale
        resin_B *= scale
        resin_C *= scale
        hardener *= scale

    # Normalize resin ratios among resin-only portion
    resin_total = max(resin_A + resin_B + resin_C, eps)
    a_n = resin_A / resin_total
    b_n = resin_B / resin_total
    c_n = resin_C / resin_total

    # Bond strength model (MPa)
    # - Gaussian preference around hardener=0.30
    hardener_opt = 0.30
    hardener_width = 0.08
    hardener_effect = np.exp(-0.5 * ((hardener - hardener_opt) / hardener_width) ** 2)

    # - Preferred resin ratios A:B:C ~ 0.5 : 0.3 : 0.2
    resin_pref = np.array([0.5, 0.3, 0.2])
    resin_vec = np.array([a_n, b_n, c_n])
    resin_mismatch = np.sum((resin_vec - resin_pref) ** 2)  # smaller is better
    resin_synergy = np.exp(-8.0 * resin_mismatch)

    # - Mild interaction to encourage A-B synergy
    ab_synergy = 1.0 + 0.2 * (a_n * b_n)

    # - Base strength and scaling
    strength_base = 35.0  # MPa baseline
    strength = strength_base + 30.0 * hardener_effect * resin_synergy * ab_synergy

    # - Small penalty if resin_total is too high (viscosity tradeoff)
    #   With our constraints resin_total in [0.5, 0.8]
    strength -= 5.0 * max(0.0, (resin_total - 0.70))

    # Cure time model (hours)
    # - Faster with more hardener, slower with more C
    cure_time = 8.0 - 10.0 * (hardener - 0.20)  # maps 0.20->8.0h, 0.50->5.0h
    cure_time += 1.5 * c_n - 0.5 * a_n  # C slows, A slightly speeds

    # Add noise
    strength_meas = strength + np.random.normal(0.0, STRENGTH_NOISE_SD)
    cure_time_meas = cure_time + np.random.normal(0.0, CURETIME_NOISE_SD)

    return {
        bond_strength_metric: (float(strength_meas), STRENGTH_NOISE_SD),
        cure_time_metric: (float(cure_time_meas), CURETIME_NOISE_SD),
    }


ax_client = AxClient()

# Re-parameterize composition:
# - Optimize resin_A, resin_B, resin_C within [0.10, 0.40]
# - Enforce 0.20 <= hardener = 1 - (A + B + C) <= 0.50
#   which is equivalent to:
#     A + B + C >= 0.50  and  A + B + C <= 0.80
ax_client.create_experiment(
    name="adhesive_moo_optimization",
    parameters=[
        {"name": "resin_A", "type": "range", "bounds": [0.10, 0.40]},
        {"name": "resin_B", "type": "range", "bounds": [0.10, 0.40]},
        {"name": "resin_C", "type": "range", "bounds": [0.10, 0.40]},
    ],
    objectives={
        bond_strength_metric: ObjectiveProperties(minimize=False),
        cure_time_metric: ObjectiveProperties(minimize=True),
    },
    parameter_constraints=[
        "resin_A + resin_B + resin_C <= 0.80",  # ensures hardener >= 0.20
        "resin_A + resin_B + resin_C >= 0.50",  # ensures hardener <= 0.50
    ],
)

# Budget: 40 trials
for i in range(40):
    parameterization, trial_index = ax_client.get_next_trial()

    # Extract resin components
    resin_A = parameterization["resin_A"]
    resin_B = parameterization["resin_B"]
    resin_C = parameterization["resin_C"]

    # Compute hardener from the composition constraint
    hardener = composition_total - (resin_A + resin_B + resin_C)

    # Floating point safety: clamp to bounds by a tiny margin if necessary
    hardener = float(np.clip(hardener, 0.20, 0.50))

    results = evaluate_adhesive_formulation(resin_A, resin_B, resin_C, hardener)
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)

# Get Pareto-optimal set based on observed data
pareto = ax_client.get_pareto_optimal_parameters(use_model_predictions=False)

# Plot results
objectives = ax_client.objective_names
df = ax_client.get_trials_data_frame()

fig, ax = plt.subplots(figsize=(6, 4), dpi=150)

# Observed scatter
ax.scatter(
    df[objectives[0]],
    df[objectives[1]],
    fc="None",
    ec="k",
    label="Observed",
)

# Pareto frontier (empirical)
pareto_data = [p[1][0] for p in pareto.values()]
pareto_df = pd.DataFrame(pareto_data).sort_values(objectives[0])
ax.plot(
    pareto_df[objectives[0]],
    pareto_df[objectives[1]],
    color="#0033FF",
    lw=2,
    label="Pareto Front",
)

# Axis labels with units
xlabel = f"{objectives[0]} ({'MPa' if objectives[0]==bond_strength_metric else 'hours'})"
ylabel = f"{objectives[1]} ({'MPa' if objectives[1]==bond_strength_metric else 'hours'})"
ax.set_xlabel(xlabel)
ax.set_ylabel(ylabel)
ax.legend()
plt.tight_layout()
plt.show()