# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


obj1_name = "branin"


def branin(x1, x2):
    y = float(
        (x2 - 5.1 / (4 * np.pi**2) * x1**2 + 5.0 / np.pi * x1 - 6.0) ** 2
        + 10 * (1 - 1.0 / (8 * np.pi)) * np.cos(x1)
        + 10
    )

    return y


ax_client = AxClient()

ax_client.create_experiment(
    parameters=[
        {"name": "x1", "type": "range", "bounds": [-5.0, 10.0]},
        {"name": "x2", "type": "range", "bounds": [0.0, 10.0]},
    ],
    objectives={
        obj1_name: ObjectiveProperties(minimize=True),
    },
)


for i in range(19):

    parameterization, trial_index = ax_client.get_next_trial()

    # extract parameters
    x1 = parameterization["x1"]
    x2 = parameterization["x2"]

    results = branin(x1, x2)
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)

best_parameters, metrics = ax_client.get_best_parameters()


# Plot results
objectives = ax_client.objective_names
df = ax_client.get_trials_data_frame()

fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
ax.scatter(df.index, df[objectives], ec="k", fc="none", label="Observed")
ax.plot(
    df.index,
    np.minimum.accumulate(df[objectives]),
    color="#0033FF",
    lw=2,
    label="Best to Trial",
)
ax.set_xlabel("Trial Number")
ax.set_ylabel(objectives[0])

ax.legend()
plt.show()

# Bayesian Optimization for Calcination Conditions to Maximize Catalytic Activity
# Requires: ax-platform==0.4.3, matplotlib, numpy, pandas
# %pip install ax-platform==0.4.3 matplotlib numpy pandas

import math
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from typing import Dict, Tuple

from ax.service.ax_client import AxClient, ObjectiveProperties


# Domain-specific metric and parameter names
objective_name = "catalytic_activity"  # μmol/g·s
temperature_param = "temperature_celsius"  # °C
time_param = "time_hours"  # hours


def measure_catalytic_activity(
    temperature_celsius: float, time_hours: float, rng: np.random.Generator
) -> Tuple[float, float]:
    """
    Simulated measurement of catalytic activity (μmol/g·s) as a function of calcination
    temperature (°C) and time (hours). This stub encodes typical physical behavior:
      - Activity increases with temperature/time due to phase formation, then decreases
        due to sintering at overly harsh conditions.
      - There is an interaction between high temperature and long time (accelerated sintering).
      - Measurement noise is included to reflect standard protocols.

    Replace this function with actual experimental measurement logic as needed.
    For real experiments:
      - Run the calcination under the provided conditions.
      - Measure catalytic activity (μmol/g·s) following your standard protocol.
      - Return (mean_value, standard_error_of_mean).

    Parameters:
      temperature_celsius: float in [300, 600]
      time_hours: float in [2, 8]
      rng: numpy.random.Generator for reproducible noise

    Returns:
      (mean_activity, sem_activity) in μmol/g·s
    """

    # Physically plausible response surface (peaked with interaction)
    # Peak near moderate-high T and intermediate time
    T = temperature_celsius
    t = time_hours

    # Base peak (tunable to typical magnitude for your catalyst/system)
    base_peak = 180.0  # μmol/g·s maximum scale

    # Unimodal peak parameters (center and spread)
    T_opt, t_opt = 500.0, 5.0
    sigma_T, sigma_t = 40.0, 1.2

    # Gaussian-like peak
    gauss_T = math.exp(-0.5 * ((T - T_opt) / sigma_T) ** 2)
    gauss_t = math.exp(-0.5 * ((t - t_opt) / sigma_t) ** 2)

    # Interaction penalty for sintering at high T and long t
    high_T_activation = 1.0 / (1.0 + math.exp(-(T - 540.0) / 8.0))  # switches on above ~540°C
    long_t_factor = max(0.0, (t - 4.5) / 4.0)  # grows when t > ~4.5 h
    sintering_penalty = 1.0 - 0.22 * high_T_activation * long_t_factor  # up to ~22% reduction

    # Secondary mild benefit at moderately long times (crystallinity improvement)
    crystallinity_boost = 1.0 + 0.05 * math.exp(-0.5 * ((t - 6.0) / 1.5) ** 2)

    # Combine effects
    noiseless_activity = base_peak * gauss_T * gauss_t * sintering_penalty * crystallinity_boost

    # Add heteroscedastic measurement noise (multiplicative + additive)
    multiplicative_noise = rng.normal(loc=1.0, scale=0.03)  # ~3% RSD
    additive_noise = rng.normal(loc=0.0, scale=1.5)  # small baseline noise in μmol/g·s

    measured_activity = max(0.0, noiseless_activity * multiplicative_noise + additive_noise)

    # Standard error of mean: assume 3 replicates as a typical protocol
    # SEM modeled as combination of a fraction of activity and baseline floor
    sem_activity = 0.02 * measured_activity + 1.0  # μmol/g·s

    return float(measured_activity), float(sem_activity)


def main():
    # Reproducibility
    rng = np.random.default_rng(seed=42)

    # Create Ax client (sequential trials, single-objective)
    ax_client = AxClient(enforce_sequential_optimization=True)
    ax_client.create_experiment(
        name="calcination_catalytic_activity_optimization",
        parameters=[
            {
                "name": temperature_param,
                "type": "range",
                "bounds": [300.0, 600.0],
                "value_type": "float",
            },
            {
                "name": time_param,
                "type": "range",
                "bounds": [2.0, 8.0],
                "value_type": "float",
            },
        ],
        objectives={
            objective_name: ObjectiveProperties(minimize=False),
        },
        # No additional outcome constraints; single-task, default GP model
    )

    # Optimization budget
    n_trials = 25

    for _ in range(n_trials):
        parameterization, trial_index = ax_client.get_next_trial()

        # Extract parameters
        T = float(parameterization[temperature_param])
        t = float(parameterization[time_param])

        try:
            # Measure the objective with realistic noise
            mean_activity, sem_activity = measure_catalytic_activity(T, t, rng)
            ax_client.complete_trial(
                trial_index=trial_index,
                raw_data={objective_name: (mean_activity, sem_activity)},
            )
        except Exception:
            # In real lab automation, you may log metadata here
            ax_client.log_trial_failure(trial_index=trial_index)

    # Report best found parameters
    best_parameters, best_values = ax_client.get_best_parameters()
    best_mean = best_values[objective_name]["mean"]
    best_sem = best_values[objective_name].get("sem", None)

    print("Best calcination conditions found (within 25 trials):")
    print(f"  {temperature_param}: {best_parameters[temperature_param]:.2f} °C")
    print(f"  {time_param}: {best_parameters[time_param]:.2f} h")
    if best_sem is not None:
        print(f"  Expected {objective_name}: {best_mean:.2f} ± {best_sem:.2f} μmol/g·s")
    else:
        print(f"  Expected {objective_name}: {best_mean:.2f} μmol/g·s")

    # Visualization of progress and design space coverage
    df = ax_client.get_trials_data_frame()

    # Ensure only completed trials are considered
    if "trial_status" in df.columns:
        df = df[df["trial_status"] == "COMPLETED"]

    if df.empty:
        print("No completed trials to visualize.")
        return

    # Extract series
    if "trial_index" in df.columns:
        x_trials = df["trial_index"].values
    else:
        x_trials = np.arange(len(df), dtype=int)

    y_obs = df[objective_name].values

    # Plot objective versus trial number with cumulative best (maximization)
    fig, ax = plt.subplots(figsize=(7, 4.5), dpi=150)
    ax.scatter(x_trials, y_obs, ec="k", fc="none", label="Observed")
    ax.plot(x_trials, np.maximum.accumulate(y_obs), color="#0033FF", lw=2, label="Best so far")
    ax.set_xlabel("Trial Number")
    ax.set_ylabel(f"{objective_name} (μmol/g·s)")
    ax.set_title("Bayesian Optimization of Calcination Conditions")
    ax.legend()
    plt.tight_layout()
    plt.show()

    # Scatter of temperature vs time colored by observed activity
    if temperature_param in df.columns and time_param in df.columns:
        fig2, ax2 = plt.subplots(figsize=(6, 5), dpi=150)
        sc = ax2.scatter(
            df[temperature_param].values,
            df[time_param].values,
            c=df[objective_name].values,
            cmap="viridis",
            s=60,
            edgecolor="k",
        )
        ax2.set_xlabel(f"{temperature_param} (°C)")
        ax2.set_ylabel(f"{time_param} (h)")
        ax2.set_title("Explored Conditions and Activity")
        cb = plt.colorbar(sc, ax=ax2)
        cb.set_label(f"{objective_name} (μmol/g·s)")
        plt.tight_layout()
        plt.show()


if __name__ == "__main__":
    main()