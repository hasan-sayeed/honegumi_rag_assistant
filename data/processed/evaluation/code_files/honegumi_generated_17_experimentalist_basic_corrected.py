# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


# Problem: Optimize laser cutting for minimum edge roughness (micrometers)
# Parameters:
#   - laser_power_watt: 500–2000 W
#   - cutting_speed_mm_per_s: 10–100 mm/s
# Objective:
#   - edge_roughness_micrometer: minimize (repeatable measurements -> zero SEM)


objective_name = "edge_roughness_micrometer"


def evaluate_laser_cut_roughness(laser_power_watt: float, cutting_speed_mm_per_s: float) -> float:
    """Deterministic surrogate for edge roughness (µm) in laser cutting.

    This function is a realistic, noise-free proxy for physical measurements:
    - Roughness is lowest near a balanced regime (moderate power/speed).
    - Too low or too high power increases roughness (lack of fusion vs. burn).
    - Speed interacts with power: too fast or too slow increases roughness.

    If integrating with a real setup, replace this with:
    - A call to the machine control API to run a cut at (power, speed)
    - A measurement routine to compute edge roughness (Ra/Rz) in micrometers
    - Return the measured roughness value (float)

    Args:
        laser_power_watt: Laser power in watts [500, 2000].
        cutting_speed_mm_per_s: Cutting speed in mm/s [10, 100].

    Returns:
        Edge roughness in micrometers (float), lower is better.
    """
    # Nominal "sweet spot" derived from domain intuition
    p_opt = 1250.0  # W
    v_opt = 55.0    # mm/s

    # Normalize around the sweet spot to shape curvature and interaction
    p_n = (laser_power_watt - p_opt) / 350.0
    v_n = (cutting_speed_mm_per_s - v_opt) / 22.0

    # Quadratic bowl with interaction term (convex near optimum)
    base = 2.8 + 1.7 * p_n**2 + 2.1 * v_n**2 + 0.6 * p_n * v_n

    # Gentle nonlinearities to avoid purely quadratic surface
    ripple = 0.18 * np.sin(np.pi * laser_power_watt / 260.0) + 0.12 * np.cos(np.pi * cutting_speed_mm_per_s / 36.0)

    # Penalize extreme regimes slightly stronger to mimic process instability
    extreme_penalty = 0.25 * max(0.0, abs(p_n) - 1.2) ** 2 + 0.25 * max(0.0, abs(v_n) - 1.2) ** 2

    roughness_um = float(base + ripple + extreme_penalty)

    # Ensure non-negative, realistic minimum
    roughness_um = max(0.3, roughness_um)
    return roughness_um


ax_client = AxClient()

ax_client.create_experiment(
    name="laser_cutting_edge_roughness_optimization",
    parameters=[
        {"name": "laser_power_watt", "type": "range", "bounds": [500.0, 2000.0]},
        {"name": "cutting_speed_mm_per_s", "type": "range", "bounds": [10.0, 100.0]},
    ],
    objectives={
        objective_name: ObjectiveProperties(minimize=True),
    },
)


# Budget: 30 cuts (noise-free measurements)
num_trials = 30
for _ in range(num_trials):
    parameterization, trial_index = ax_client.get_next_trial()

    # Extract parameters for this trial
    laser_power_watt = float(parameterization["laser_power_watt"])
    cutting_speed_mm_per_s = float(parameterization["cutting_speed_mm_per_s"])

    try:
        # Evaluate edge roughness deterministically (SEM = 0.0 since repeatable)
        roughness_um = evaluate_laser_cut_roughness(laser_power_watt, cutting_speed_mm_per_s)
        ax_client.complete_trial(
            trial_index=trial_index,
            raw_data={objective_name: (roughness_um, 0.0)},
        )
    except Exception as e:
        # If the real experiment fails, mark the trial failed and continue
        print(f"Trial {trial_index} failed due to error: {e}")
        ax_client.log_trial_failure(trial_index=trial_index)


best_parameters, best_metrics = ax_client.get_best_parameters()
best_roughness_um = best_metrics[objective_name]["mean"]

print("Best settings found:")
print(f"  laser_power_watt: {best_parameters['laser_power_watt']:.3f} W")
print(f"  cutting_speed_mm_per_s: {best_parameters['cutting_speed_mm_per_s']:.3f} mm/s")
print(f"Estimated best edge roughness: {best_roughness_um:.4f} µm")


# Plot results
objectives = ax_client.objective_names
df = ax_client.get_trials_data_frame()

# Only keep completed trials with available metric values
df = df.dropna(subset=[objective_name])

fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
ax.scatter(df.index, df[objective_name], ec="k", fc="none", label="Observed")
ax.plot(
    df.index,
    np.minimum.accumulate(df[objective_name]),
    color="#0033FF",
    lw=2,
    label="Best to Trial",
)
ax.set_xlabel("Trial Number")
ax.set_ylabel("Edge Roughness (µm)")
ax.set_title("Laser Cutting Optimization: Edge Roughness vs Trial")
ax.legend()
plt.tight_layout()
plt.show()