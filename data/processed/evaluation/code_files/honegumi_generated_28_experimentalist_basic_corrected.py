# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


metric_name = "extraction_efficiency"


def run_solvent_extraction(temperature_celsius: float, solvent_to_feed_ratio_vv: float) -> float:
    """
    Deterministic surrogate for solvent extraction efficiency (%).

    This function encodes a plausible response surface:
    - Efficiency increases with solvent-to-feed ratio with diminishing returns.
    - Efficiency peaks around a moderate temperature (approx. 45°C) due to competing kinetics/volatility.
    - Interaction provides a slight synergy when both factors are favorable.
    The output is clipped to [0, 100] to represent percent efficiency.

    Parameters
    ----------
    temperature_celsius : float
        Extraction temperature in °C (20–60).
    solvent_to_feed_ratio_vv : float
        Solvent-to-feed volume ratio (v/v), 1.0–5.0.

    Returns
    -------
    float
        Extraction efficiency in percent (%), deterministic.
    """
    # Bounds check to help catch mis-specified trials
    if not (20.0 <= temperature_celsius <= 60.0):
        raise ValueError("temperature_celsius must be within [20, 60] °C.")
    if not (1.0 <= solvent_to_feed_ratio_vv <= 5.0):
        raise ValueError("solvent_to_feed_ratio_vv must be within [1.0, 5.0] v/v.")

    T = float(temperature_celsius)
    R = float(solvent_to_feed_ratio_vv)

    # Temperature effect: bell-shaped peak around ~45°C
    temp_peak = np.exp(-0.5 * ((T - 45.0) / 8.0) ** 2)  # in (0, 1]

    # Solvent ratio effect: saturating increase from 1:1 to 1:5
    solv_saturation = 1.0 - np.exp(-1.0 * (R - 1.0))  # in [0, ~0.98]

    # Base model: combine effects multiplicatively with offsets to avoid zeroing out
    base = 20.0 + 80.0 * (0.2 + 0.8 * solv_saturation) * (0.3 + 0.7 * temp_peak)

    # Mild synergy term when both effects are strong
    synergy = 5.0 * solv_saturation * temp_peak

    efficiency = base + synergy

    # Clip to valid percent range
    return float(np.clip(efficiency, 0.0, 100.0))


ax_client = AxClient()

ax_client.create_experiment(
    parameters=[
        {"name": "temperature_celsius", "type": "range", "bounds": [20.0, 60.0]},
        {"name": "solvent_to_feed_ratio_vv", "type": "range", "bounds": [1.0, 5.0]},
    ],
    objectives={
        metric_name: ObjectiveProperties(minimize=False),
    },
)

# Budget: 26 experiments (deterministic measurements)
for i in range(26):
    parameterization, trial_index = ax_client.get_next_trial()

    # Extract parameters
    temperature_celsius = parameterization["temperature_celsius"]
    solvent_to_feed_ratio_vv = parameterization["solvent_to_feed_ratio_vv"]

    # Deterministic evaluation (noise-free)
    efficiency_percent = run_solvent_extraction(temperature_celsius, solvent_to_feed_ratio_vv)
    ax_client.complete_trial(trial_index=trial_index, raw_data=efficiency_percent)

best_parameters, best_metrics = ax_client.get_best_parameters()
best_efficiency = best_metrics[metric_name]["mean"]
print("Best parameters found:")
print(best_parameters)
print(f"Best extraction efficiency: {best_efficiency:.2f} %")

# Plot results
df = ax_client.get_trials_data_frame()
y = df[metric_name].values

fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
ax.scatter(df.index, y, ec="k", fc="none", label="Observed")
ax.plot(df.index, np.maximum.accumulate(y), color="#0033FF", lw=2, label="Best to Trial")
ax.set_xlabel("Trial Number")
ax.set_ylabel("Extraction Efficiency (%)")
ax.legend()
plt.tight_layout()
plt.show()