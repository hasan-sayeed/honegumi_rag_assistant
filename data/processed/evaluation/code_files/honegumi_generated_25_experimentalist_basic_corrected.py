# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from typing import Tuple, Dict

from ax.service.ax_client import AxClient, ObjectiveProperties


# Metric (objective) name
biomass_metric_name = "biomass_yield"


# Reproducible randomness for simulated biological variability
_rng = np.random.default_rng(2025)


def simulate_fermentation_biomass_yield(
    glucose_g_per_L: float,
    nitrogen_source_g_per_L: float,
    phosphate_g_per_L: float,
) -> Tuple[float, float]:
    """
    Simulate biomass yield (g/L) for a batch fermentation given nutrient concentrations.
    Returns a tuple: (measured_yield_mean, measurement_sem).

    This function implements a plausible biological response:
    - Saturation kinetics for each nutrient (Monod-like).
    - Liebig's law of the minimum (limiting nutrient governs).
    - Mild inhibition at higher concentrations for each nutrient.
    - Adds stochastic measurement/process noise to emulate biological variability.

    Replace this with actual experimental measurement in production.
    """

    # Monod half-saturation (g/L), tuned to be within provided ranges
    K_glucose = 8.0
    K_nitrogen = 1.5
    K_phosphate = 0.5

    # Saturation terms in [0, 1]
    s_glc = glucose_g_per_L / (K_glucose + glucose_g_per_L)
    s_nit = nitrogen_source_g_per_L / (K_nitrogen + nitrogen_source_g_per_L)
    s_pho = phosphate_g_per_L / (K_phosphate + phosphate_g_per_L)

    # Limiting factor (Liebig's minimum)
    limiting = min(s_glc, s_nit, s_pho)

    # Maximum achievable biomass yield (g/L) under ideal conditions
    Y_max = 14.0

    # Base yield before inhibition
    base_yield = Y_max * limiting

    # Concentration-dependent inhibition (Gaussian penalties centered near upper mid-range)
    # Tuned so that extreme high concentrations slightly reduce yield.
    inh_glc = np.exp(-((glucose_g_per_L - 22.0) / 10.0) ** 2)
    inh_nit = np.exp(-((nitrogen_source_g_per_L - 6.0) / 3.0) ** 2)
    inh_pho = np.exp(-((phosphate_g_per_L - 2.2) / 1.5) ** 2)

    inhibition_factor = inh_glc * inh_nit * inh_pho

    # Mean yield without noise
    mean_yield = base_yield * (0.75 + 0.25 * inhibition_factor)

    # Additive noise (g/L) increases slightly with signal level to mimic heteroscedasticity
    sigma = 0.1 * mean_yield + 0.3
    measured_yield = mean_yield + _rng.normal(0.0, sigma)

    # Physical realism: negative yields are not possible
    measured_yield = float(max(measured_yield, 0.0))

    # SEM estimate (g/L); here we report our noise model's sigma as an uncertainty proxy
    measurement_sem = float(max(sigma, 1e-6))

    return measured_yield, measurement_sem


# Initialize Ax client
ax_client = AxClient()

# Define the experiment with the exact problem parameters and single objective (maximize yield)
ax_client.create_experiment(
    parameters=[
        {"name": "glucose_g_per_L", "type": "range", "bounds": [5.0, 30.0], "value_type": "float"},
        {"name": "nitrogen_source_g_per_L", "type": "range", "bounds": [1.0, 8.0], "value_type": "float"},
        {"name": "phosphate_g_per_L", "type": "range", "bounds": [0.5, 3.0], "value_type": "float"},
    ],
    objectives={
        biomass_metric_name: ObjectiveProperties(minimize=False),
    },
    name="fermentation_biomass_optimization",
)

# Budget: 30 trials
num_trials = 30

for _ in range(num_trials):
    parameterization, trial_index = ax_client.get_next_trial()

    # Extract parameters
    glucose = float(parameterization["glucose_g_per_L"])
    nitrogen = float(parameterization["nitrogen_source_g_per_L"])
    phosphate = float(parameterization["phosphate_g_per_L"])

    # Evaluate (simulate) biomass yield with biological variability
    measured_yield, sem = simulate_fermentation_biomass_yield(glucose, nitrogen, phosphate)

    # Report result to Ax with uncertainty (SEM)
    ax_client.complete_trial(
        trial_index=trial_index,
        raw_data={biomass_metric_name: (measured_yield, sem)},
    )

# Retrieve best found parameters and corresponding metric
best_parameters, best_metrics = ax_client.get_best_parameters()

print("Best nutrient concentrations found:")
for k, v in best_parameters.items():
    print(f"  {k}: {v:.4g}")
print("\nBest observed biomass yield (g/L):")
for metric_name, metric_val in best_metrics.items():
    # metric_val is a dict like {"mean": ..., "sem": ...}
    print(f"  {metric_name}: mean={metric_val['mean']:.3f}, sem={metric_val['sem']:.3f}")

# Visualization of optimization progress
objectives = ax_client.objective_names  # list with a single entry: biomass_metric_name
df = ax_client.get_trials_data_frame()

# Ensure we work with the single objective Series
metric_series = df[biomass_metric_name]

fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
ax.scatter(df.index, metric_series, ec="k", fc="none", label="Observed (biomass yield)")
ax.plot(
    df.index,
    np.maximum.accumulate(metric_series),
    color="#0033FF",
    lw=2,
    label="Best so far",
)
ax.set_xlabel("Trial Number")
ax.set_ylabel("Biomass yield (g/L)")
ax.set_title("Fermentation optimization: biomass yield over trials")
ax.legend()
plt.tight_layout()
plt.show()