# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


obj1_name = "branin"


def branin(x1, x2):
    y = float(
        (x2 - 5.1 / (4 * np.pi**2) * x1**2 + 5.0 / np.pi * x1 - 6.0) ** 2
        + 10 * (1 - 1.0 / (8 * np.pi)) * np.cos(x1)
        + 10
    )

    return y


ax_client = AxClient()

ax_client.create_experiment(
    parameters=[
        {"name": "x1", "type": "range", "bounds": [-5.0, 10.0]},
        {"name": "x2", "type": "range", "bounds": [0.0, 10.0]},
    ],
    objectives={
        obj1_name: ObjectiveProperties(minimize=True),
    },
)


for i in range(19):

    parameterization, trial_index = ax_client.get_next_trial()

    # extract parameters
    x1 = parameterization["x1"]
    x2 = parameterization["x2"]

    results = branin(x1, x2)
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)

best_parameters, metrics = ax_client.get_best_parameters()


# Plot results
objectives = ax_client.objective_names
df = ax_client.get_trials_data_frame()

fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
ax.scatter(df.index, df[objectives], ec="k", fc="none", label="Observed")
ax.plot(
    df.index,
    np.minimum.accumulate(df[objectives]),
    color="#0033FF",
    lw=2,
    label="Best to Trial",
)
ax.set_xlabel("Trial Number")
ax.set_ylabel(objectives[0])

ax.legend()
plt.show()

# Generated by adapting a Honegumi skeleton for ceramic sintering optimization
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


# Problem-specific names
objective_name = "density_g_per_cm3"
temperature_param = "temperature_celsius"
time_param = "sintering_time_hours"


def measure_density(temperature_celsius: float, sintering_time_hours: float, rng: np.random.Generator) -> dict:
    """Simulate measuring density (g/cm^3) of a ceramic after sintering.

    TODO: Replace this synthetic simulator with actual experimental measurement logic.
    For real experiments:
      - Heat the sample to `temperature_celsius` for `sintering_time_hours`
      - Measure density (e.g., Archimedes method) and return the measured value
      - If replicates are measured, return (mean, SEM) for the objective.

    Parameters
    ----------
    temperature_celsius : float
        Sintering temperature in °C (800–1200).
    sintering_time_hours : float
        Sintering duration in hours (1–6).
    rng : np.random.Generator
        Random number generator for simulating measurement noise.

    Returns
    -------
    dict
        Mapping from objective name to (value, SEM) tuple for the Ax client.
    """
    T = float(temperature_celsius)
    t = float(sintering_time_hours)

    # Synthetic, physics-inspired surrogate:
    # - Logistic densification vs temperature and time
    # - Mild penalties for overheating (abnormal grain growth) and excessively long hold times
    # - Clipped to a realistic density range for typical structural ceramics (example range)
    d_min = 3.0  # g/cm^3, low-density green/poorly sintered
    d_max = 6.0  # g/cm^3, near theoretical for many oxide ceramics

    # Logistic progress for sintering with T and t
    T_mid, T_scale = 1030.0, 40.0
    t_mid, t_scale = 3.0, 0.7
    s_T = 1.0 / (1.0 + np.exp(-(T - T_mid) / T_scale))
    s_t = 1.0 / (1.0 + np.exp(-(t - t_mid) / t_scale))

    # Penalties for over-sintering
    penalty_T = 1.0 - 0.18 * np.exp(-0.5 * ((T - 1180.0) / 25.0) ** 2)
    penalty_t = 1.0 - 0.08 * np.exp(-0.5 * ((t - 5.5) / 0.6) ** 2)
    penalty = max(0.75, penalty_T * penalty_t)

    ideal_density = d_min + (d_max - d_min) * s_T * s_t * penalty

    # Add measurement noise; SEM represents uncertainty of the mean
    measurement_sd = 0.03  # g/cm^3, illustrative single-sample measurement noise
    observed_density = float(np.clip(ideal_density + rng.normal(0.0, measurement_sd), d_min, d_max))
    sem = measurement_sd  # With single measurement, SEM ≈ SD; replace with actual SEM if replicates are used

    return {objective_name: (observed_density, sem)}


def main() -> None:
    rng = np.random.default_rng(2024)

    ax_client = AxClient(enforce_sequential_optimization=True)

    ax_client.create_experiment(
        name="ceramic_sintering_density_optimization",
        parameters=[
            {
                "name": temperature_param,
                "type": "range",
                "bounds": [800.0, 1200.0],
            },
            {
                "name": time_param,
                "type": "range",
                "bounds": [1.0, 6.0],
            },
        ],
        objectives={
            objective_name: ObjectiveProperties(minimize=False),
        },
        overwrite_existing_experiment=True,
    )

    total_trials = 30  # Budget for 20-30 experiments; set to 30 here

    for i in range(total_trials):
        parameterization, trial_index = ax_client.get_next_trial()

        T = float(parameterization[temperature_param])
        t = float(parameterization[time_param])

        try:
            result = measure_density(T, t, rng)
            ax_client.complete_trial(trial_index=trial_index, raw_data=result)
        except Exception as e:
            # If an experiment fails, log failure so Ax can propose another point
            ax_client.log_trial_failure(trial_index=trial_index)
            print(f"Trial {trial_index} failed with error: {e}")

    best_parameters, best_values = ax_client.get_best_parameters()
    best_density = best_values[objective_name]["mean"]
    best_density_sem = best_values[objective_name]["sem"]

    print("Best sintering conditions found:")
    print(f"  {temperature_param}: {best_parameters[temperature_param]:.2f} °C")
    print(f"  {time_param}: {best_parameters[time_param]:.2f} hours")
    print(f"Estimated best {objective_name}: {best_density:.4f} ± {best_density_sem:.4f}")

    # Visualization of optimization progress
    objectives = ax_client.objective_names
    df = ax_client.get_trials_data_frame()
    df = df.sort_index()  # Ensure order by trial index

    fig, ax = plt.subplots(figsize=(7, 4), dpi=150)
    ax.scatter(df.index, df[objectives], ec="k", fc="none", label="Observed")
    ax.plot(
        df.index,
        np.maximum.accumulate(df[objectives].values.squeeze()),
        color="#0033FF",
        lw=2,
        label="Best to Trial",
    )
    ax.set_xlabel("Trial Number")
    ax.set_ylabel(objectives[0])
    ax.set_title("Sintering Optimization: Density over Trials")
    ax.legend()
    plt.tight_layout()
    plt.show()


if __name__ == "__main__":
    main()