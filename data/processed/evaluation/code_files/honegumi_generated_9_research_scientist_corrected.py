# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


# Domain-specific metric
metric_name = "compressive_strength_28d_mpa"  # 28-day compressive strength (MPa)

# Total composition sum for concrete mix (wt%)
TOTAL_WT_PCT = 100.0

# Reproducible randomness for simulated measurement noise
rng = np.random.default_rng(42)


def measure_28day_compressive_strength(
    cement_wt_pct: float,
    water_wt_pct: float,
    aggregate_wt_pct: float,
) -> float:
    """
    Simulated evaluation of 28-day compressive strength (MPa) for a concrete mix.

    This stub mimics realistic behavior based on common empirical relationships:
    - Strength decreases as water-to-cement ratio (w/c) increases (Abrams' law).
    - There is a mild benefit to higher cement content (within practical limits).
    - There is an optimal aggregate fraction around ~70 wt% (penalize deviations).
    - Additive Gaussian noise simulates experimental measurement variability.

    Replace this function with actual experimental measurement or a high-fidelity
    simulation/model as needed.
    """
    # Water-to-cement ratio by weight
    w_c = water_wt_pct / max(cement_wt_pct, 1e-6)

    # Abrams-like influence (decreasing with w/c)
    strength_wcr = 70.0 / (1.0 + 3.0 * w_c)

    # Cement content bonus (diminishing but positive within 15-25%)
    cement_bonus = 1.2 * (cement_wt_pct - 20.0)  # +/- 6 MPa over range

    # Aggregate optimality penalty centered at ~70 wt%
    aggregate_penalty = 0.03 * (aggregate_wt_pct - 70.0) ** 2

    # Base offset to keep realistic range and aggregate contributions
    base_offset = 10.0

    mean_strength = base_offset + strength_wcr + cement_bonus - aggregate_penalty

    # Add measurement noise (SEM ~ 1.5 MPa); clip to non-negative
    noisy_strength = float(np.clip(mean_strength + rng.normal(0.0, 1.5), 0.0, None))

    return noisy_strength


ax_client = AxClient()

# We parameterize only cement and water; aggregate is computed as the remainder to 100 wt%.
# Constraints enforce:
# - Bounds for cement and water
# - Sum bounds to keep aggregate within [60, 80] wt%: 20 <= cement + water <= 40
# - Ordering cement > water (as a non-strict inequality for feasibility: water <= cement)
ax_client.create_experiment(
    parameters=[
        {"name": "cement_wt_pct", "type": "range", "bounds": [15.0, 25.0]},
        {"name": "water_wt_pct", "type": "range", "bounds": [5.0, 15.0]},
    ],
    objectives={
        metric_name: ObjectiveProperties(minimize=False),
    },
    parameter_constraints=[
        "water_wt_pct <= cement_wt_pct",          # cement > water (non-strict in solver)
        "cement_wt_pct + water_wt_pct <= 40.0",   # ensures aggregate >= 60 wt%
        "-cement_wt_pct - water_wt_pct <= -20.0", # ensures aggregate <= 80 wt%
    ],
)

# Optimization budget: 20 trials
for _ in range(20):
    parameterization, trial_index = ax_client.get_next_trial()

    cement = float(parameterization["cement_wt_pct"])
    water = float(parameterization["water_wt_pct"])
    aggregate = float(TOTAL_WT_PCT - (cement + water))  # enforce composition sum to 100 wt%

    # Evaluate the objective (return mean with SEM for noisy measurements)
    strength_mpa = measure_28day_compressive_strength(cement, water, aggregate)
    sem_mpa = 1.5  # assumed standard error of measurement (MPa)

    ax_client.complete_trial(trial_index=trial_index, raw_data=(strength_mpa, sem_mpa))

best_parameters, metrics = ax_client.get_best_parameters()
print("Best mix (wt%):", best_parameters)
print("Observed best 28-day compressive strength (MPa):", metrics)

# Plot results
objective_names = ax_client.objective_names
df = ax_client.get_trials_data_frame()

metric = objective_names[0]
y = df[metric].values

fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
ax.scatter(df.index, y, ec="k", fc="none", label="Observed")
ax.plot(df.index, np.maximum.accumulate(y), color="#0033FF", lw=2, label="Best to Trial")
ax.set_xlabel("Trial Number")
ax.set_ylabel(metric)
ax.legend()
plt.tight_layout()
plt.show()