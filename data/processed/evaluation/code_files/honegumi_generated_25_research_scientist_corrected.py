# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


# Domain-specific metric name for the objective
objective_name = "biomass_yield_g_per_L"

# Random generator for controlled stochasticity (noise in measurements)
_rng = np.random.default_rng(seed=42)


def evaluate_fermentation_biomass_yield(glucose_g_per_L: float,
                                        nitrogen_source_g_per_L: float,
                                        phosphate_g_per_L: float) -> float:
    """
    Simulated evaluation of biomass yield (g/L) for a fermentation medium.

    Replace this function with actual lab measurements or a trusted simulator:
    - Prepare medium with provided nutrient concentrations
    - Run fermentation under standard conditions
    - Measure biomass concentration (g/L) at the end of the batch/run
    - Return the measured biomass yield as a float

    This implementation provides a smooth, realistic response surface with:
    - Saturation effects for each nutrient (diminishing returns)
    - Balance penalty for deviating from a target ratio
    - High-glucose inhibition at very high concentrations
    - Additive measurement/process noise
    """
    g = glucose_g_per_L
    n = nitrogen_source_g_per_L
    p = phosphate_g_per_L

    # Saturation functions (Monod-like, using smooth exponential saturation)
    def sat(x, x50, power=1.2):
        return 1.0 - np.exp(-((x / x50) ** power))

    s_g = sat(g, x50=12.0, power=1.3)
    s_n = sat(n, x50=3.0, power=1.3)
    s_p = sat(p, x50=1.2, power=1.3)

    # Target "balanced" concentrations (approximate optimums within the bounds)
    g_opt, n_opt, p_opt = 18.0, 4.5, 1.8

    # Balance penalty: encourages ratios near the target; broader tolerance on glucose
    sigma_g, sigma_n, sigma_p = 0.45, 0.25, 0.25  # relative tolerances
    balance_penalty = np.exp(
        -0.5
        * (
            ((g / g_opt - 1.0) / sigma_g) ** 2
            + ((n / n_opt - 1.0) / sigma_n) ** 2
            + ((p / p_opt - 1.0) / sigma_p) ** 2
        )
    )

    # High-glucose inhibition (osmotic stress, overflow metabolism)
    glucose_inhibition = 1.0 / (1.0 + (max(g - 22.0, 0.0) / 6.0) ** 4)

    # Combine effects: base potential yield with saturation of the most limiting nutrient
    Y_max = 15.0  # g/L, hypothetical maximum biomass under ideal conditions
    limiting = min(s_g, s_n, s_p)
    deterministic_yield = Y_max * limiting * balance_penalty * glucose_inhibition

    # Small smooth synergy between N and P when both are not limiting
    synergy_np = 0.05 * (s_n * s_p)
    deterministic_yield *= (1.0 + synergy_np)

    # Add realistic measurement/process noise (Gaussian)
    noise_sigma = 0.35  # g/L
    noisy_yield = float(max(0.0, deterministic_yield + _rng.normal(0.0, noise_sigma)))

    return noisy_yield


# Configure Ax optimization client
ax_client = AxClient(random_seed=123)

ax_client.create_experiment(
    name="fermentation_medium_optimization",
    parameters=[
        {"name": "glucose", "type": "range", "bounds": [5.0, 30.0]},
        {"name": "nitrogen_source", "type": "range", "bounds": [1.0, 8.0]},
        {"name": "phosphate", "type": "range", "bounds": [0.5, 3.0]},
    ],
    objectives={
        objective_name: ObjectiveProperties(minimize=False),
    },
)

# Run the optimization loop (budget: 30 experiments)
num_trials = 30
for _ in range(num_trials):
    parameterization, trial_index = ax_client.get_next_trial()

    glucose = float(parameterization["glucose"])
    nitrogen_source = float(parameterization["nitrogen_source"])
    phosphate = float(parameterization["phosphate"])

    measured_yield = evaluate_fermentation_biomass_yield(
        glucose_g_per_L=glucose,
        nitrogen_source_g_per_L=nitrogen_source,
        phosphate_g_per_L=phosphate,
    )

    # For noisy outcomes, passing the scalar value is sufficient; SEM is unknown
    ax_client.complete_trial(trial_index=trial_index, raw_data=measured_yield)

# Retrieve the best found parameters and corresponding objective value
best_parameters, best_values = ax_client.get_best_parameters()
best_yield = best_values[objective_name]["mean"]
print("Best parameters found:")
print(best_parameters)
print(f"Best observed biomass yield: {best_yield:.3f} g/L")

# Plot results
metric_name = ax_client.objective_names[0]
df = ax_client.get_trials_data_frame()

fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
ax.scatter(df.index, df[metric_name], ec="k", fc="none", label="Observed")
ax.plot(
    df.index,
    np.maximum.accumulate(df[metric_name]),
    color="#0033FF",
    lw=2,
    label="Best to Trial (max)",
)
ax.set_xlabel("Trial Number")
ax.set_ylabel("Biomass yield (g/L)")
ax.set_title("Fermentation Medium Optimization")
ax.legend()
plt.tight_layout()
plt.show()