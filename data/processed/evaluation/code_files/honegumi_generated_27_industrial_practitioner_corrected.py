# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


obj1_name = "branin"
obj2_name = "branin_swapped"


def branin3_moo(x1, x2, x3):
    y = float(
        (x2 - 5.1 / (4 * np.pi**2) * x1**2 + 5.0 / np.pi * x1 - 6.0) ** 2
        + 10 * (1 - 1.0 / (8 * np.pi)) * np.cos(x1)
        + 10
    )

    # Contrived way to incorporate x3 into the objective
    y = y * (1 + 0.1 * x1 * x2 * x3)

    # second objective has x1 and x2 swapped
    y2 = float(
        (x1 - 5.1 / (4 * np.pi**2) * x2**2 + 5.0 / np.pi * x2 - 6.0) ** 2
        + 10 * (1 - 1.0 / (8 * np.pi)) * np.cos(x2)
        + 10
    )

    # Contrived way to incorporate x3 into the second objective
    y2 = y2 * (1 - 0.1 * x1 * x2 * x3)

    return {obj1_name: y, obj2_name: y2}


# Define total for compositional constraint, where x1 + x2 + x3 == total
total = 10.0


ax_client = AxClient()

ax_client.create_experiment(
    parameters=[
        {"name": "x1", "type": "range", "bounds": [0.0, total]},
        {"name": "x2", "type": "range", "bounds": [0.0, total]},
    ],
    objectives={
        obj1_name: ObjectiveProperties(minimize=True),
        obj2_name: ObjectiveProperties(minimize=True),
    },
    parameter_constraints=[
        f"x1 + x2 <= {total}",  # reparameterized compositional constraint, which is a type of sum constraint
    ],
)


for i in range(21):

    parameterization, trial_index = ax_client.get_next_trial()

    # extract parameters
    x1 = parameterization["x1"]
    x2 = parameterization["x2"]
    x3 = total - (x1 + x2)  # composition constraint: x1 + x2 + x3 == total

    results = branin3_moo(x1, x2, x3)
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)
pareto_results = ax_client.get_pareto_optimal_parameters()


# Plot results
objectives = ax_client.objective_names
df = ax_client.get_trials_data_frame()

fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
pareto = ax_client.get_pareto_optimal_parameters(use_model_predictions=False)
pareto_data = [p[1][0] for p in pareto.values()]
pareto = pd.DataFrame(pareto_data).sort_values(objectives[0])

ax.scatter(df[objectives[0]], df[objectives[1]], fc="None", ec="k", label="Observed")
ax.plot(
    pareto[objectives[0]],
    pareto[objectives[1]],
    color="#0033FF",
    lw=2,
    label="Pareto Front",
)
ax.set_xlabel(objectives[0])
ax.set_ylabel(objectives[1])

ax.legend()
plt.show()

# Optical glass design optimization with Ax (Multi-objective, compositional constraint)
# %pip install ax-platform==0.4.3 matplotlib

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from ax.service.ax_client import AxClient, ObjectiveProperties

# Objectives
OBJ_REFRACTIVE_INDEX = "refractive_index"  # maximize
OBJ_DISPERSION = "dispersion"              # minimize

# Composition total (percent)
TOTAL_PCT = 100.0

# Simple stochastic surrogate for lab measurements (replace with actual lab measurements)
_rng = np.random.RandomState(0)


def evaluate_glass_composition(SiO2_pct: float, Na2O_pct: float, CaO_pct: float):
    """
    Returns synthetic measurements for refractive index and dispersion for the given composition.
    Replace this with actual furnace melt + metrology integration.

    - Refractive index increases with Na2O and CaO, decreases with SiO2.
    - Dispersion increases with Na2O and CaO and decreases with SiO2 (we minimize dispersion).
    """
    # Nonlinear surrogate with small noise
    n_hat = (
        1.45
        + 0.0035 * Na2O_pct
        + 0.0020 * CaO_pct
        - 0.0005 * SiO2_pct
        + 1e-4 * (Na2O_pct * CaO_pct)  # weak synergistic term
        - 5e-6 * (SiO2_pct - 60.0) ** 2
    )
    n_meas = n_hat + _rng.normal(0.0, 3e-4)

    disp_hat = (
        0.020
        + 0.0006 * Na2O_pct
        + 0.00035 * CaO_pct
        - 0.00025 * (SiO2_pct - 60.0)
        + 1e-5 * (Na2O_pct ** 2)
        + 5e-6 * (Na2O_pct * CaO_pct)
        - 1e-6 * (SiO2_pct - 60.0) ** 2
    )
    disp_meas = max(1e-5, disp_hat + _rng.normal(0.0, 5e-4))  # keep positive

    # Provide small SEMs to indicate measurement noise
    return {
        OBJ_REFRACTIVE_INDEX: (float(n_meas), 2e-4),
        OBJ_DISPERSION: (float(disp_meas), 5e-4),
    }


# Create Ax client and experiment
ax_client = AxClient()

# We reparameterize the 3-part composition by optimizing SiO2 and Na2O directly,
# and computing CaO as the residual to 100%. To enforce CaO bounds [10, 20],
# we add linear constraints on (SiO2 + Na2O) in [80, 90].
ax_client.create_experiment(
    name="optical_glass_moo",
    parameters=[
        {"name": "SiO2_pct", "type": "range", "bounds": [50.0, 70.0]},
        {"name": "Na2O_pct", "type": "range", "bounds": [15.0, 25.0]},
    ],
    objectives={
        OBJ_REFRACTIVE_INDEX: ObjectiveProperties(minimize=False),
        OBJ_DISPERSION: ObjectiveProperties(minimize=True),
    },
    parameter_constraints=[
        f"SiO2_pct + Na2O_pct <= {TOTAL_PCT - 10.0}",  # ensures CaO_pct >= 10
        f"SiO2_pct + Na2O_pct >= {TOTAL_PCT - 20.0}",  # ensures CaO_pct <= 20
    ],
)

# Budget: 38 melts
N_TRIALS = 38
for i in range(N_TRIALS):
    parameterization, trial_index = ax_client.get_next_trial()

    SiO2 = float(parameterization["SiO2_pct"])
    Na2O = float(parameterization["Na2O_pct"])
    CaO = float(TOTAL_PCT - (SiO2 + Na2O))  # composition closure

    # Evaluate the surrogate (replace with actual measurement system)
    results = evaluate_glass_composition(SiO2, Na2O, CaO)

    ax_client.complete_trial(trial_index=trial_index, raw_data=results)

# Retrieve Pareto-optimal observed results
pareto_map = ax_client.get_pareto_optimal_parameters(use_model_predictions=False)

# Plot observed outcomes and the empirical Pareto front
objectives = ax_client.objective_names
df = ax_client.get_trials_data_frame()

fig, ax = plt.subplots(figsize=(7, 5), dpi=150)

# Scatter all observed measurements
ax.scatter(
    df[objectives[0]],
    df[objectives[1]],
    fc="None",
    ec="k",
    label="Observed melts",
)

# Extract Pareto frontier points (observed, not model-predicted)
# pareto_map: dict -> (parameters, [metric_means_dict, ...]) in objective order
pareto_points = []
for _, (_, metric_list) in pareto_map.items():
    # metric_list[0] should be dict of objective means keyed by objective names
    metrics = metric_list[0]
    pareto_points.append({objectives[0]: metrics[objectives[0]], objectives[1]: metrics[objectives[1]]})

if pareto_points:
    pareto_df = pd.DataFrame(pareto_points).sort_values(objectives[0])
    ax.plot(
        pareto_df[objectives[0]],
        pareto_df[objectives[1]],
        color="#0033FF",
        lw=2,
        label="Observed Pareto front",
    )

ax.set_xlabel(f"{objectives[0]} (maximize)")
ax.set_ylabel(f"{objectives[1]} (minimize)")
ax.legend()
plt.tight_layout()
plt.show()