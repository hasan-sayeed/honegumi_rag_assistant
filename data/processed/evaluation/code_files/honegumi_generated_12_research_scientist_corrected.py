# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from typing import Dict, Tuple

from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt

from ax.modelbridge.factory import Models
from ax.modelbridge.generation_strategy import GenerationStep, GenerationStrategy
from botorch.acquisition import UpperConfidenceBound
from ax.modelbridge.registry import Specified_Task_ST_MTGP_trans
from ax.core.observation import ObservationFeatures


# Problem: Multi-task Bayesian optimization of ceramic binder formulations.
# Tasks: 'alumina', 'zirconia', 'SiC' (materials). Objective: maximize green strength (MPa).
# Shared parameters (continuous):
# - binder_concentration (1.0 - 10.0 wt%)
# - plasticizer (0.0 - 3.0 wt%)
# - dispersant (0.1 - 1.0 wt%)
# Transfer learning across tasks via MTGP. Budget: 40 experiments per task (120 total).


objective_name = "green_strength_MPa"
task_param_name = "ceramic_system"
tasks = ["alumina", "zirconia", "SiC"]


def evaluate_binder_formulation(
    binder_concentration: float,
    plasticizer: float,
    dispersant: float,
    ceramic_system: str,
) -> Dict[str, Tuple[float, float]]:
    """
    Evaluate green strength (MPa) for a given binder formulation on a given ceramic system.

    NOTE: Replace this synthetic model with real measurement logic in production.
    For real use, integrate with lab automation / LIMS or manual data entry and
    return the measured mean and standard error of the mean (SEM) for green strength.

    The synthetic model below encodes plausible trends:
    - Green strength has a concave dependence on binder concentration with a task-specific optimum.
    - Plasticizer improves processing but can reduce strength beyond an optimum.
    - Dispersant improves particle packing up to an optimum, then saturates.
    - Small interaction terms capture synergy between binder and dispersant.
    - Additive Gaussian noise emulates measurement noise; SEM is set accordingly.
    """

    # Task-specific maxima and optima (illustrative)
    task_settings = {
        "alumina":  {"max_strength": 20.0, "binder_opt": 6.5, "plast_opt": 1.0, "disp_opt": 0.45},
        "zirconia": {"max_strength": 23.0, "binder_opt": 5.5, "plast_opt": 0.8, "disp_opt": 0.50},
        "SiC":      {"max_strength": 17.0, "binder_opt": 7.2, "plast_opt": 1.2, "disp_opt": 0.40},
    }
    s = task_settings[ceramic_system]

    # Normalize ranges to [0, 1] for shaping terms
    b = (binder_concentration - 1.0) / (10.0 - 1.0)
    p = (plasticizer - 0.0) / (3.0 - 0.0)
    d = (dispersant - 0.1) / (1.0 - 0.1)

    # Parabolic penalties around optima (scaled to bounds)
    binder_term = -((binder_concentration - s["binder_opt"]) / 3.0) ** 2
    plast_term = -((plasticizer - s["plast_opt"]) / 1.0) ** 2
    disp_term = -((dispersant - s["disp_opt"]) / 0.25) ** 2

    # Interaction/synergy (mild positive interaction near higher binder and optimal dispersant)
    interaction = 0.6 * (b * (1.0 - abs(d - (s["disp_opt"] - 0.1) / 0.9)))

    # Aggregate into base signal and shift to be positive
    signal = s["max_strength"] + 6.0 * binder_term + 3.0 * plast_term + 3.5 * disp_term + 2.0 * interaction

    # Add small shape from cross terms to avoid symmetric ridges
    cross = -1.0 * (b - 0.6) * (p - 0.3) + 0.5 * (d - 0.5) * (b - 0.4)
    signal += cross

    # Ensure non-negative and add noise
    rng = np.random.RandomState()
    noise_sd = 0.8  # measurement noise standard deviation [MPa]
    measured = max(0.0, signal + rng.normal(0.0, noise_sd))

    # Return mean and SEM; if SEM unknown, set to None. Here we provide a small SEM.
    sem = max(0.2, noise_sd / np.sqrt(3.0))
    return {objective_name: (float(measured), float(sem))}


# Generation strategy: Sobol initialization then BoTorch Modular with MTGP transforms and UCB acquisition.
# Use a modest Sobol warmup then MTGP for transfer across ceramic systems.
gs = GenerationStrategy(
    steps=[
        GenerationStep(
            model=Models.SOBOL,
            num_trials=12,  # ~ 4 per task as warmup
            min_trials_observed=9,
            max_parallelism=12,
            model_kwargs={"seed": 2025, "transforms": Specified_Task_ST_MTGP_trans},
            model_gen_kwargs={"deduplicate": True},
        ),
        GenerationStep(
            model=Models.BOTORCH_MODULAR,
            num_trials=-1,
            max_parallelism=12,
            model_kwargs={
                "botorch_acqf_class": UpperConfidenceBound,
                "transforms": Specified_Task_ST_MTGP_trans,
            },
        ),
    ]
)

ax_client = AxClient(generation_strategy=gs)

# Create experiment: shared search space + ceramic_system as task parameter.
ax_client.create_experiment(
    name="ceramic_binder_green_strength_mtbo",
    parameters=[
        {
            "name": "binder_concentration",
            "type": "range",
            "bounds": [1.0, 10.0],  # wt%
        },
        {
            "name": "plasticizer",
            "type": "range",
            "bounds": [0.0, 3.0],  # wt%
        },
        {
            "name": "dispersant",
            "type": "range",
            "bounds": [0.1, 1.0],  # wt%
        },
        {
            "name": task_param_name,
            "type": "choice",
            "values": tasks,
            "is_task": True,
            "target_value": tasks[0],  # Target task can be any; we will cycle tasks explicitly
        },
    ],
    objectives={
        objective_name: ObjectiveProperties(minimize=False),
    },
)

# Optimization loop: 40 experiments per task (120 total). Cycle through tasks to allocate budget evenly.
total_per_task = 40
total_trials = total_per_task * len(tasks)

for i in range(total_trials):
    current_task = tasks[i % len(tasks)]
    parameterization, trial_index = ax_client.get_next_trial(
        fixed_features=ObservationFeatures({task_param_name: current_task})
    )

    # Extract parameters
    bc = float(parameterization["binder_concentration"])
    pl = float(parameterization["plasticizer"])
    dp = float(parameterization["dispersant"])
    cs = str(parameterization[task_param_name])

    # Evaluate
    try:
        results = evaluate_binder_formulation(bc, pl, dp, cs)
    except Exception as e:
        # If evaluation fails, abandon the trial
        ax_client.abandon_trial(trial_index=trial_index, reason=str(e))
        continue

    ax_client.complete_trial(trial_index=trial_index, raw_data=results)

# Analysis and visualization
df = ax_client.get_trials_data_frame()

# Ensure we only keep completed trials with the metric recorded
df = df[pd.notnull(df[objective_name])].copy()

# Plot cumulative best (best-so-far) green strength per task
fig, ax = plt.subplots(figsize=(7, 4), dpi=150)
colors = {"alumina": "#1f77b4", "zirconia": "#2ca02c", "SiC": "#d62728"}
for t in tasks:
    dt = df[df[task_param_name] == t].sort_values("trial_index")
    if dt.empty:
        continue
    y = dt[objective_name].values.astype(float)
    best_so_far = np.maximum.accumulate(y)
    ax.plot(dt["trial_index"].values, best_so_far, label=f"{t} (best-so-far)", color=colors[t])
ax.set_xlabel("Trial index")
ax.set_ylabel("Green strength (MPa)")
ax.set_title("Cumulative best green strength by ceramic system")
ax.legend()
plt.tight_layout()
plt.show()

# Scatter of observed outcomes colored by ceramic system
fig2, ax2 = plt.subplots(figsize=(6, 4), dpi=150)
for t in tasks:
    dt = df[df[task_param_name] == t]
    ax2.scatter(
        dt["binder_concentration"].values,
        dt[objective_name].values,
        label=t,
        alpha=0.7,
        edgecolor="k",
        s=30,
    )
ax2.set_xlabel("Binder concentration (wt%)")
ax2.set_ylabel("Green strength (MPa)")
ax2.set_title("Observed green strength vs. binder concentration")
ax2.legend()
plt.tight_layout()
plt.show()

# Print best parameters found per task
for t in tasks:
    dt = df[df[task_param_name] == t]
    if dt.empty:
        continue
    best_row = dt.loc[dt[objective_name].idxmax()]
    print(
        f"Best for {t}: "
        f"green_strength={best_row[objective_name]:.2f} MPa; "
        f"binder_concentration={best_row['binder_concentration']:.3f} wt%, "
        f"plasticizer={best_row['plasticizer']:.3f} wt%, "
        f"dispersant={best_row['dispersant']:.3f} wt%"
    )