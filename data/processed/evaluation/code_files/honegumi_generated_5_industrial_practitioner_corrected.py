# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


obj1_name = "branin"
obj2_name = "branin_swapped"


def branin3_moo(x1, x2, x3):
    y = float(
        (x2 - 5.1 / (4 * np.pi**2) * x1**2 + 5.0 / np.pi * x1 - 6.0) ** 2
        + 10 * (1 - 1.0 / (8 * np.pi)) * np.cos(x1)
        + 10
    )

    # Contrived way to incorporate x3 into the objective
    y = y * (1 + 0.1 * x1 * x2 * x3)

    # second objective has x1 and x2 swapped
    y2 = float(
        (x1 - 5.1 / (4 * np.pi**2) * x2**2 + 5.0 / np.pi * x2 - 6.0) ** 2
        + 10 * (1 - 1.0 / (8 * np.pi)) * np.cos(x2)
        + 10
    )

    # Contrived way to incorporate x3 into the second objective
    y2 = y2 * (1 - 0.1 * x1 * x2 * x3)

    return {obj1_name: y, obj2_name: y2}


# Define total for compositional constraint, where x1 + x2 + x3 == total
total = 10.0


ax_client = AxClient()

ax_client.create_experiment(
    parameters=[
        {"name": "x1", "type": "range", "bounds": [0.0, total]},
        {"name": "x2", "type": "range", "bounds": [0.0, total]},
    ],
    objectives={
        obj1_name: ObjectiveProperties(minimize=True),
        obj2_name: ObjectiveProperties(minimize=True),
    },
    parameter_constraints=[
        f"x1 + x2 <= {total}",  # reparameterized compositional constraint, which is a type of sum constraint
    ],
)


for i in range(21):

    parameterization, trial_index = ax_client.get_next_trial()

    # extract parameters
    x1 = parameterization["x1"]
    x2 = parameterization["x2"]
    x3 = total - (x1 + x2)  # composition constraint: x1 + x2 + x3 == total

    results = branin3_moo(x1, x2, x3)
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)
pareto_results = ax_client.get_pareto_optimal_parameters()


# Plot results
objectives = ax_client.objective_names
df = ax_client.get_trials_data_frame()

fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
pareto = ax_client.get_pareto_optimal_parameters(use_model_predictions=False)
pareto_data = [p[1][0] for p in pareto.values()]
pareto = pd.DataFrame(pareto_data).sort_values(objectives[0])

ax.scatter(df[objectives[0]], df[objectives[1]], fc="None", ec="k", label="Observed")
ax.plot(
    pareto[objectives[0]],
    pareto[objectives[1]],
    color="#0033FF",
    lw=2,
    label="Pareto Front",
)
ax.set_xlabel(objectives[0])
ax.set_ylabel(objectives[1])

ax.legend()
plt.show()

import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


# Domain-specific objective names
BIOAVAILABILITY = "bioavailability_percent"
SHELF_LIFE = "shelf_life_months"


def evaluate_pharmaceutical_formulation(parameters: dict) -> dict:
    """
    Simulated evaluation of a solid oral dosage formulation.

    Objectives:
      - bioavailability_percent: Higher is better (0-100%)
      - shelf_life_months: Higher is better (months)

    Inputs:
      - excipient_1_fraction (binder)
      - excipient_2_fraction (disintegrant)
      - excipient_3_fraction (filler)
      - excipient_4_fraction (lubricant)
      - excipient_5_fraction (surfactant)
      - pH (3-7)
      - storage_temperature (15-30 C)

    This function is a realistic stub capturing plausible trends:
      - Bioavailability peaks near a target composition and pH ~ 5.5 and increases with surfactant.
      - Shelf life degrades with higher storage temperature and extreme pH; certain excipients reduce stability.
      - Adds measurement noise and reports SEM > 0 to reflect a noisy setting.
    """
    # Extract parameters
    f1 = float(parameters["excipient_1_fraction"])  # binder
    f2 = float(parameters["excipient_2_fraction"])  # disintegrant
    f3 = float(parameters["excipient_3_fraction"])  # filler
    f4 = float(parameters["excipient_4_fraction"])  # lubricant
    f5 = float(parameters["excipient_5_fraction"])  # surfactant
    pH = float(parameters["pH"])
    T = float(parameters["storage_temperature"])

    # Ensure composition is valid within numerical tolerance (constraints should enforce == 1.0)
    total_frac = f1 + f2 + f3 + f4 + f5
    if not np.isclose(total_frac, 1.0, atol=1e-6):
        # Renormalize defensively to avoid invalid downstream computations.
        f1, f2, f3, f4, f5 = np.array([f1, f2, f3, f4, f5]) / max(total_frac, 1e-9)

    # Target composition profile for high bioavailability (illustrative)
    target = np.array([0.20, 0.15, 0.45, 0.05, 0.15])
    comp = np.array([f1, f2, f3, f4, f5])

    # Bioavailability model:
    # - Penalize squared deviation from target composition
    # - Favor pH around 5.5
    # - Increase with surfactant; slight penalty for excessive lubricant
    comp_penalty = np.sum(((comp - target) / (0.20 + 1e-8)) ** 2)  # normalized deviations
    alpha_comp = 1.8  # strength of composition penalty
    pH_center, pH_width = 5.5, 0.7
    pH_factor = np.exp(-0.5 * ((pH - pH_center) / pH_width) ** 2)
    surfactant_boost = 12.0 * f5  # surfactant improves solubility
    lube_penalty = 6.0 * max(f4 - 0.08, 0.0)  # too much lubricant can hinder dissolution

    bioavailability = 100.0 * np.exp(-alpha_comp * comp_penalty) * pH_factor + surfactant_boost - lube_penalty
    bioavailability = np.clip(bioavailability, 0.0, 100.0)

    # Shelf-life model:
    # - Base lifetime at 15C, decays with temperature (Arrhenius-like simple model)
    # - Penalize extreme pH away from 4.5 (acidic slightly more stable in this toy model)
    # - Penalize higher fractions of moisture-sensitive excipients (disintegrant, surfactant)
    base_life_15C = 42.0  # months at 15C baseline
    temp_sensitivity = 0.065  # per degree above 15C
    temp_factor = np.exp(-temp_sensitivity * (T - 15.0))
    pH_center_stability, pH_width_stability = 4.5, 1.0
    pH_stability = np.exp(-0.5 * ((pH - pH_center_stability) / pH_width_stability) ** 2)
    moisture_penalty = 18.0 * (0.7 * f2 + 0.3 * f5)  # disintegrant > surfactant effect
    lube_benefit = 5.0 * min(f4, 0.06)  # small benefit up to 6%
    shelf_life = base_life_15C * temp_factor * pH_stability - moisture_penalty + lube_benefit
    shelf_life = float(np.clip(shelf_life, 0.0, 60.0))

    # Add observational noise and SEM (standard error of mean)
    rng = np.random.default_rng()
    bio_noise_sd = 1.0  # percentage points
    life_noise_sd = 0.7  # months
    bio_obs = float(np.clip(bioavailability + rng.normal(0.0, bio_noise_sd), 0.0, 100.0))
    life_obs = float(np.clip(shelf_life + rng.normal(0.0, life_noise_sd), 0.0, 60.0))

    # Return mean estimate and SEM; here SEM approximated by the known noise SD
    return {
        BIOAVAILABILITY: (bio_obs, bio_noise_sd),
        SHELF_LIFE: (life_obs, life_noise_sd),
    }


def compute_observed_pareto(df: pd.DataFrame, x_col: str, y_col: str) -> pd.DataFrame:
    """
    Compute nondominated points (maximization of both objectives) from observed data.
    Returns a DataFrame of Pareto-optimal points sorted by x_col.
    """
    pts = df[[x_col, y_col]].dropna().to_numpy(dtype=float)
    if pts.shape[0] == 0:
        return pd.DataFrame(columns=[x_col, y_col])

    # Identify nondominated points
    is_dominated = np.zeros(pts.shape[0], dtype=bool)
    for i in range(pts.shape[0]):
        if is_dominated[i]:
            continue
        dominates_i = (pts[:, 0] >= pts[i, 0]) & (pts[:, 1] >= pts[i, 1]) & (
            (pts[:, 0] > pts[i, 0]) | (pts[:, 1] > pts[i, 1])
        )
        # If any point strictly dominates i, mark i as dominated
        if np.any(dominates_i):
            is_dominated[i] = True

    pareto_pts = pts[~is_dominated]
    pareto_df = pd.DataFrame(pareto_pts, columns=[x_col, y_col]).sort_values(by=x_col)
    return pareto_df


def main():
    np.random.seed(0)

    ax_client = AxClient()
    ax_client.create_experiment(
        name="pharmaceutical_formulation_moo",
        parameters=[
            {"name": "excipient_1_fraction", "type": "range", "bounds": [0.0, 1.0]},  # binder
            {"name": "excipient_2_fraction", "type": "range", "bounds": [0.0, 1.0]},  # disintegrant
            {"name": "excipient_3_fraction", "type": "range", "bounds": [0.0, 1.0]},  # filler
            {"name": "excipient_4_fraction", "type": "range", "bounds": [0.0, 1.0]},  # lubricant
            {"name": "excipient_5_fraction", "type": "range", "bounds": [0.0, 1.0]},  # surfactant
            {"name": "pH", "type": "range", "bounds": [3.0, 7.0]},
            {"name": "storage_temperature", "type": "range", "bounds": [15.0, 30.0]},
        ],
        objectives={
            BIOAVAILABILITY: ObjectiveProperties(minimize=False),
            SHELF_LIFE: ObjectiveProperties(minimize=False),
        },
        # Enforce compositional equality by applying both upper and lower sum constraints
        parameter_constraints=[
            "excipient_1_fraction + excipient_2_fraction + excipient_3_fraction + excipient_4_fraction + excipient_5_fraction <= 1.0",
            "excipient_1_fraction + excipient_2_fraction + excipient_3_fraction + excipient_4_fraction + excipient_5_fraction >= 1.0",
        ],
    )

    # Run optimization for the specified budget
    NUM_TRIALS = 50
    for _ in range(NUM_TRIALS):
        parameters, trial_index = ax_client.get_next_trial()
        results = evaluate_pharmaceutical_formulation(parameters)
        ax_client.complete_trial(trial_index=trial_index, raw_data=results)

    # Collect results and compute Pareto frontier from observed data
    df = ax_client.get_trials_data_frame()
    if BIOAVAILABILITY not in df.columns or SHELF_LIFE not in df.columns:
        raise RuntimeError("Expected objective columns are not present in trials data frame.")

    pareto_df = compute_observed_pareto(df, BIOAVAILABILITY, SHELF_LIFE)

    # Plot observed points and the empirical Pareto frontier
    fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
    ax.scatter(
        df[BIOAVAILABILITY],
        df[SHELF_LIFE],
        fc="None",
        ec="k",
        label="Observed",
        alpha=0.7,
    )
    if len(pareto_df) > 0:
        ax.plot(
            pareto_df[BIOAVAILABILITY],
            pareto_df[SHELF_LIFE],
            color="#0033FF",
            lw=2,
            label="Empirical Pareto Front",
        )
    ax.set_xlabel("Bioavailability (%)")
    ax.set_ylabel("Shelf life (months)")
    ax.set_title("Formulation MOO: Bioavailability vs. Shelf Life")
    ax.legend()
    plt.tight_layout()
    plt.show()


if __name__ == "__main__":
    main()