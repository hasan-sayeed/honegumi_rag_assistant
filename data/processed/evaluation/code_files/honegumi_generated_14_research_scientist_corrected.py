# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


obj1_name = "branin"


def branin3(x1, x2, x3):
    y = float(
        (x2 - 5.1 / (4 * np.pi**2) * x1**2 + 5.0 / np.pi * x1 - 6.0) ** 2
        + 10 * (1 - 1.0 / (8 * np.pi)) * np.cos(x1)
        + 10
    )

    # Contrived way to incorporate x3 into the objective
    y = y * (1 + 0.1 * x1 * x2 * x3)

    return y


# Define total for compositional constraint, where x1 + x2 + x3 == total
total = 10.0


ax_client = AxClient()

ax_client.create_experiment(
    parameters=[
        {"name": "x1", "type": "range", "bounds": [0.0, total]},
        {"name": "x2", "type": "range", "bounds": [0.0, total]},
    ],
    objectives={
        obj1_name: ObjectiveProperties(minimize=True),
    },
    parameter_constraints=[
        f"x1 + x2 <= {total}",  # reparameterized compositional constraint, which is a type of sum constraint
    ],
)


for i in range(21):

    parameterization, trial_index = ax_client.get_next_trial()

    # extract parameters
    x1 = parameterization["x1"]
    x2 = parameterization["x2"]
    x3 = total - (x1 + x2)  # composition constraint: x1 + x2 + x3 == total

    results = branin3(x1, x2, x3)
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)

best_parameters, metrics = ax_client.get_best_parameters()


# Plot results
objectives = ax_client.objective_names
df = ax_client.get_trials_data_frame()

fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
ax.scatter(df.index, df[objectives], ec="k", fc="none", label="Observed")
ax.plot(
    df.index,
    np.minimum.accumulate(df[objectives]),
    color="#0033FF",
    lw=2,
    label="Best to Trial",
)
ax.set_xlabel("Trial Number")
ax.set_ylabel(objectives[0])

ax.legend()
plt.show()

# Liquid color matching with Bayesian optimization (Ax Platform)
# %pip install ax-platform==0.4.3 matplotlib numpy pandas
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


# ----------------------------
# Domain configuration
# ----------------------------
# AS7341 channels (nm)
WAVELENGTHS_NM = np.array([415, 445, 480, 515, 555, 590, 630, 680], dtype=float)

# Random seed for reproducibility of simulated noise
RNG = np.random.default_rng(42)

# Toggle to use hardware sensor (if available) or simulation
USE_HARDWARE_SENSOR = False

# Observation noise estimate for the scalar objective we report to Ax (SEM)
OBJECTIVE_NOISE_SEM = 0.003

# Simulated measurement noise per-channel (additive, before normalization)
MEASUREMENT_NOISE_STD = 0.01

# Nonlinearity strength for Beer-Lambert-like mixing (higher => stronger absorption)
ABSORPTION_SCALE = 3.0

# Target color (unknown in real world; set here for a runnable demo)
TARGET_FRACTIONS = {"red_fraction": 0.25, "yellow_fraction": 0.55, "blue_fraction": 0.20}


# ----------------------------
# Spectral models
# ----------------------------
def get_dye_absorbance_curves():
    """
    Approximate absorbance spectra for red, yellow, blue dyes on AS7341 channels.
    Values are arbitrary but plausible: dyes absorb complementary colors; transmitted
    light is exp(-sum(ci * absorbance_i(lambda))).
    """
    # Channels: 415, 445, 480, 515, 555, 590, 630, 680 nm
    # Red dye transmits red, absorbs green/blue
    absorb_red = np.array([0.85, 0.78, 0.65, 0.42, 0.22, 0.15, 0.07, 0.05], dtype=float)
    # Yellow dye transmits yellow, absorbs blue
    absorb_yellow = np.array([0.92, 0.85, 0.62, 0.28, 0.10, 0.08, 0.10, 0.18], dtype=float)
    # Blue dye transmits blue, absorbs red/green
    absorb_blue = np.array([0.12, 0.16, 0.22, 0.35, 0.62, 0.82, 0.92, 0.97], dtype=float)
    return absorb_red, absorb_yellow, absorb_blue


def normalize_vector(v: np.ndarray, eps: float = 1e-12) -> np.ndarray:
    s = float(np.sum(v))
    return v / (s + eps)


def simulate_as7341_spectrum(red_fraction: float, yellow_fraction: float, blue_fraction: float) -> np.ndarray:
    """
    Simulate AS7341 8-channel reading for a mixture of red/yellow/blue dyes using a
    Beer-Lambert-like model with plausible absorbance curves.
    """
    absorb_red, absorb_yellow, absorb_blue = get_dye_absorbance_curves()

    # Total absorbance is linear in concentrations; transmittance is exponential
    total_absorbance = (
        red_fraction * absorb_red
        + yellow_fraction * absorb_yellow
        + blue_fraction * absorb_blue
    )

    transmittance = np.exp(-ABSORPTION_SCALE * total_absorbance)

    # Optional: illumination / sensor spectral response can be applied here
    illumination = np.ones_like(transmittance)

    # Raw signal proportional to transmittance and illumination
    signal = illumination * transmittance

    # Add per-channel measurement noise (pre-normalization)
    noisy_signal = signal + RNG.normal(0.0, MEASUREMENT_NOISE_STD, size=signal.shape)

    # Ensure non-negativity
    noisy_signal = np.clip(noisy_signal, 0.0, None)

    return noisy_signal


def measure_spectrum_with_as7341(red_fraction: float, yellow_fraction: float, blue_fraction: float) -> np.ndarray:
    """
    Replace this function with actual hardware measurement to read AS7341.

    Expected to return a vector of 8 channel readings aligned with WAVELENGTHS_NM.
    """
    # Placeholder: in real deployment, integrate with AS7341 and your mixing/dispensing system.
    # For this complete, executable script we fall back to simulation.
    return simulate_as7341_spectrum(red_fraction, yellow_fraction, blue_fraction)


# Precompute the target spectrum (normalized) for the demo
def get_target_spectrum() -> np.ndarray:
    r = TARGET_FRACTIONS["red_fraction"]
    y = TARGET_FRACTIONS["yellow_fraction"]
    b = TARGET_FRACTIONS["blue_fraction"]
    spec = simulate_as7341_spectrum(r, y, b)
    return normalize_vector(spec)


TARGET_SPECTRUM = get_target_spectrum()


# ----------------------------
# Objective evaluation
# ----------------------------
def evaluate_color_mixture(red_fraction: float, yellow_fraction: float, blue_fraction: float) -> float:
    """
    Compute the spectral mismatch between the measured spectrum of the mixture and the target spectrum.
    Returns a scalar to minimize: mean squared error between normalized spectra.
    """
    if USE_HARDWARE_SENSOR:
        measured = measure_spectrum_with_as7341(red_fraction, yellow_fraction, blue_fraction)
    else:
        measured = simulate_as7341_spectrum(red_fraction, yellow_fraction, blue_fraction)

    measured_norm = normalize_vector(measured)
    mismatch = float(np.mean((measured_norm - TARGET_SPECTRUM) ** 2))
    return mismatch


# ----------------------------
# Ax optimization setup
# ----------------------------
objective_name = "spectral_mismatch"
total_fraction = 1.0  # composition sum

ax_client = AxClient()

ax_client.create_experiment(
    name="liquid_color_matching_as7341",
    parameters=[
        {
            "name": "red_fraction",
            "type": "range",
            "bounds": [0.0, total_fraction],
            "value_type": "float",
        },
        {
            "name": "yellow_fraction",
            "type": "range",
            "bounds": [0.0, total_fraction],
            "value_type": "float",
        },
    ],
    objectives={
        objective_name: ObjectiveProperties(minimize=True),
    },
    parameter_constraints=[
        f"red_fraction + yellow_fraction <= {total_fraction}",  # Reparameterized composition (blue is 1 - (red + yellow))
    ],
)


# ----------------------------
# Optimization loop (30 trials)
# ----------------------------
NUM_TRIALS = 30

for _ in range(NUM_TRIALS):
    parameterization, trial_index = ax_client.get_next_trial()

    red_fraction = float(parameterization["red_fraction"])
    yellow_fraction = float(parameterization["yellow_fraction"])
    blue_fraction = float(total_fraction - (red_fraction + yellow_fraction))  # Enforce composition

    # Safety clamp for numerical precision
    blue_fraction = max(0.0, min(1.0, blue_fraction))

    mismatch_value = evaluate_color_mixture(red_fraction, yellow_fraction, blue_fraction)

    # Report scalar with an estimated standard error of measurement (SEM)
    ax_client.complete_trial(trial_index=trial_index, raw_data=(mismatch_value, OBJECTIVE_NOISE_SEM))


best_parameters, best_metrics = ax_client.get_best_parameters()


# ----------------------------
# Reporting and visualization
# ----------------------------
print("Best mixing fractions found (red, yellow, blue):")
best_red = float(best_parameters["red_fraction"])
best_yellow = float(best_parameters["yellow_fraction"])
best_blue = float(total_fraction - (best_red + best_yellow))
print(
    f"  red_fraction={best_red:.4f}, yellow_fraction={best_yellow:.4f}, blue_fraction={best_blue:.4f}"
)

print("Best spectral mismatch (estimated):")
print(f"  {objective_name} = {best_metrics[objective_name][0]:.6f}")

# Plot mismatch across trials
df = ax_client.get_trials_data_frame()
obj_col = objective_name
y_vals = df[obj_col].values
best_so_far = np.minimum.accumulate(y_vals)

fig, ax = plt.subplots(figsize=(7, 4.5), dpi=140)
ax.scatter(df.index, y_vals, ec="k", fc="none", label="Observed")
ax.plot(df.index, best_so_far, color="#0033FF", lw=2, label="Best so far")
ax.set_xlabel("Trial number")
ax.set_ylabel("Spectral mismatch (MSE)")
ax.set_title("Bayesian optimization of liquid color match")
ax.legend()
plt.tight_layout()
plt.show()

# Plot target vs best-achieved spectrum
def spectrum_from_fractions(rf, yf, bf):
    if USE_HARDWARE_SENSOR:
        spec = measure_spectrum_with_as7341(rf, yf, bf)
    else:
        spec = simulate_as7341_spectrum(rf, yf, bf)
    return normalize_vector(spec)

best_spectrum = spectrum_from_fractions(best_red, best_yellow, best_blue)

fig2, ax2 = plt.subplots(figsize=(7, 4.5), dpi=140)
ax2.plot(WAVELENGTHS_NM, TARGET_SPECTRUM, "-o", label="Target (normalized)")
ax2.plot(WAVELENGTHS_NM, best_spectrum, "-o", label="Best mixture (normalized)")
ax2.set_xlabel("Wavelength (nm)")
ax2.set_ylabel("Normalized intensity")
ax2.set_title("Target vs. best-achieved spectrum")
ax2.grid(True, alpha=0.3)
ax2.legend()
plt.tight_layout()
plt.show()