# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


# Metric names (objectives)
metric_charge_time = "charge_time_min"       # minimize
metric_cycle_life = "cycle_life_cycles"      # maximize


def evaluate_fast_charging(parameters: dict) -> dict:
    """
    Evaluate fast charging settings for a lithium-ion cell.

    Inputs (parameters dict):
      - charge_current_c: C-rate in [0.5, 3.0]
      - voltage_limit_v: charge cutoff voltage in [4.1, 4.3] V
      - temperature_c: ambient temperature in [10, 40] °C

    Outputs (dict of metric -> (mean, sem)):
      - charge_time_min: estimated time to full charge (min), lower is better
      - cycle_life_cycles: estimated cycle life (cycles), higher is better

    This function uses a simplified physics-informed surrogate with noise to
    emulate experimental outcomes. Replace with actual lab evaluation or high-fidelity
    simulation when available.
    """
    C = float(parameters["charge_current_c"])
    V = float(parameters["voltage_limit_v"])
    T = float(parameters["temperature_c"])

    # --------------------------
    # Charge time model (minutes)
    # Base time scales inversely with C-rate
    base_time = 60.0 / np.clip(C, 0.1, None)  # minutes

    # Voltage factor: lower V_limit slows down taper; higher V_limit can slightly reduce time
    # Scale within ~±25% across 4.1–4.3 V range around 4.2 V
    voltage_factor = 1.0 + 0.5 * ((4.2 - V) / 0.2)  # 4.1 -> +0.25, 4.3 -> -0.25
    voltage_factor = float(np.clip(voltage_factor, 0.7, 1.4))

    # Temperature factor: fastest near ~30°C; colder/hotter slows down
    temp_factor_time = 1.0 + 0.0025 * (30.0 - T) ** 2  # 10°C -> ~2x, 40°C -> ~1.25x

    charge_time = base_time * voltage_factor * temp_factor_time

    # --------------------------
    # Cycle life model (cycles)
    base_life = 1000.0  # nominal cycles at mild conditions

    # Current penalty: deviations from ~1C reduce life
    life_factor_current = np.exp(-0.6 * (C - 1.0) ** 2)  # 3C -> ~0.09x

    # Voltage penalty: higher cutoff reduces life
    life_factor_voltage = np.exp(-0.5 * ((V - 4.2) / 0.1))  # +0.1V -> ~0.61x; +0.2V -> ~0.37x
    # If below 4.2V, modest life benefit:
    if V < 4.2:
        life_factor_voltage = 1.0 + 0.15 * ((4.2 - V) / 0.1)  # up to ~1.3x at 4.1V

    # Temperature effect: optimal near ~25°C
    life_factor_temp = np.exp(-1.5 * ((T - 25.0) / 15.0) ** 2)

    # Low-T plating risk: strong penalty at low T with high C
    plating_penalty = 1.0
    if T < 20.0:
        plating_penalty *= np.exp(-0.6 * (C - 1.0) ** 2 * (20.0 - T) / 10.0)

    # High-T + high-V synergy penalty
    high_tv_penalty = 1.0
    if (T > 35.0) and (V > 4.25):
        high_tv_penalty *= np.exp(-0.8 * ((T - 35.0) / 5.0) * ((V - 4.25) / 0.05))

    cycle_life = base_life * life_factor_current * life_factor_voltage * life_factor_temp * plating_penalty * high_tv_penalty

    # Practical bounds
    charge_time = float(np.clip(charge_time, 5.0, 180.0))
    cycle_life = float(np.clip(cycle_life, 50.0, 3000.0))

    # Add measurement noise; report SEM to Ax
    rng = np.random.default_rng()
    time_noise_sd = max(0.02 * charge_time, 0.2)  # ~2% or at least 0.2 min
    life_noise_sd = max(0.05 * cycle_life, 5.0)   # ~5% or at least 5 cycles

    noisy_time = float(charge_time + rng.normal(0.0, time_noise_sd))
    noisy_life = float(cycle_life + rng.normal(0.0, life_noise_sd))

    return {
        metric_charge_time: (noisy_time, time_noise_sd),
        metric_cycle_life: (noisy_life, life_noise_sd),
    }


def compute_observed_pareto_front(df: pd.DataFrame, x_col: str, y_col: str) -> pd.DataFrame:
    """
    Compute observed Pareto frontier for 2 objectives:
      - x_col is minimized
      - y_col is maximized
    Returns a DataFrame sorted by x_col with Pareto-optimal points.
    """
    sdf = df[[x_col, y_col]].dropna().sort_values(x_col, ascending=True)
    if sdf.empty:
        return sdf
    pareto_idx = []
    best_y = -np.inf
    for idx, row in sdf.iterrows():
        y = row[y_col]
        if y >= best_y - 1e-12:
            pareto_idx.append(idx)
            best_y = y
    return sdf.loc[pareto_idx].sort_values(x_col, ascending=True)


# Initialize Ax client and create the experiment
ax_client = AxClient()
ax_client.create_experiment(
    name="battery_fast_charging_moo",
    parameters=[
        {"name": "charge_current_c", "type": "range", "bounds": [0.5, 3.0], "value_type": "float"},
        {"name": "voltage_limit_v", "type": "range", "bounds": [4.1, 4.3], "value_type": "float"},
        {"name": "temperature_c", "type": "range", "bounds": [10.0, 40.0], "value_type": "float"},
    ],
    objectives={
        metric_charge_time: ObjectiveProperties(minimize=True),
        metric_cycle_life: ObjectiveProperties(minimize=False),
    },
)

# Optimization loop (budget: 35 trials)
N_TRIALS = 35
for _ in range(N_TRIALS):
    params, trial_index = ax_client.get_next_trial()
    results = evaluate_fast_charging(params)
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)

# Retrieve results
df = ax_client.get_trials_data_frame()
df_plot = df[[metric_charge_time, metric_cycle_life]].dropna()

# Compute observed Pareto frontier
pareto_df = compute_observed_pareto_front(df_plot, metric_charge_time, metric_cycle_life)

# Plot observed points and Pareto frontier
fig, ax = plt.subplots(figsize=(7, 5), dpi=150)
ax.scatter(
    df_plot[metric_charge_time],
    df_plot[metric_cycle_life],
    facecolors="none",
    edgecolors="k",
    label="Observed"
)
if not pareto_df.empty:
    ax.plot(
        pareto_df[metric_charge_time],
        pareto_df[metric_cycle_life],
        color="#0033FF",
        lw=2,
        marker="o",
        label="Observed Pareto Front",
    )

ax.set_xlabel("Charge time (min)")
ax.set_ylabel("Cycle life (cycles)")
ax.set_title("Fast Charging Optimization: Time vs Cycle Life")
ax.legend()
plt.tight_layout()
plt.show()