# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


obj1_name = "branin"


def branin(x1, x2):
    y = float(
        (x2 - 5.1 / (4 * np.pi**2) * x1**2 + 5.0 / np.pi * x1 - 6.0) ** 2
        + 10 * (1 - 1.0 / (8 * np.pi)) * np.cos(x1)
        + 10
    )

    return y


ax_client = AxClient()

ax_client.create_experiment(
    parameters=[
        {"name": "x1", "type": "range", "bounds": [-5.0, 10.0]},
        {"name": "x2", "type": "range", "bounds": [0.0, 10.0]},
    ],
    objectives={
        obj1_name: ObjectiveProperties(minimize=True),
    },
)


for i in range(19):

    parameterization, trial_index = ax_client.get_next_trial()

    # extract parameters
    x1 = parameterization["x1"]
    x2 = parameterization["x2"]

    results = branin(x1, x2)
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)

best_parameters, metrics = ax_client.get_best_parameters()


# Plot results
objectives = ax_client.objective_names
df = ax_client.get_trials_data_frame()

fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
ax.scatter(df.index, df[objectives], ec="k", fc="none", label="Observed")
ax.plot(
    df.index,
    np.minimum.accumulate(df[objectives]),
    color="#0033FF",
    lw=2,
    label="Best to Trial",
)
ax.set_xlabel("Trial Number")
ax.set_ylabel(objectives[0])

ax.legend()
plt.show()

# Generated from a Honegumi skeleton and adapted to solar cell PCE optimization
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from ax.service.ax_client import AxClient, ObjectiveProperties


# Domain-specific metric and parameters:
# Objective: Maximize power conversion efficiency (PCE, in %)
# Parameters:
#   - annealing_temperature_celsius: 100 to 200 째C (continuous)
#   - deposition_rate_nm_per_s: 0.5 to 3.0 nm/s (continuous)
#
# Experimental budget: 25 trials
# We simulate noisy measurements with a plausible response surface.

METRIC_NAME = "PCE"  # Power Conversion Efficiency in percent


def evaluate_solar_cell_pce(annealing_temperature_celsius: float, deposition_rate_nm_per_s: float) -> float:
    """
    Simulated evaluation of solar cell PCE given annealing temperature and deposition rate.

    This function provides a realistic stub of the experimental outcome:
    - Peak PCE around 165 째C anneal and 1.8 nm/s deposition rate (good crystallinity)
    - Secondary local optimum near 145 째C and 1.2 nm/s (alternative processing window)
    - Degradation at too high temperatures (decomposition) and too high deposition rate (rough films)
    - Additive Gaussian measurement/process noise to emulate real lab measurements

    Replace this function with actual measurement integration (e.g., instrument control + data acquisition)
    to use this script in production.
    """
    T = float(annealing_temperature_celsius)
    R = float(deposition_rate_nm_per_s)

    # Main optimum
    T_opt1, R_opt1 = 165.0, 1.8
    sigma_T1, sigma_R1 = 12.0, 0.45

    # Secondary (weaker) optimum
    T_opt2, R_opt2 = 145.0, 1.2
    sigma_T2, sigma_R2 = 10.0, 0.35
    secondary_scale = 0.6

    # Penalties near extremes
    # Thermal decomposition at high T
    decomp_penalty = 2.8 * np.exp(-0.5 * ((T - 190.0) / 8.0) ** 2)
    # Rough morphology at very high deposition rate
    rough_penalty = 2.2 * np.exp(-0.5 * ((R - 2.8) / 0.25) ** 2)

    # Base PCE level + contributions from optima
    base = 9.0
    peak1 = 12.5 * np.exp(-0.5 * ((T - T_opt1) / sigma_T1) ** 2 - 0.5 * ((R - R_opt1) / sigma_R1) ** 2)
    peak2 = 7.5 * secondary_scale * np.exp(
        -0.5 * ((T - T_opt2) / sigma_T2) ** 2 - 0.5 * ((R - R_opt2) / sigma_R2) ** 2
    )

    # Mild interaction: slightly favor slower deposition at lower T
    interaction_term = 0.6 * np.exp(-0.5 * ((T - 150.0) / 18.0) ** 2) * np.exp(-0.5 * ((R - 1.1) / 0.3) ** 2)

    pce = base + peak1 + peak2 + interaction_term - decomp_penalty - rough_penalty

    # Add experimental noise (random seed not fixed, to mimic real experiments)
    measurement_noise = np.random.normal(loc=0.0, scale=0.25)  # ~0.25 %-point noise
    pce_noisy = float(np.clip(pce + measurement_noise, 0.0, 30.0))

    return pce_noisy


def main() -> None:
    # Optional: set a seed for reproducibility of Bayesian optimization (not measurement noise)
    # np.random.seed(123)

    ax_client = AxClient()

    ax_client.create_experiment(
        name="solar_cell_pce_optimization",
        parameters=[
            {
                "name": "annealing_temperature_celsius",
                "type": "range",
                "bounds": [100.0, 200.0],
                "value_type": "float",
            },
            {
                "name": "deposition_rate_nm_per_s",
                "type": "range",
                "bounds": [0.5, 3.0],
                "value_type": "float",
            },
        ],
        objectives={
            METRIC_NAME: ObjectiveProperties(minimize=False),
        },
        overwrite_existing_experiment=True,
    )

    budget = 25  # number of experiments

    for _ in range(budget):
        parameterization, trial_index = ax_client.get_next_trial()

        # Extract domain parameters
        T_c = float(parameterization["annealing_temperature_celsius"])
        rate = float(parameterization["deposition_rate_nm_per_s"])

        # Run evaluation (replace with actual lab measurement in production)
        pce_value = evaluate_solar_cell_pce(T_c, rate)

        # Report result back to Ax (single-objective dict)
        ax_client.complete_trial(trial_index=trial_index, raw_data={METRIC_NAME: pce_value})

    best_parameters, best_values = ax_client.get_best_parameters()

    # Print best found configuration and corresponding PCE
    best_pce = best_values[METRIC_NAME]["mean"] if isinstance(best_values, dict) else best_values
    print("Best parameters found:")
    for k, v in best_parameters.items():
        print(f"  {k}: {v}")
    print(f"Best observed {METRIC_NAME}: {best_pce:.3f} %")

    # Visualization: PCE across trials with cumulative best (maximize)
    objectives = ax_client.objective_names  # should be ["PCE"]
    df = ax_client.get_trials_data_frame()

    # Ensure we have the metric column
    if METRIC_NAME not in df.columns:
        raise RuntimeError(f"Expected metric column '{METRIC_NAME}' not found in trials data frame.\nColumns: {df.columns}")

    y = df[METRIC_NAME].to_numpy()

    fig, ax = plt.subplots(figsize=(7, 4.5), dpi=150)
    ax.scatter(df.index, y, ec="k", fc="none", label="Observed PCE")
    ax.plot(df.index, np.maximum.accumulate(y), color="#0033FF", lw=2, label="Best-to-Trial (cummax)")
    ax.set_xlabel("Trial Number")
    ax.set_ylabel(f"{METRIC_NAME} (%)")
    ax.set_title("Solar Cell PCE Optimization (Ax)")
    ax.legend()
    plt.tight_layout()
    plt.show()

    # Visualization: parameter space colored by PCE
    if "annealing_temperature_celsius" in df.columns and "deposition_rate_nm_per_s" in df.columns:
        fig2, ax2 = plt.subplots(figsize=(6, 5), dpi=150)
        sc = ax2.scatter(
            df["deposition_rate_nm_per_s"],
            df["annealing_temperature_celsius"],
            c=df[METRIC_NAME],
            cmap="viridis",
            s=55,
            edgecolor="k",
        )
        ax2.set_xlabel("Deposition rate (nm/s)")
        ax2.set_ylabel("Annealing temperature (째C)")
        ax2.set_title("Experimental Conditions Colored by PCE")
        cb = plt.colorbar(sc, ax=ax2)
        cb.set_label("PCE (%)")
        plt.tight_layout()
        plt.show()


if __name__ == "__main__":
    main()