# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


obj1_name = "branin"
obj2_name = "branin_swapped"


def branin3_moo(x1, x2, x3):
    y = float(
        (x2 - 5.1 / (4 * np.pi**2) * x1**2 + 5.0 / np.pi * x1 - 6.0) ** 2
        + 10 * (1 - 1.0 / (8 * np.pi)) * np.cos(x1)
        + 10
    )

    # Contrived way to incorporate x3 into the objective
    y = y * (1 + 0.1 * x1 * x2 * x3)

    # second objective has x1 and x2 swapped
    y2 = float(
        (x1 - 5.1 / (4 * np.pi**2) * x2**2 + 5.0 / np.pi * x2 - 6.0) ** 2
        + 10 * (1 - 1.0 / (8 * np.pi)) * np.cos(x2)
        + 10
    )

    # Contrived way to incorporate x3 into the second objective
    y2 = y2 * (1 - 0.1 * x1 * x2 * x3)

    return {obj1_name: y, obj2_name: y2}


# Define total for compositional constraint, where x1 + x2 + x3 == total
total = 10.0


# Define the training data

# note that for this training data, the compositional constraint is satisfied


X_train = pd.DataFrame(
    [
        {"x1": 4.0, "x2": 5.0, "x3": 1.0},
        {"x1": 0.0, "x2": 6.2, "x3": 3.8},
        {"x1": 5.9, "x2": 2.0, "x3": 2.0},
        {"x1": 1.5, "x2": 2.0, "x3": 6.5},
        {"x1": 1.0, "x2": 9.0, "x3": 0.0},
    ]
)

# Define y_train (normally the values would be supplied directly instead of calculating here)
y_train = [
    branin3_moo(row["x1"], row["x2"], row["x3"]) for _, row in X_train.iterrows()
]

# See https://youtu.be/4tnaL9ts6CQ for simple human-in-the-loop BO instructions

# Define the number of training examples
n_train = len(X_train)


ax_client = AxClient()

ax_client.create_experiment(
    parameters=[
        {"name": "x1", "type": "range", "bounds": [0.0, total]},
        {"name": "x2", "type": "range", "bounds": [0.0, total]},
    ],
    objectives={
        obj1_name: ObjectiveProperties(minimize=True, threshold=25.0),
        obj2_name: ObjectiveProperties(minimize=True, threshold=15.0),
    },
    parameter_constraints=[
        f"x1 + x2 <= {total}",  # reparameterized compositional constraint, which is a type of sum constraint
    ],
)

# Add existing data to the AxClient
for i in range(n_train):
    parameterization = X_train.iloc[i].to_dict()

    # remove x3, since it's hidden from search space due to composition constraint
    parameterization.pop("x3")

    ax_client.attach_trial(parameterization)
    ax_client.complete_trial(trial_index=i, raw_data=y_train[i])


for i in range(21):

    parameterization, trial_index = ax_client.get_next_trial()

    # extract parameters
    x1 = parameterization["x1"]
    x2 = parameterization["x2"]
    x3 = total - (x1 + x2)  # composition constraint: x1 + x2 + x3 == total

    results = branin3_moo(x1, x2, x3)
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)
pareto_results = ax_client.get_pareto_optimal_parameters()


# Plot results
objectives = ax_client.objective_names
df = ax_client.get_trials_data_frame()

fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
pareto = ax_client.get_pareto_optimal_parameters(use_model_predictions=False)
pareto_data = [p[1][0] for p in pareto.values()]
pareto = pd.DataFrame(pareto_data).sort_values(objectives[0])

ax.scatter(df[objectives[0]], df[objectives[1]], fc="None", ec="k", label="Observed")
ax.plot(
    pareto[objectives[0]],
    pareto[objectives[1]],
    color="#0033FF",
    lw=2,
    label="Pareto Front",
)
ax.set_xlabel(objectives[0])
ax.set_ylabel(objectives[1])

ax.legend()
plt.show()

# Generated for polymer formulation MOO with Ax Platform
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# Ax imports
try:
    from ax.service.ax_client import AxClient, ObjectiveProperties
except Exception:
    from ax.service.ax_client import AxClient
    from ax.service.utils.instantiation import ObjectiveProperties

# Optional Pareto plotting utilities (posterior frontier)
try:
    from ax.plot.pareto_frontier import plot_pareto_frontier
    from ax.plot.pareto_utils import compute_posterior_pareto_frontier
    from ax.utils.notebook.plotting import render
    HAVE_PARETO_PLOT = True
except Exception:
    HAVE_PARETO_PLOT = False


# Random seed for reproducibility of synthetic evaluation noise
np.random.seed(42)


# Objective names
STRENGTH_METRIC = "strength"  # MPa, to maximize
BIODEG_METRIC = "biodegradability_score"  # unitless score, to maximize


# Compositional total for monomer fractions
COMPOSITION_TOTAL = 1.0


def _sigmoid(z: float) -> float:
    return 1.0 / (1.0 + np.exp(-z))


def evaluate_polymer_formulation(
    monomer1_fraction: float,
    monomer2_fraction: float,
    monomer3_fraction: float,
    monomer4_fraction: float,
    monomer5_fraction: float,
    extrusion_rate: float,
    temperature: float,
) -> dict:
    """
    Synthetic evaluation model for a polymer formulation with two objectives:
      - strength (MPa), higher is better
      - biodegradability_score (0-1), higher is better

    Replace this function with actual experimental measurement or a validated simulator.

    Notes on the synthetic model:
    - Monomer contributions to strength and biodegradability are weighted.
    - Temperature and extrusion_rate modulate both objectives.
    - Small noise is added to emulate measurement noise.
    """

    # Sanity clamp for fractions and process variables
    m = np.array(
        [
            monomer1_fraction,
            monomer2_fraction,
            monomer3_fraction,
            monomer4_fraction,
            monomer5_fraction,
        ]
    )
    m = np.clip(m, 0.0, 1.0)
    # Normalize to sum to 1 (defensive, should already hold)
    s = m.sum()
    if s > 0:
        m = m / s
    m1, m2, m3, m4, m5 = m.tolist()

    # Strength contributions (MPa-like scale); m1/m4 boost strength, m5 weakest
    strength_base = 120.0 * m1 + 85.0 * m2 + 100.0 * m3 + 110.0 * m4 + 70.0 * m5

    # Temperature (C) modifier: optimal around 170C
    temp_factor = np.exp(-0.5 * ((temperature - 170.0) / 20.0) ** 2)

    # Extrusion rate (mm/s) modifier: optimal around 0.055 mm/s
    rate_factor = np.exp(-0.5 * ((extrusion_rate - 0.055) / 0.02) ** 2)

    # Synergy terms: m1 & m4 positive synergy; m2 & m5 slightly negative
    synergy = 1.0 + 0.15 * (m1 * m4) - 0.10 * (m2 * m5)

    # Combine with baseline offsets to keep meaningful range
    strength = strength_base * (0.6 + 0.5 * temp_factor) * (0.6 + 0.5 * rate_factor) * synergy

    # Add Gaussian measurement noise
    strength_noise_sd = 2.0
    strength_meas = float(max(0.0, strength + np.random.normal(0.0, strength_noise_sd)))

    # Biodegradability contributions: m3 and m5 are more biodegradable
    biodeg_base = 0.20 * m1 + 0.40 * m2 + 0.80 * m3 + 0.30 * m4 + 0.90 * m5

    # Temperature penalty (higher processing temp tends to reduce biodegradability)
    temp_penalty = 1.0 - 0.35 * _sigmoid((temperature - 160.0) / 15.0)

    # Extrusion rate bonus (slightly increases porosity)
    rate_bonus = 1.0 + 0.20 * _sigmoid((extrusion_rate - 0.05) / 0.015)

    # Cross-linking factor (m1 & m4 reduce biodegradability)
    crosslink = 1.0 - 0.20 * (m1 * m4)

    biodeg_score = biodeg_base * temp_penalty * rate_bonus * crosslink

    # Add small noise and clamp to [0, 1]
    biodeg_noise_sd = 0.03
    biodeg_meas = float(np.clip(biodeg_score + np.random.normal(0.0, biodeg_noise_sd), 0.0, 1.0))

    return {
        STRENGTH_METRIC: (strength_meas, strength_noise_sd),
        BIODEG_METRIC: (biodeg_meas, biodeg_noise_sd),
    }


def compute_observed_pareto(df: pd.DataFrame, x_col: str, y_col: str) -> pd.DataFrame:
    """
    Compute observed Pareto frontier for a 2D maximization problem from a DataFrame
    that contains columns x_col and y_col.
    Returns the subset of nondominated points sorted by x_col.
    """
    pts = df[[x_col, y_col]].dropna().to_numpy()
    if len(pts) == 0:
        return pd.DataFrame(columns=[x_col, y_col])
    is_dominated = np.zeros(len(pts), dtype=bool)
    for i in range(len(pts)):
        if is_dominated[i]:
            continue
        xi, yi = pts[i]
        # A point j dominates i if xj >= xi and yj >= yi with at least one strict
        dominates = (pts[:, 0] >= xi) & (pts[:, 1] >= yi) & (
            (pts[:, 0] > xi) | (pts[:, 1] > yi)
        )
        dominates[i] = False
        if dominates.any():
            is_dominated[i] = True
    pareto_pts = pts[~is_dominated]
    pareto_df = pd.DataFrame(pareto_pts, columns=[x_col, y_col]).sort_values(by=x_col)
    return pareto_df


# Historical literature observations (3 points).
# Provide your actual measurements here; below are example parameterizations.
# Each dict is a parameterization for monomer1..4 (monomer5 is computed),
# plus extrusion_rate and temperature. The evaluation function simulates objectives.
historical_parameterizations = [
    {
        "monomer1_fraction": 0.25,
        "monomer2_fraction": 0.20,
        "monomer3_fraction": 0.20,
        "monomer4_fraction": 0.15,
        # monomer5_fraction will be 0.20
        "extrusion_rate": 0.050,
        "temperature": 160.0,
    },
    {
        "monomer1_fraction": 0.10,
        "monomer2_fraction": 0.10,
        "monomer3_fraction": 0.35,
        "monomer4_fraction": 0.15,
        # monomer5_fraction will be 0.30
        "extrusion_rate": 0.070,
        "temperature": 175.0,
    },
    {
        "monomer1_fraction": 0.35,
        "monomer2_fraction": 0.20,
        "monomer3_fraction": 0.10,
        "monomer4_fraction": 0.25,
        # monomer5_fraction will be 0.10
        "extrusion_rate": 0.030,
        "temperature": 165.0,
    },
]


# Budget
TOTAL_TRIALS = 35


# Initialize Ax client and create experiment
ax_client = AxClient()
ax_client.create_experiment(
    name="polymer_formulation_multi_objective",
    parameters=[
        # Reparameterized composition: optimize over first 4 monomers; the 5th is 1 - sum(4)
        {"name": "monomer1_fraction", "type": "range", "bounds": [0.0, 1.0]},
        {"name": "monomer2_fraction", "type": "range", "bounds": [0.0, 1.0]},
        {"name": "monomer3_fraction", "type": "range", "bounds": [0.0, 1.0]},
        {"name": "monomer4_fraction", "type": "range", "bounds": [0.0, 1.0]},
        {"name": "extrusion_rate", "type": "range", "bounds": [0.01, 0.1]},  # mm/s
        {"name": "temperature", "type": "range", "bounds": [120.0, 200.0]},  # Celsius
    ],
    objectives={
        STRENGTH_METRIC: ObjectiveProperties(minimize=False, threshold=70.0),
        # If you know a region-of-interest threshold for biodegradability, set it here.
        # Otherwise, leave as None to let Ax infer it.
        BIODEG_METRIC: ObjectiveProperties(minimize=False, threshold=None),
    },
    parameter_constraints=[
        # Sum constraint to ensure monomer5_fraction = 1 - (m1+m2+m3+m4) >= 0
        "monomer1_fraction + monomer2_fraction + monomer3_fraction + monomer4_fraction <= 1.0",
    ],
)

# Attach historical data
for i, params in enumerate(historical_parameterizations):
    # Compute monomer5 from composition constraint
    m5 = COMPOSITION_TOTAL - (
        params["monomer1_fraction"]
        + params["monomer2_fraction"]
        + params["monomer3_fraction"]
        + params["monomer4_fraction"]
    )
    m5 = max(0.0, m5)

    eval_res = evaluate_polymer_formulation(
        monomer1_fraction=params["monomer1_fraction"],
        monomer2_fraction=params["monomer2_fraction"],
        monomer3_fraction=params["monomer3_fraction"],
        monomer4_fraction=params["monomer4_fraction"],
        monomer5_fraction=m5,
        extrusion_rate=params["extrusion_rate"],
        temperature=params["temperature"],
    )
    # Attach and complete historical trial
    ax_client.attach_trial(
        parameters={
            "monomer1_fraction": params["monomer1_fraction"],
            "monomer2_fraction": params["monomer2_fraction"],
            "monomer3_fraction": params["monomer3_fraction"],
            "monomer4_fraction": params["monomer4_fraction"],
            "extrusion_rate": params["extrusion_rate"],
            "temperature": params["temperature"],
        }
    )
    ax_client.complete_trial(trial_index=i, raw_data=eval_res)

# Optimization loop
n_existing = len(historical_parameterizations)
n_to_run = max(0, TOTAL_TRIALS - n_existing)

for _ in range(n_to_run):
    parameterization, trial_index = ax_client.get_next_trial()

    # Extract parameters and compute monomer5 fraction via composition
    m1 = parameterization["monomer1_fraction"]
    m2 = parameterization["monomer2_fraction"]
    m3 = parameterization["monomer3_fraction"]
    m4 = parameterization["monomer4_fraction"]
    m5 = COMPOSITION_TOTAL - (m1 + m2 + m3 + m4)
    m5 = max(0.0, m5)  # defensive clamp

    res = evaluate_polymer_formulation(
        monomer1_fraction=m1,
        monomer2_fraction=m2,
        monomer3_fraction=m3,
        monomer4_fraction=m4,
        monomer5_fraction=m5,
        extrusion_rate=parameterization["extrusion_rate"],
        temperature=parameterization["temperature"],
    )
    ax_client.complete_trial(trial_index=trial_index, raw_data=res)

# Retrieve Pareto-optimal arms based on observed data
pareto_params = ax_client.get_pareto_optimal_parameters(use_model_predictions=False)

# Plot observed outcomes with empirical Pareto frontier
df = ax_client.get_trials_data_frame()

# If pivoted, columns should include metric names directly; otherwise pivot manually.
if STRENGTH_METRIC not in df.columns or BIODEG_METRIC not in df.columns:
    # Attempt to pivot
    if {"metric_name", "mean"}.issubset(df.columns):
        df_wide = df.pivot_table(index="arm_name", columns="metric_name", values="mean").reset_index()
        df = df_wide
    else:
        # Fallback: try to aggregate
        try:
            df = df.groupby(["arm_name", "metric_name"])["mean"].mean().unstack().reset_index()
        except Exception:
            pass

fig, ax = plt.subplots(figsize=(7, 5), dpi=140)
if STRENGTH_METRIC in df.columns and BIODEG_METRIC in df.columns:
    ax.scatter(
        df[STRENGTH_METRIC], df[BIODEG_METRIC], fc="None", ec="k", label="Observed"
    )
    pareto_obs = compute_observed_pareto(df, STRENGTH_METRIC, BIODEG_METRIC)
    if len(pareto_obs) > 0:
        ax.plot(
            pareto_obs[STRENGTH_METRIC],
            pareto_obs[BIODEG_METRIC],
            color="#0033FF",
            lw=2,
            label="Observed Pareto Front",
        )
    ax.axvline(70.0, color="red", ls="--", lw=1.0, label="Strength threshold (70 MPa)")
    ax.set_xlabel(f"{STRENGTH_METRIC} (MPa)")
    ax.set_ylabel(f"{BIODEG_METRIC} (score)")
    ax.set_title("Observed outcomes and empirical Pareto frontier")
    ax.legend()
    plt.tight_layout()
    plt.show()
else:
    print("Could not find expected metric columns for plotting in the trials DataFrame.")

# Optional: Plot model-posterior Pareto frontier for smoother estimate
if HAVE_PARETO_PLOT:
    try:
        objectives = ax_client.experiment.optimization_config.objective.objectives
        # Choose an ordering for plotting: primary on x-axis, secondary on y-axis
        primary_obj = [o for o in objectives if o.minimize is False and o.metric.name == BIODEG_METRIC][0].metric
        secondary_obj = [o for o in objectives if o.minimize is False and o.metric.name == STRENGTH_METRIC][0].metric

        frontier = compute_posterior_pareto_frontier(
            experiment=ax_client.experiment,
            data=ax_client.experiment.fetch_data(),
            primary_objective=primary_obj,
            secondary_objective=secondary_obj,
            absolute_metrics=[STRENGTH_METRIC, BIODEG_METRIC],
            num_points=25,
        )
        render(plot_pareto_frontier(frontier, CI_level=0.90))
    except Exception as e:
        print(f"Posterior Pareto frontier plotting failed: {e}")

# Print a brief summary of Pareto-optimal parameterizations
print("\nPareto-optimal parameterizations (observed data):")
for arm_name, (params, metrics) in pareto_params.items():
    # Reconstruct monomer5 for reporting
    m5 = COMPOSITION_TOTAL - (
        params["monomer1_fraction"]
        + params["monomer2_fraction"]
        + params["monomer3_fraction"]
        + params["monomer4_fraction"]
    )
    strength_val = metrics.get(STRENGTH_METRIC)
    biodeg_val = metrics.get(BIODEG_METRIC)
    # metrics values may be tuples (mean, sem) or means; handle both
    def _val(v):
        if isinstance(v, tuple) or isinstance(v, list):
            return v[0]
        return v
    strength_str = f"{_val(strength_val):.2f}" if strength_val is not None else "NA"
    biodeg_str = f"{_val(biodeg_val):.3f}" if biodeg_val is not None else "NA"
    print(
        f"- {arm_name}: strength={strength_str} MPa, biodegradability={biodeg_str}, "
        f"fractions=[{params['monomer1_fraction']:.3f}, {params['monomer2_fraction']:.3f}, "
        f"{params['monomer3_fraction']:.3f}, {params['monomer4_fraction']:.3f}, {m5:.3f}], "
        f"extrusion_rate={params['extrusion_rate']:.3f} mm/s, temperature={params['temperature']:.1f} C"
    )