# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


obj1_name = "branin"


def branin(x1, x2):
    y = float(
        (x2 - 5.1 / (4 * np.pi**2) * x1**2 + 5.0 / np.pi * x1 - 6.0) ** 2
        + 10 * (1 - 1.0 / (8 * np.pi)) * np.cos(x1)
        + 10
    )

    return y


ax_client = AxClient()

ax_client.create_experiment(
    parameters=[
        {"name": "x1", "type": "range", "bounds": [-5.0, 10.0]},
        {"name": "x2", "type": "range", "bounds": [0.0, 10.0]},
    ],
    objectives={
        obj1_name: ObjectiveProperties(minimize=True),
    },
)


for i in range(19):

    parameterization, trial_index = ax_client.get_next_trial()

    # extract parameters
    x1 = parameterization["x1"]
    x2 = parameterization["x2"]

    results = branin(x1, x2)
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)

best_parameters, metrics = ax_client.get_best_parameters()


# Plot results
objectives = ax_client.objective_names
df = ax_client.get_trials_data_frame()

fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
ax.scatter(df.index, df[objectives], ec="k", fc="none", label="Observed")
ax.plot(
    df.index,
    np.minimum.accumulate(df[objectives]),
    color="#0033FF",
    lw=2,
    label="Best to Trial",
)
ax.set_xlabel("Trial Number")
ax.set_ylabel(objectives[0])

ax.legend()
plt.show()

# Generated from Honegumi skeleton and adapted to catalyst synthesis optimization
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from typing import Dict, Tuple

from ax.service.ax_client import AxClient, ObjectiveProperties


# Domain-specific names
objective_name = "catalytic_activity"  # units: μmol/g·s

# Random generator for reproducibility of the simulated measurement noise
rng = np.random.default_rng(seed=2025)


def evaluate_catalyst_activity(calcination_temperature_celsius: float, calcination_time_hours: float) -> Dict[str, Tuple[float, float]]:
    """Simulate measuring catalytic activity (μmol/g·s) of a catalyst after calcination.

    This is a realistic stub for demonstration. Replace with your lab's measurement logic:
      - Run the calcination at the specified temperature and time
      - Measure catalytic activity (e.g., via probe reaction rate in μmol/g·s)
      - Estimate measurement uncertainty (standard error of the mean)

    The synthetic model below assumes:
      - Activity peaks near 500°C and 5 hours due to optimal phase/dispersion
      - Over-calcination (too high T or too long time) reduces activity
      - Measurement noise increases mildly with signal magnitude
    """
    T = calcination_temperature_celsius
    t = calcination_time_hours

    # Peak location and widths (domain-informed but illustrative)
    T_opt = 500.0
    t_opt = 5.0
    sigma_T = 60.0
    sigma_logt = 0.25  # width in log-time space

    # Base peak (2D Gaussian in T and log(t))
    logt = np.log(t)
    logt_opt = np.log(t_opt)
    peak = np.exp(-0.5 * ((T - T_opt) / sigma_T) ** 2 - 0.5 * ((logt - logt_opt) / sigma_logt) ** 2)

    # Mild interaction and asymmetry effects (domain-inspired shaping)
    interaction = 1.0 - 0.0004 * (T - 450.0) * (t - 4.0)
    interaction = np.clip(interaction, 0.6, 1.4)

    # Penalize very long times and very high temperatures (sintering/phase change)
    penalty_T = 1.0 / (1.0 + np.exp((T - 560.0) / 12.0)) * 0.15 + 0.85
    penalty_t = 1.0 / (1.0 + np.exp((t - 7.2) / 0.25)) * 0.2 + 0.8

    # Scale to a plausible activity range (0 to ~1000 μmol/g·s)
    activity_mean = 980.0 * peak * interaction * penalty_T * penalty_t

    # Add heteroscedastic measurement noise
    noise_sd = 0.05 * activity_mean + 5.0  # 5% of signal + floor
    measured_activity = activity_mean + rng.normal(0.0, noise_sd)

    # Standard error of the mean (SEM) if you average a few replicates (n~3)
    sem = noise_sd / np.sqrt(3.0)

    # Ensure non-negative reported activity
    measured_activity = float(max(0.0, measured_activity))
    sem = float(max(1e-6, sem))

    return {objective_name: (measured_activity, sem)}


def main() -> None:
    # Configure Ax for single-objective, sequential optimization
    ax_client = AxClient(enforce_sequential_optimization=True)

    ax_client.create_experiment(
        name="catalyst_calcination_optimization",
        parameters=[
            {
                "name": "calcination_temperature_celsius",
                "type": "range",
                "bounds": [300.0, 600.0],
            },
            {
                "name": "calcination_time_hours",
                "type": "range",
                "bounds": [2.0, 8.0],
            },
        ],
        objectives={
            objective_name: ObjectiveProperties(minimize=False),
        },
        # No additional constraints for this problem
        choose_generation_strategy_kwargs=None,
    )

    total_trials = 25  # Budget

    for i in range(total_trials):
        parameterization, trial_index = ax_client.get_next_trial()

        # Extract parameters for this trial
        calcination_temperature_celsius = float(parameterization["calcination_temperature_celsius"])
        calcination_time_hours = float(parameterization["calcination_time_hours"])

        # Evaluate (replace with actual experiment/measurement in production)
        results = evaluate_catalyst_activity(
            calcination_temperature_celsius=calcination_temperature_celsius,
            calcination_time_hours=calcination_time_hours,
        )

        ax_client.complete_trial(trial_index=trial_index, raw_data=results)

    best_parameters, best_values = ax_client.get_best_parameters()
    print("Best parameters found:")
    print(best_parameters)
    print("Best estimated objective values (model-predicted):")
    print(best_values)

    # Visualization: objective value per trial and best-so-far curve (maximize)
    objectives = ax_client.objective_names
    df = ax_client.get_trials_data_frame()

    # Derive x-axis and y-values robustly
    if "trial_index" in df.columns:
        x_vals = df["trial_index"].to_numpy()
    else:
        x_vals = np.arange(len(df))

    # Try common column naming patterns for objective mean
    if objectives[0] in df.columns:
        y_vals = df[objectives[0]].to_numpy()
    elif f"{objectives[0]}__mean" in df.columns:
        y_vals = df[f"{objectives[0]}__mean"].to_numpy()
    elif f"mean_{objectives[0]}" in df.columns:
        y_vals = df[f"mean_{objectives[0]}"].to_numpy()
    else:
        # Fallback: first column containing the objective name
        y_col = df.filter(like=objectives[0]).columns[0]
        y_vals = df[y_col].to_numpy()

    best_so_far = np.maximum.accumulate(y_vals)

    fig, ax = plt.subplots(figsize=(7, 4), dpi=150)
    ax.scatter(x_vals, y_vals, ec="k", fc="none", label="Observed activity")
    ax.plot(x_vals, best_so_far, color="#0033FF", lw=2, label="Best so far")
    ax.set_xlabel("Trial number")
    ax.set_ylabel(f"{objectives[0]} (μmol/g·s)")
    ax.set_title("Catalytic activity over trials")
    ax.legend()
    plt.tight_layout()
    plt.show()


if __name__ == "__main__":
    main()