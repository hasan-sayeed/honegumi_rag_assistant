# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from typing import Dict, Tuple
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


# Domain-specific metric names
REFRACTIVE_INDEX = "refractive_index"  # maximize
DISPERSION = "dispersion"  # minimize (higher means more dispersion)

# Composition totals and parameter bounds (percent by weight)
COMPOSITION_TOTAL = 100.0
SIO2_BOUNDS = (50.0, 70.0)  # derived via constraint on modifiers
NA2O_BOUNDS = (15.0, 25.0)
CAO_BOUNDS = (10.0, 20.0)

# Budget
N_TRIALS = 38

# Random generator for reproducibility of noisy measurements
rng = np.random.default_rng(2025)


def evaluate_optical_glass(na2o_pct: float, cao_pct: float) -> Dict[str, Tuple[float, float]]:
    """Evaluate optical glass properties from composition (SiO2-Na2O-CaO).

    This function simulates realistic, noisy measurements for:
      - refractive_index: higher is better
      - dispersion: lower is better (proxy metric proportional to chromatic dispersion)

    TODO: Replace this simulation with actual experimental or simulation logic as needed.
    For example:
      - Interface to a refractometer and spectrometer for real measurements
      - Call a physics-based optical property simulator using Sellmeier coefficients
      - Query a database of prior glass compositions and properties

    Args:
        na2o_pct: Na2O composition in percent by weight.
        cao_pct:  CaO composition in percent by weight.

    Returns:
        Dict with metric -> (mean, standard_error) for Ax.
    """
    siO2_pct = COMPOSITION_TOTAL - na2o_pct - cao_pct

    # Validate feasibility (should be ensured by constraints, but check for numerical safety)
    if not (SIO2_BOUNDS[0] - 1e-9 <= siO2_pct <= SIO2_BOUNDS[1] + 1e-9):
        raise ValueError(
            f"Infeasible SiO2 derived from modifiers: {siO2_pct:.3f}%. "
            f"Expected within {SIO2_BOUNDS}. Check constraints."
        )

    # Convert to fractions for mixture rules
    f_si = siO2_pct / 100.0
    f_na = na2o_pct / 100.0
    f_ca = cao_pct / 100.0

    # Representative single-oxide refractive indices at d-line (approximate)
    n_si = 1.458  # fused silica
    n_na = 1.633
    n_ca = 1.840

    # Linear mixing baseline + small interaction terms to induce realistic trade-offs
    n_linear = n_si * f_si + n_na * f_na + n_ca * f_ca
    n_interaction = 0.04 * f_na * f_ca + 0.01 * f_na * f_na - 0.015 * f_si * f_ca
    n_det = n_linear + n_interaction

    # Dispersion proxy (higher for modifiers, lower for SiO2); interaction raises dispersion with co-modifiers
    disp_linear = 0.020 * f_si + 0.050 * f_na + 0.065 * f_ca
    disp_interaction = 0.030 * f_na * f_ca - 0.010 * f_si * f_na
    d_det = disp_linear + disp_interaction

    # Add measurement noise (assume repeatability-limited SEM)
    n_sem = 8e-4
    d_sem = 1.5e-3
    n_meas = float(n_det + rng.normal(0.0, n_sem))
    d_meas = float(d_det + rng.normal(0.0, d_sem))

    return {
        REFRACTIVE_INDEX: (n_meas, n_sem),
        DISPERSION: (d_meas, d_sem),
    }


# Set up Ax client and experiment
ax_client = AxClient(random_seed=42)

# We reparameterize the composition by optimizing modifiers (Na2O, CaO) and deriving SiO2 as the remainder.
# Constraints to enforce SiO2 bounds: 50 <= 100 - Na2O - CaO <= 70  ->  30 <= Na2O + CaO <= 50
ax_client.create_experiment(
    parameters=[
        {"name": "Na2O", "type": "range", "bounds": [NA2O_BOUNDS[0], NA2O_BOUNDS[1]]},
        {"name": "CaO", "type": "range", "bounds": [CAO_BOUNDS[0], CAO_BOUNDS[1]]},
    ],
    objectives={
        REFRACTIVE_INDEX: ObjectiveProperties(minimize=False),
        DISPERSION: ObjectiveProperties(minimize=True),
    },
    parameter_constraints=[
        "Na2O + CaO >= 30.0",
        "Na2O + CaO <= 50.0",
    ],
)

# Optimization loop
for _ in range(N_TRIALS):
    parameterization, trial_index = ax_client.get_next_trial()

    na2o_pct = float(parameterization["Na2O"])
    cao_pct = float(parameterization["CaO"])

    results = evaluate_optical_glass(na2o_pct, cao_pct)
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)

# Retrieve observed Pareto set
pareto = ax_client.get_pareto_optimal_parameters(use_model_predictions=False)

# Plot results
objectives = ax_client.objective_names
df = ax_client.get_trials_data_frame()

fig, ax = plt.subplots(figsize=(7, 5), dpi=150)
ax.scatter(df[REFRACTIVE_INDEX], df[DISPERSION], fc="None", ec="k", label="Observed")

pareto_points = []
for _, (_, vals) in pareto.items():
    # vals: dict metric -> (mean, sem)
    pareto_points.append(
        {
            REFRACTIVE_INDEX: float(vals[REFRACTIVE_INDEX][0]),
            DISPERSION: float(vals[DISPERSION][0]),
        }
    )
if pareto_points:
    pareto_df = pd.DataFrame(pareto_points).sort_values(REFRACTIVE_INDEX)
    ax.plot(
        pareto_df[REFRACTIVE_INDEX],
        pareto_df[DISPERSION],
        color="#0033FF",
        lw=2,
        label="Pareto Front",
    )

ax.set_xlabel("Refractive index (d-line, a.u.)")
ax.set_ylabel("Dispersion (proxy, lower is better)")
ax.set_title("SiO2–Na2O–CaO Glass Optimization: Pareto Front")
ax.legend()
plt.tight_layout()
plt.show()