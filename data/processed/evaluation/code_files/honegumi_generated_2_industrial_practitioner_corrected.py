# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from typing import Dict, Tuple
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


# Objective name for this problem
objective_name = "corrosion_damage_score"


def evaluate_coating_corrosion_damage(
    resin_fraction: float,
    inhibitor_fraction: float,
    insulator_fraction: float,
    stabilizer_fraction: float,
    coating_thickness_mm: float,
    rng: np.random.Generator,
) -> Dict[str, Tuple[float, float]]:
    """
    Evaluate the anti-corrosion coating by returning the corrosion damage score (to be minimized).

    This is a realistic stub that emulates a physical measurement:
    - Higher inhibitor reduces corrosion (diminishing returns).
    - Resin supports adhesion and barrier formation (moderate benefit).
    - Insulator improves barrier properties (moderate benefit).
    - Small stabilizer improves durability, but effect saturates and can slightly worsen at the high end.
    - Greater coating thickness reduces corrosion with diminishing returns.
    - Adds measurement variability to reflect experimental noise.

    Returns:
        Dict[str, (mean, sem)]: {"corrosion_damage_score": (observed_value, standard_error)}
    """
    # Safety: enforce numeric bounds within feasible region (should already be ensured by constraints)
    resin_fraction = float(np.clip(resin_fraction, 0.0, 1.0))
    inhibitor_fraction = float(np.clip(inhibitor_fraction, 0.0, 1.0))
    insulator_fraction = float(np.clip(insulator_fraction, 0.0, 1.0))
    stabilizer_fraction = float(np.clip(stabilizer_fraction, 0.0, 0.1))
    coating_thickness_mm = float(np.clip(coating_thickness_mm, 0.1, 10.0))

    # Protective effects (heuristic, with saturation/diminishing returns)
    eff_inhibitor = 2.7 * inhibitor_fraction**0.55
    eff_resin = 1.3 * resin_fraction**0.6
    eff_insulator = 1.6 * insulator_fraction**0.6

    # Synergistic interactions
    synergy_ri = 0.55 * np.sqrt(max(resin_fraction * inhibitor_fraction, 0.0))
    synergy_is = 0.45 * np.sqrt(max(inhibitor_fraction * insulator_fraction, 0.0))
    synergy_rs = 0.25 * np.sqrt(max(resin_fraction * insulator_fraction, 0.0))

    # Stabilizer small positive effect that saturates near ~0.05 and slightly penalizes near 0.1
    stabilizer_effect = 0.35 * (1 - np.exp(-stabilizer_fraction / 0.02)) - 0.15 * max(stabilizer_fraction - 0.08, 0.0)

    # Thickness effect (diminishing returns)
    thickness_effect = 2.2 * (1 - np.exp(-0.45 * coating_thickness_mm))

    # Aggregate protective effect
    effective_protection = (
        eff_inhibitor
        + eff_resin
        + eff_insulator
        + synergy_ri
        + synergy_is
        + synergy_rs
        + stabilizer_effect
        + thickness_effect
    )

    # Baseline corrosion damage (arbitrary scale)
    base_damage = 55.0

    # Convert protection to damage (lower is better)
    true_damage = base_damage * np.exp(-effective_protection)

    # Introduce experimental noise and report standard error
    measurement_sd = 1.5  # standard deviation of measurement variability
    observed_damage = float(true_damage + rng.normal(0.0, measurement_sd))
    observed_damage = max(observed_damage, 0.0)  # ensure non-negative

    return {objective_name: (observed_damage, measurement_sd)}


# Reparameterization for composition constraint:
# We optimize over resin_fraction, inhibitor_fraction, insulator_fraction, and thickness.
# Stabilizer fraction is computed as 1 - (resin + inhibitor + insulator).
# To respect stabilizer bounds [0, 0.1], we enforce:
#    resin + inhibitor + insulator <= 1.0   (stabilizer >= 0)
#    resin + inhibitor + insulator >= 0.9   (stabilizer <= 0.1)
# We also enforce ordering:
#    resin_fraction >= inhibitor_fraction
#    resin_fraction >= insulator_fraction

ax_client = AxClient()

ax_client.create_experiment(
    name="anti_corrosion_coating_optimization",
    parameters=[
        {"name": "resin_fraction", "type": "range", "bounds": [0.0, 1.0]},
        {"name": "inhibitor_fraction", "type": "range", "bounds": [0.0, 1.0]},
        {"name": "insulator_fraction", "type": "range", "bounds": [0.0, 1.0]},
        {"name": "coating_thickness_mm", "type": "range", "bounds": [0.1, 10.0]},
    ],
    objectives={
        objective_name: ObjectiveProperties(minimize=True),
    },
    parameter_constraints=[
        # Composition constraints to ensure computed stabilizer_fraction in [0, 0.1]
        "resin_fraction + inhibitor_fraction + insulator_fraction <= 1.0",
        "resin_fraction + inhibitor_fraction + insulator_fraction >= 0.9",
        # Ordering constraints
        "resin_fraction >= inhibitor_fraction",
        "resin_fraction >= insulator_fraction",
    ],
)

# Experimental settings
batch_size = 6               # 6 samples per batch
num_batches = 20             # 15â€“20 batches planned; use 20 for full 120-trial budget
rng = np.random.default_rng(12345)  # RNG for reproducible measurement variability

for batch_idx in range(num_batches):
    parameterizations, optimization_complete = ax_client.get_next_trials(batch_size)
    for trial_index, p in list(parameterizations.items()):
        resin_fraction = float(p["resin_fraction"])
        inhibitor_fraction = float(p["inhibitor_fraction"])
        insulator_fraction = float(p["insulator_fraction"])
        coating_thickness_mm = float(p["coating_thickness_mm"])

        # Compute stabilizer from composition (guaranteed to be within [0, 0.1] by constraints above)
        stabilizer_fraction = 1.0 - (resin_fraction + inhibitor_fraction + insulator_fraction)

        try:
            results = evaluate_coating_corrosion_damage(
                resin_fraction=resin_fraction,
                inhibitor_fraction=inhibitor_fraction,
                insulator_fraction=insulator_fraction,
                stabilizer_fraction=stabilizer_fraction,
                coating_thickness_mm=coating_thickness_mm,
                rng=rng,
            )
        except Exception as e:
            # In case of evaluation failure, assign a large penalty
            results = {objective_name: (1e6, 10.0)}
        ax_client.complete_trial(trial_index=trial_index, raw_data=results)

    if optimization_complete:
        break

best_parameters, best_metrics = ax_client.get_best_parameters()
best_params = best_parameters
# Recover stabilizer for the best found recipe
best_stabilizer = 1.0 - (
    best_params["resin_fraction"] + best_params["inhibitor_fraction"] + best_params["insulator_fraction"]
)

print("Best parameters found (with computed stabilizer_fraction):")
print(
    {
        "resin_fraction": best_params["resin_fraction"],
        "inhibitor_fraction": best_params["inhibitor_fraction"],
        "insulator_fraction": best_params["insulator_fraction"],
        "stabilizer_fraction": best_stabilizer,
        "coating_thickness_mm": best_params["coating_thickness_mm"],
    }
)
print("Best objective metrics (mean, sem):")
print(best_metrics)

# Plot results over batches
df = ax_client.get_trials_data_frame()
# Keep only completed trials with observations for the objective
df = df[df["trial_status"] == "COMPLETED"]
y = df[objective_name]
# Map trial index to batch index for plotting
df = df.copy()
df["batch_idx"] = df["trial_index"] // batch_size

fig, ax = plt.subplots(figsize=(7, 4.5), dpi=150)
ax.scatter(df["batch_idx"], y, ec="k", fc="none", label="Observed")
# Best-so-far per trial in chronological order
y_bsf = np.minimum.accumulate(y.values)
ax.plot(df["batch_idx"].values, y_bsf, color="#0033FF", lw=2, label="Best to Trial")
ax.set_xlabel("Batch Number")
ax.set_ylabel("Corrosion Damage Score (lower is better)")
ax.set_title("Anti-corrosion Coating Optimization Progress")
ax.legend()
plt.tight_layout()
plt.show()