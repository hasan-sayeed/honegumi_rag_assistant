# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


obj1_name = "branin"


def branin3(x1, x2, x3):
    y = float(
        (x2 - 5.1 / (4 * np.pi**2) * x1**2 + 5.0 / np.pi * x1 - 6.0) ** 2
        + 10 * (1 - 1.0 / (8 * np.pi)) * np.cos(x1)
        + 10
    )

    # Contrived way to incorporate x3 into the objective
    y = y * (1 + 0.1 * x1 * x2 * x3)

    return y


# Define total for compositional constraint, where x1 + x2 + x3 == total
total = 10.0


ax_client = AxClient()

ax_client.create_experiment(
    parameters=[
        {"name": "x1", "type": "range", "bounds": [0.0, total]},
        {"name": "x2", "type": "range", "bounds": [0.0, total]},
    ],
    objectives={
        obj1_name: ObjectiveProperties(minimize=True),
    },
    parameter_constraints=[
        f"x1 + x2 <= {total}",  # reparameterized compositional constraint, which is a type of sum constraint
    ],
)


for i in range(21):

    parameterization, trial_index = ax_client.get_next_trial()

    # extract parameters
    x1 = parameterization["x1"]
    x2 = parameterization["x2"]
    x3 = total - (x1 + x2)  # composition constraint: x1 + x2 + x3 == total

    results = branin3(x1, x2, x3)
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)

best_parameters, metrics = ax_client.get_best_parameters()


# Plot results
objectives = ax_client.objective_names
df = ax_client.get_trials_data_frame()

fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
ax.scatter(df.index, df[objectives], ec="k", fc="none", label="Observed")
ax.plot(
    df.index,
    np.minimum.accumulate(df[objectives]),
    color="#0033FF",
    lw=2,
    label="Best to Trial",
)
ax.set_xlabel("Trial Number")
ax.set_ylabel(objectives[0])

ax.legend()
plt.show()

# Generated by adapting a Honegumi skeleton for RGB liquid color matching with AS7341
# %pip install ax-platform==0.4.3 matplotlib numpy pandas
import math
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


# -----------------------------
# Problem-specific configuration
# -----------------------------
# AS7341 channels: 415, 445, 480, 515, 555, 590, 630, 680 nm
CHANNEL_WAVELENGTHS_NM = np.array([415, 445, 480, 515, 555, 590, 630, 680], dtype=float)

# Total fraction must sum to 1.0 (composition constraint)
TOTAL_FRACTION = 1.0

# Objective name
OBJECTIVE_NAME = "spectral_mismatch"  # Lower is better

# Measurement configuration
USE_REAL_SENSOR = False  # Set True if integrating with actual AS7341 hardware
N_REPLICATE_READS = 3    # Number of replicate sensor reads per mixture to estimate noise
NOISE_STD_SIM = 0.01     # Simulated measurement noise (standard deviation) on normalized spectrum

# Randomness control for simulation repeatability
RNG = np.random.default_rng(12345)


# -----------------------------
# Sensor interface (optional)
# -----------------------------
def read_as7341_spectrum(n_averages: int = 5):
    """
    Attempt to read an 8-channel spectrum from an AS7341 sensor (if available).
    Returns None if the sensor library is not available, or a numpy array of length 8 if successful.
    """
    try:
        # Placeholder for real sensor import; adjust per your hardware library
        # from some_as7341_library import AS7341
        # sensor = AS7341()
        # readings = []
        # for _ in range(n_averages):
            # readings.append(sensor.read_channels())  # expected to return array-like of length 8
        # spectrum = np.mean(np.array(readings), axis=0)
        # return np.asarray(spectrum, dtype=float)
        return None  # Remove this line and uncomment above to use real sensor
    except Exception:
        return None


# -----------------------------
# Spectral models for simulation
# -----------------------------
def gaussian_peaks(wavelengths: np.ndarray, peaks: list[tuple[float, float]]) -> np.ndarray:
    """
    Create a spectrum as a sum of Gaussian peaks.
    peaks: list of (center_nm, sigma_nm)
    """
    spec = np.zeros_like(wavelengths, dtype=float)
    for center, sigma in peaks:
        spec += np.exp(-0.5 * ((wavelengths - center) / sigma) ** 2)
    return spec


def build_pure_dye_spectra() -> dict:
    """
    Return normalized pure spectra for red, yellow, blue dyes (length-8 arrays).
    The shapes are heuristic and intended for a plausible simulation.
    """
    # Heuristic peaks for each dye
    red_spec = gaussian_peaks(CHANNEL_WAVELENGTHS_NM, [(630, 18), (680, 18)])
    yellow_spec = gaussian_peaks(CHANNEL_WAVELENGTHS_NM, [(555, 20), (590, 20)])
    blue_spec = gaussian_peaks(CHANNEL_WAVELENGTHS_NM, [(415, 15), (445, 15), (480, 15)])

    # Normalize each to sum to 1
    red_spec /= red_spec.sum()
    yellow_spec /= yellow_spec.sum()
    blue_spec /= blue_spec.sum()

    return {
        "red": red_spec,
        "yellow": yellow_spec,
        "blue": blue_spec,
    }


PURE_SPECTRA = build_pure_dye_spectra()


def simulate_as7341_measurement(red_fraction: float, yellow_fraction: float, blue_fraction: float) -> np.ndarray:
    """
    Simulate AS7341 reading by linearly mixing pure spectra and adding small noise.
    Returns a length-8 array representing measured intensities per channel.
    """
    # Linear mixture (approximation)
    mixed = (
        red_fraction * PURE_SPECTRA["red"]
        + yellow_fraction * PURE_SPECTRA["yellow"]
        + blue_fraction * PURE_SPECTRA["blue"]
    )
    # Additive noise
    noise = RNG.normal(loc=0.0, scale=NOISE_STD_SIM, size=mixed.shape)
    measured = mixed + noise
    # Ensure non-negative
    measured = np.clip(measured, a_min=0.0, a_max=None)
    return measured


def normalize_spectrum(x: np.ndarray, eps: float = 1e-12) -> np.ndarray:
    """
    Normalize spectrum to unit L1 norm (sum to 1), to focus on spectral shape.
    """
    s = float(np.sum(x))
    if s < eps:
        return np.ones_like(x) / len(x)
    return x / s


def spectral_mse(s1: np.ndarray, s2: np.ndarray) -> float:
    """
    Mean squared error between two length-8 normalized spectra.
    """
    return float(np.mean((s1 - s2) ** 2))


# -----------------------------
# Target spectrum setup
# -----------------------------
def build_target_spectrum() -> np.ndarray:
    """
    Define the target spectrum to match.
    Option 1: Use real sensor measurement (if available) of the target liquid.
    Option 2: Simulate a target via hidden ground-truth fractions (default).
    """
    if USE_REAL_SENSOR:
        spec = read_as7341_spectrum(n_averages=10)
        if spec is not None:
            return normalize_spectrum(np.asarray(spec, dtype=float))

    # Default: simulated target using hidden true fractions
    hidden_true_fractions = np.array([0.22, 0.53, 0.25], dtype=float)  # red, yellow, blue
    target = (
        hidden_true_fractions[0] * PURE_SPECTRA["red"]
        + hidden_true_fractions[1] * PURE_SPECTRA["yellow"]
        + hidden_true_fractions[2] * PURE_SPECTRA["blue"]
    )
    return normalize_spectrum(target)


TARGET_SPECTRUM = build_target_spectrum()


# -----------------------------
# Evaluation logic
# -----------------------------
def evaluate_rgb_mixture(red_fraction: float, yellow_fraction: float, blue_fraction: float) -> dict:
    """
    Evaluate spectral mismatch between the mixed liquid and the target spectrum.

    Returns a dict: {"spectral_mismatch": (mean, sem)}
    """
    # Guard against floating-point drift outside feasible region
    red_fraction = float(np.clip(red_fraction, 0.0, 1.0))
    yellow_fraction = float(np.clip(yellow_fraction, 0.0, 1.0))
    blue_fraction = float(np.clip(blue_fraction, 0.0, 1.0))

    # Read sensor (if available) or simulate replicate measurements
    replicate_losses = []
    for _ in range(N_REPLICATE_READS):
        if USE_REAL_SENSOR:
            spec = read_as7341_spectrum(n_averages=5)
            if spec is None:
                # If sensor not available, fall back to simulation for a valid run
                spec = simulate_as7341_measurement(red_fraction, yellow_fraction, blue_fraction)
        else:
            spec = simulate_as7341_measurement(red_fraction, yellow_fraction, blue_fraction)

        norm_spec = normalize_spectrum(np.asarray(spec, dtype=float))
        loss = spectral_mse(norm_spec, TARGET_SPECTRUM)
        replicate_losses.append(loss)

    replicate_losses = np.asarray(replicate_losses, dtype=float)
    mean_loss = float(np.mean(replicate_losses))
    # Unbiased sample standard deviation with ddof=1, guard small N
    if len(replicate_losses) > 1:
        sem_loss = float(np.std(replicate_losses, ddof=1) / math.sqrt(len(replicate_losses)))
    else:
        sem_loss = 0.0

    return {OBJECTIVE_NAME: (mean_loss, sem_loss)}


# -----------------------------
# Optimization with Ax
# -----------------------------
def main():
    ax_client = AxClient()
    ax_client.create_experiment(
        name="rgb_liquid_color_matching",
        parameters=[
            # Reparameterize the composition constraint: optimize over red + yellow, compute blue
            {"name": "red_fraction", "type": "range", "bounds": [0.0, TOTAL_FRACTION]},
            {"name": "yellow_fraction", "type": "range", "bounds": [0.0, TOTAL_FRACTION]},
        ],
        objectives={
            OBJECTIVE_NAME: ObjectiveProperties(minimize=True),
        },
        parameter_constraints=[
            f"red_fraction + yellow_fraction <= {TOTAL_FRACTION}",
        ],
    )

    # Budget: 30 mixtures
    n_trials = 30
    for _ in range(n_trials):
        parameterization, trial_index = ax_client.get_next_trial()

        red_fraction = float(parameterization["red_fraction"])
        yellow_fraction = float(parameterization["yellow_fraction"])
        blue_fraction = float(TOTAL_FRACTION - (red_fraction + yellow_fraction))
        if blue_fraction < 0.0:
            blue_fraction = 0.0  # numerical guard

        results = evaluate_rgb_mixture(red_fraction, yellow_fraction, blue_fraction)
        ax_client.complete_trial(trial_index=trial_index, raw_data=results)

    best_parameters, best_values = ax_client.get_best_parameters()
    best_red = float(best_parameters["red_fraction"])
    best_yellow = float(best_parameters["yellow_fraction"])
    best_blue = float(TOTAL_FRACTION - (best_red + best_yellow))

    print("Best estimated mixture (fractions):")
    print(f"  red_fraction:    {best_red:.4f}")
    print(f"  yellow_fraction: {best_yellow:.4f}")
    print(f"  blue_fraction:   {best_blue:.4f}")
    if OBJECTIVE_NAME in best_values:
        val = best_values[OBJECTIVE_NAME]
        mean = val["mean"]
        sem = val.get("sem", None)
        if sem is not None:
            print(f"Estimated minimum {OBJECTIVE_NAME}: {mean:.6f} ± {sem:.6f}")
        else:
            print(f"Estimated minimum {OBJECTIVE_NAME}: {mean:.6f}")

    # Plot optimization trace
    objectives = ax_client.objective_names
    df = ax_client.get_trials_data_frame()

    # Attempt to access metric column robustly
    y_series = None
    if len(objectives) == 1:
        obj = objectives[0]
        if obj in df.columns:
            y_series = df[obj]
        else:
            # Fallback: find a column containing the objective name
            matches = [c for c in df.columns if isinstance(c, str) and obj in c]
            if matches:
                y_series = df[matches[0]]
    else:
        # Multi-objective not used here
        pass

    if y_series is None:
        # Fallback to last numeric column
        num_cols = df.select_dtypes(include=[float, int]).columns
        if len(num_cols) > 0:
            y_series = df[num_cols[-1]]
        else:
            y_series = pd.Series([], dtype=float)

    fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
    ax.scatter(df.index, y_series, ec="k", fc="none", label="Observed")
    if len(y_series) > 0:
        best_so_far = np.minimum.accumulate(y_series.values)
        ax.plot(df.index, best_so_far, color="#0033FF", lw=2, label="Best to Trial")
    ax.set_xlabel("Trial Number")
    ax.set_ylabel(OBJECTIVE_NAME)
    ax.set_title("Spectral mismatch optimization trace")
    ax.legend()
    plt.tight_layout()
    plt.show()


if __name__ == "__main__":
    main()