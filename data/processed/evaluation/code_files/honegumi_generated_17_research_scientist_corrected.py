# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


# Domain-specific metric name
EDGE_ROUGHNESS_METRIC_NAME = "edge_roughness_micrometers"

# Global RNG for reproducible synthetic measurements (replace with real measurements in lab)
_RNG = np.random.default_rng(2025)


def evaluate_laser_cut_edge_roughness(laser_power_watts: float, cutting_speed_mm_per_s: float) -> float:
    """
    Synthetic evaluator for laser cutting edge roughness (μm).

    This function emulates typical behavior observed in laser cutting:
    - Roughness is strongly governed by linear energy density (LED = P / v).
    - There exists an optimal LED window; deviations increase roughness.
    - Extreme speeds or powers can also worsen roughness (e.g., dross, striations).
    - Includes small stochastic noise to mimic profilometry measurement noise.

    Replace this with actual experimental measurement:
      1) Run a cut at the provided laser_power_watts and cutting_speed_mm_per_s.
      2) Measure edge roughness via profilometry (in micrometers, μm).
      3) Return the measured roughness value as a float.

    Parameters
    ----------
    laser_power_watts : float
        Laser power in Watts, expected in [500, 2000].
    cutting_speed_mm_per_s : float
        Cutting speed in mm/s, expected in [10, 100].

    Returns
    -------
    float
        Edge roughness in micrometers (μm). Lower is better.
    """
    # Linear energy density (J/mm)
    led = laser_power_watts / max(cutting_speed_mm_per_s, 1e-9)

    # Phenomenological model
    # Target LED where roughness tends to be minimal (set within domain)
    led_opt = 12.0  # J/mm (example typical optimum)
    # Base minimal achievable roughness (μm)
    r_min = 2.0

    # Penalize deviations from optimal LED (log-scale symmetry)
    led_term = 10.0 * (np.log(led / led_opt)) ** 2

    # Mild curvature penalties to discourage extreme ends of each range
    # Normalize parameters to [0, 1] over their bounds
    p_min, p_max = 500.0, 2000.0
    v_min, v_max = 10.0, 100.0
    p_norm = (laser_power_watts - p_min) / (p_max - p_min)
    v_norm = (cutting_speed_mm_per_s - v_min) / (v_max - v_min)
    power_term = 2.0 * (p_norm - 0.55) ** 2
    speed_term = 3.0 * (v_norm - 0.50) ** 2

    # Aggregate deterministic roughness
    roughness = r_min + led_term + power_term + speed_term

    # Add measurement/process noise to emulate profilometry and process variability
    noise_sd_um = 0.3
    roughness_noisy = float(roughness + _RNG.normal(0.0, noise_sd_um))

    # Ensure physically reasonable non-negative roughness
    return max(0.1, roughness_noisy)


# Set up Bayesian optimization with Ax
ax_client = AxClient()

ax_client.create_experiment(
    name="laser_cutting_edge_roughness_optimization",
    parameters=[
        {
            "name": "laser_power_watts",
            "type": "range",
            "bounds": [500.0, 2000.0],
        },
        {
            "name": "cutting_speed_mm_per_s",
            "type": "range",
            "bounds": [10.0, 100.0],
        },
    ],
    objectives={
        EDGE_ROUGHNESS_METRIC_NAME: ObjectiveProperties(minimize=True),
    },
    # No outcome constraints or parameter constraints in this problem
    # Expect noisy measurements; Ax will model observation noise
)


# Run optimization for the specified budget of 30 experiments
N_TRIALS = 30
for _ in range(N_TRIALS):
    parameterization, trial_index = ax_client.get_next_trial()

    # Extract parameters
    power = float(parameterization["laser_power_watts"])
    speed = float(parameterization["cutting_speed_mm_per_s"])

    # Evaluate (replace with real experimental measurement)
    measured_roughness_um = evaluate_laser_cut_edge_roughness(power, speed)

    # Report result back to Ax (single objective; pass scalar or dict)
    ax_client.complete_trial(trial_index=trial_index, raw_data=measured_roughness_um)


best_parameters, best_metrics = ax_client.get_best_parameters()

print("Best parameters found:")
for k, v in best_parameters.items():
    print(f"  {k}: {v:.4f}")
print("Best observed metric:")
for m_name, m_stats in best_metrics.items():
    val = m_stats.get("value", None)
    sem = m_stats.get("standard_error", m_stats.get("sem", None))
    if val is not None and sem is not None:
        print(f"  {m_name}: {val:.4f} μm (sem ~ {sem:.4f})")
    elif val is not None:
        print(f"  {m_name}: {val:.4f} μm")


# Visualization of optimization progress
objectives = ax_client.objective_names
df = ax_client.get_trials_data_frame()

# Extract single objective series robustly
if isinstance(objectives, (list, tuple)) and len(objectives) == 1:
    metric_name = objectives[0]
else:
    raise RuntimeError("Expected a single objective for plotting.")

y = df[metric_name].values
trial_indices = np.arange(len(df), dtype=int)

fig, ax = plt.subplots(figsize=(7, 4.5), dpi=150)
ax.scatter(trial_indices, y, ec="k", fc="none", label="Observed")
ax.plot(trial_indices, np.minimum.accumulate(y), color="#0033FF", lw=2, label="Best to Trial")
ax.set_xlabel("Trial Number")
ax.set_ylabel(f"{metric_name} (μm)")
ax.set_title("Laser Cutting: Edge Roughness Minimization Progress")
ax.grid(alpha=0.3)
ax.legend()

# Optional scatter in parameter space colored by roughness
fig2, ax2 = plt.subplots(figsize=(6, 4.5), dpi=150)
sc = ax2.scatter(
    df["laser_power_watts"].values,
    df["cutting_speed_mm_per_s"].values,
    c=y,
    cmap="viridis_r",
    ec="k",
)
ax2.set_xlabel("Laser Power (W)")
ax2.set_ylabel("Cutting Speed (mm/s)")
ax2.set_title("Tried Conditions Colored by Edge Roughness (μm)")
cbar = plt.colorbar(sc, ax=ax2)
cbar.set_label("Edge Roughness (μm)")
ax2.grid(alpha=0.3)

plt.tight_layout()
plt.show()