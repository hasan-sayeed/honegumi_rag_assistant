# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


ionic_conductivity_metric = "ionic_conductivity"


def evaluate_electrolyte_conductivity(
    LiPF6_conc: float,
    LiBF4_conc: float,
    LiClO4_conc: float,
    LiTFSI_conc: float,
) -> dict:
    """
    Simulate room-temperature ionic conductivity (mS/cm) for a mixed-salt Li-ion electrolyte.
    This stub is designed to be physically plausible and smooth for BO, but should be replaced
    with actual experimental measurement logic in production.

    Args:
        LiPF6_conc: molarity of LiPF6 in M (0.0 - 1.5)
        LiBF4_conc: molarity of LiBF4 in M (0.0 - 0.5)
        LiClO4_conc: molarity of LiClO4 in M (0.0 - 0.3)
        LiTFSI_conc: molarity of LiTFSI in M (0.0 - 0.8)

    Returns:
        dict with key "ionic_conductivity" (mS/cm)
    """
    # Total salt concentration
    total_M = LiPF6_conc + LiBF4_conc + LiClO4_conc + LiTFSI_conc
    if total_M <= 0:
        return {ionic_conductivity_metric: 0.0}

    # Composition fractions
    w_pf6 = LiPF6_conc / total_M
    w_bf4 = LiBF4_conc / total_M
    w_clo4 = LiClO4_conc / total_M
    w_tfsi = LiTFSI_conc / total_M

    # Relative mobility factors (dimensionless, baseline ~1.0)
    mu_pf6 = 1.00
    mu_bf4 = 0.85
    mu_clo4 = 1.15
    mu_tfsi = 1.05

    mu_base = (
        w_pf6 * mu_pf6
        + w_bf4 * mu_bf4
        + w_clo4 * mu_clo4
        + w_tfsi * mu_tfsi
    )

    # Simple pairwise synergy terms (dimensionless, positive => better conductivity)
    # These capture mixed-anion benefits in reducing ion pairing / improving transport.
    s_pf6_clo4 = 0.10
    s_pf6_tfsi = 0.08
    s_clo4_tfsi = 0.06
    s_bf4_clo4 = 0.05
    s_bf4_tfsi = 0.02
    s_pf6_bf4 = 0.01

    synergy = (
        s_pf6_clo4 * np.sqrt(w_pf6 * w_clo4)
        + s_pf6_tfsi * np.sqrt(w_pf6 * w_tfsi)
        + s_clo4_tfsi * np.sqrt(w_clo4 * w_tfsi)
        + s_bf4_clo4 * np.sqrt(w_bf4 * w_clo4)
        + s_bf4_tfsi * np.sqrt(w_bf4 * w_tfsi)
        + s_pf6_bf4 * np.sqrt(w_pf6 * w_bf4)
    )

    # Concentration response: rises then falls due to viscosity/ion pairing
    s_opt = 1.2  # M, typical peak around ~1.0-1.2 M in many carbonate systems
    conc_shape = (total_M / s_opt) * np.exp(1 - total_M / s_opt)  # in [0, 1], peak at s_opt

    # Base scale for room-temperature liquid electrolytes
    base_scale_ms_per_cm = 11.5  # mS/cm peak scale without strong synergy

    conductivity_no_noise = base_scale_ms_per_cm * conc_shape * (
        0.9 + 0.25 * (mu_base - 1.0) + 0.35 * synergy
    )

    # Mild stability/viscosity penalty for very high LiClO4 fractions at high total concentration
    # (kept small to avoid overwhelming other effects)
    if total_M > 1.4:
        penalty = 0.15 * w_clo4 * (total_M - 1.4)
    else:
        penalty = 0.0

    conductivity_no_noise = max(0.0, conductivity_no_noise - penalty)

    # Add experimental noise to emulate measurement variability (Noise model: True)
    noise_sd = 0.1 + 0.05 * total_M  # mS/cm
    observed_conductivity = float(max(0.0, np.random.normal(conductivity_no_noise, noise_sd)))

    return {ionic_conductivity_metric: observed_conductivity}


if __name__ == "__main__":
    np.random.seed(2025)

    ax_client = AxClient(random_seed=2025)

    ax_client.create_experiment(
        name="battery_electrolyte_salt_mix_optimization",
        parameters=[
            {"name": "LiPF6_conc", "type": "range", "bounds": [0.0, 1.5]},
            {"name": "LiBF4_conc", "type": "range", "bounds": [0.0, 0.5]},
            {"name": "LiClO4_conc", "type": "range", "bounds": [0.0, 0.3]},
            {"name": "LiTFSI_conc", "type": "range", "bounds": [0.0, 0.8]},
        ],
        objectives={
            ionic_conductivity_metric: ObjectiveProperties(minimize=False)
        },
        parameter_constraints=[
            "LiPF6_conc + LiBF4_conc + LiClO4_conc + LiTFSI_conc <= 2.0",
        ],
    )

    n_experiments = 35
    for _ in range(n_experiments):
        parameterization, trial_index = ax_client.get_next_trial()

        # Extract concentrations in M
        LiPF6_conc = float(parameterization["LiPF6_conc"])
        LiBF4_conc = float(parameterization["LiBF4_conc"])
        LiClO4_conc = float(parameterization["LiClO4_conc"])
        LiTFSI_conc = float(parameterization["LiTFSI_conc"])

        measurement = evaluate_electrolyte_conductivity(
            LiPF6_conc=LiPF6_conc,
            LiBF4_conc=LiBF4_conc,
            LiClO4_conc=LiClO4_conc,
            LiTFSI_conc=LiTFSI_conc,
        )

        # Report result back to Ax (single objective provided as dict)
        ax_client.complete_trial(trial_index=trial_index, raw_data=measurement)

    best_parameters, best_values = ax_client.get_best_parameters()
    print("Best electrolyte composition (M):")
    for k, v in best_parameters.items():
        print(f"  {k}: {v:.4f}")
    print("\nBest observed ionic conductivity (mS/cm):")
    for obj_name, val in best_values.items():
        print(f"  {obj_name}: {val['objective']:.4f}")

    # Plot results
    objectives = ax_client.objective_names
    df = ax_client.get_trials_data_frame()

    # If DataFrame contains multiple rows per trial due to multiple metrics, aggregate by trial
    if "trial_index" in df.columns and ionic_conductivity_metric in df.columns:
        df_sorted = df.sort_values("trial_index")
        y = df_sorted[ionic_conductivity_metric].values
        x = df_sorted["trial_index"].values
    else:
        # Fallback to index-based plotting
        df_sorted = df.copy()
        y = df_sorted[objectives[0]].values
        x = np.arange(len(y))

    fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
    ax.scatter(x, y, ec="k", fc="none", label="Observed")
    ax.plot(x, np.maximum.accumulate(y), color="#0033FF", lw=2, label="Best to Trial")
    ax.set_xlabel("Trial Number")
    ax.set_ylabel(f"{ionic_conductivity_metric} (mS/cm)")
    ax.set_title("Bayesian Optimization of Ionic Conductivity")
    ax.legend()
    plt.tight_layout()
    plt.show()