# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


# Problem: Spray coating uniformity optimization
# Objective: Minimize thickness variation (%)
# Parameters:
#   - spray_distance_cm: 10 to 30 cm
#   - air_pressure_bar: 1 to 4 bar
# Budget: 25 experiments
# Noise model: True (we report SEM with each observation)

METRIC_NAME = "thickness_variation_percent"


def evaluate_spray_coating(spray_distance_cm: float, air_pressure_bar: float) -> dict:
    """
    Simulated evaluation of coating thickness variation (%).

    This function provides a realistic stub in absence of direct lab instrumentation code.
    It models that thickness variation is minimized near moderate settings and increases
    at extremes or with mismatch between distance and pressure. Random measurement noise
    is included and reported as SEM.

    Replace this with actual measurement code in production, e.g.:
      - Run spray pass with given parameters
      - Measure film thickness across target, compute % variation = 100 * std/mean
      - Return measured mean and an estimate of SEM across repeated measurements
    """
    # Set a reproducible random generator; remove seed for true randomness in production
    rng = np.random.default_rng()

    # Nominal "optimal" operating region (domain knowledge guess)
    optimal_distance_cm = 20.0
    optimal_pressure_bar = 2.5

    # Normalize parameters relative to "optimal" settings
    distance_scaled = (spray_distance_cm - optimal_distance_cm) / 6.0
    pressure_scaled = (air_pressure_bar - optimal_pressure_bar) / 0.6

    # Base model: quadratic penalties + mild interaction
    base_variation = (
        4.0
        + 3.0 * distance_scaled**2
        + 3.0 * pressure_scaled**2
        + 2.0 * distance_scaled * pressure_scaled
    )

    # Heteroscedastic noise: grows as we move away from the optimum
    penalty = max(0.0, distance_scaled**2 + pressure_scaled**2)
    noise_sigma = 0.25 + 0.15 * penalty

    observed_variation = float(base_variation + rng.normal(0.0, noise_sigma))
    observed_variation = max(0.1, observed_variation)  # Physical floor; cannot be negative

    # Report an SEM estimate (e.g., from 3 quick repeats or instrument's precision model)
    sem_estimate = max(0.05, 0.2 * noise_sigma)

    return {METRIC_NAME: (observed_variation, sem_estimate)}


if __name__ == "__main__":
    np.random.seed(123)  # For reproducible Ax model initialization; remove for production

    ax_client = AxClient()

    ax_client.create_experiment(
        name="spray_coating_uniformity_optimization",
        parameters=[
            {"name": "spray_distance_cm", "type": "range", "bounds": [10.0, 30.0]},
            {"name": "air_pressure_bar", "type": "range", "bounds": [1.0, 4.0]},
        ],
        objectives={
            METRIC_NAME: ObjectiveProperties(minimize=True),
        },
    )

    total_trials = 25  # Budget

    for _ in range(total_trials):
        parameterization, trial_index = ax_client.get_next_trial()

        # Extract parameters
        spray_distance_cm = float(parameterization["spray_distance_cm"])
        air_pressure_bar = float(parameterization["air_pressure_bar"])

        # Run evaluation (replace with actual experiment + measurement)
        try:
            measured = evaluate_spray_coating(spray_distance_cm, air_pressure_bar)
        except Exception as e:
            # In case of failure, return a large penalty and a reasonable SEM
            measured = {METRIC_NAME: (100.0, 1.0)}

        ax_client.complete_trial(trial_index=trial_index, raw_data=measured)

    best_parameters, best_metrics = ax_client.get_best_parameters()

    # Print best settings and outcome
    print("Best Parameters:")
    for k, v in best_parameters.items():
        print(f"  {k}: {v}")
    print("Best Observed Metrics:")
    for metric_name, metric_dict in best_metrics.items():
        mean = metric_dict["mean"]
        sem = metric_dict.get("sem", None)
        if sem is None:
            print(f"  {metric_name}: {mean:.3f}")
        else:
            print(f"  {metric_name}: {mean:.3f} Â± {sem:.3f} (SEM)")

    # Plot results
    objectives = ax_client.objective_names
    df = ax_client.get_trials_data_frame()

    # Use the mean metric column
    y_values = df[objectives[0]].values
    x_values = np.arange(len(y_values))

    fig, ax = plt.subplots(figsize=(7, 4), dpi=150)
    ax.scatter(x_values, y_values, ec="k", fc="none", label="Observed")
    ax.plot(x_values, np.minimum.accumulate(y_values), color="#0033FF", lw=2, label="Best to Trial")
    ax.set_xlabel("Trial Number")
    ax.set_ylabel(f"{objectives[0]} (%)")
    ax.set_title("Spray Coating: Thickness Variation Over Trials")
    ax.grid(True, alpha=0.3)
    ax.legend()
    plt.tight_layout()
    plt.show()