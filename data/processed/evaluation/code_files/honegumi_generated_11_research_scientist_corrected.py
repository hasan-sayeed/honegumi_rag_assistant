# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


obj1_name = "branin"


def branin(x1, x2):
    y = float(
        (x2 - 5.1 / (4 * np.pi**2) * x1**2 + 5.0 / np.pi * x1 - 6.0) ** 2
        + 10 * (1 - 1.0 / (8 * np.pi)) * np.cos(x1)
        + 10
    )

    return y


# Define the training data


X_train = pd.DataFrame(
    [
        {"x1": -3.0, "x2": 5.0},
        {"x1": 0.0, "x2": 6.2},
        {"x1": 5.9, "x2": 2.0},
        {"x1": 1.5, "x2": 2.0},
        {"x1": 1.0, "x2": 9.0},
    ]
)

# Define y_train (normally the values would be supplied directly instead of calculating here)
y_train = [branin(row["x1"], row["x2"]) for _, row in X_train.iterrows()]

# See https://youtu.be/4tnaL9ts6CQ for simple human-in-the-loop BO instructions

# Define the number of training examples
n_train = len(X_train)


ax_client = AxClient()

ax_client.create_experiment(
    parameters=[
        {"name": "x1", "type": "range", "bounds": [-5.0, 10.0]},
        {"name": "x2", "type": "range", "bounds": [0.0, 10.0]},
    ],
    objectives={
        obj1_name: ObjectiveProperties(minimize=True),
    },
)

# Add existing data to the AxClient
for i in range(n_train):
    parameterization = X_train.iloc[i].to_dict()

    ax_client.attach_trial(parameterization)
    ax_client.complete_trial(trial_index=i, raw_data=y_train[i])


for i in range(19):

    parameterization, trial_index = ax_client.get_next_trial()

    # extract parameters
    x1 = parameterization["x1"]
    x2 = parameterization["x2"]

    results = branin(x1, x2)
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)

best_parameters, metrics = ax_client.get_best_parameters()


# Plot results
objectives = ax_client.objective_names
df = ax_client.get_trials_data_frame()

fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
ax.scatter(df.index, df[objectives], ec="k", fc="none", label="Observed")
ax.plot(
    df.index,
    np.minimum.accumulate(df[objectives]),
    color="#0033FF",
    lw=2,
    label="Best to Trial",
)
ax.set_xlabel("Trial Number")
ax.set_ylabel(objectives[0])

ax.legend()
plt.show()

# Generated for MAX phase discovery with Ax Platform
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


# Objective name
objective_name = "electrical_conductivity"  # S/m, to maximize


# Synthetic evaluation of electrical conductivity from featurization.
# In real use, replace this function to run DFT/experiment and return measured conductivity.
_rng = np.random.default_rng(42)


def simulate_electrical_conductivity(
    M_site_electronegativity: float,
    A_site_radius: float,
    X_site_radius: float,
    DFT_formation_energy: float,
) -> float:
    """
    Featurization-driven synthetic conductivity model (S/m).
    - Peaks near physically plausible optima and degrades away from them.
    - Increases modestly for more stable (more negative) formation energies.
    - Adds measurement noise to emulate experimental uncertainty.
    """
    # Peak locations (domain-informed guesses)
    mu_M_en = 1.6  # Pauling
    mu_A_r = 1.50  # Å
    mu_X_r = 0.70  # Å

    # Widths (how quickly performance decays away from optima)
    sig_M_en = 0.30
    sig_A_r = 0.25
    sig_X_r = 0.05

    # Gaussian peaks for each feature
    score_M = np.exp(-((M_site_electronegativity - mu_M_en) / sig_M_en) ** 2)
    score_A = np.exp(-((A_site_radius - mu_A_r) / sig_A_r) ** 2)
    score_X = np.exp(-((X_site_radius - mu_X_r) / sig_X_r) ** 2)

    # Stability factor from formation energy (more negative -> higher factor)
    stability_factor = 1.0 + 0.6 * np.tanh(-DFT_formation_energy)  # ~[0.4, 1.6] over range

    # Baseline metallic conductivity scale and feature interaction
    peak_scale = 1.2e7  # S/m
    feature_interaction = score_M * (0.6 * score_A + 0.4 * score_X)

    mean_conductivity = 1.0e6 + peak_scale * feature_interaction * stability_factor

    # Add multiplicative noise (~7% RSD)
    noise_scale = 0.07
    noise_factor = _rng.lognormal(mean=0.0, sigma=noise_scale)
    conductivity = float(mean_conductivity * noise_factor)

    # Safety: clip to positive range
    return max(conductivity, 1.0e4)


def evaluate_trial(parameterization: dict) -> float:
    """Wrapper to evaluate a parameterization and return conductivity (S/m)."""
    return simulate_electrical_conductivity(
        M_site_electronegativity=parameterization["M_site_electronegativity"],
        A_site_radius=parameterization["A_site_radius"],
        X_site_radius=parameterization["X_site_radius"],
        DFT_formation_energy=parameterization["DFT_formation_energy"],
    )


# Define realistic parameter bounds for the search space
PARAM_BOUNDS = {
    "M_site_electronegativity": (1.0, 2.5),  # Pauling scale (typical transition metals)
    "A_site_radius": (1.2, 2.2),  # Å (typical A-layer elements, covalent/metallic radii range)
    "X_site_radius": (0.5, 0.8),  # Å (C ~0.70, N ~0.65)
    "DFT_formation_energy": (-3.0, 0.5),  # eV/atom (negative is favorable)
}


def generate_literature_dataset(n_points: int = 20, seed: int = 7) -> pd.DataFrame:
    """Generate initial 'literature' dataset across the search space."""
    rng = np.random.default_rng(seed)
    df = pd.DataFrame(
        {
            "M_site_electronegativity": rng.uniform(
                PARAM_BOUNDS["M_site_electronegativity"][0],
                PARAM_BOUNDS["M_site_electronegativity"][1],
                size=n_points,
            ),
            "A_site_radius": rng.uniform(
                PARAM_BOUNDS["A_site_radius"][0],
                PARAM_BOUNDS["A_site_radius"][1],
                size=n_points,
            ),
            "X_site_radius": rng.uniform(
                PARAM_BOUNDS["X_site_radius"][0],
                PARAM_BOUNDS["X_site_radius"][1],
                size=n_points,
            ),
            "DFT_formation_energy": rng.uniform(
                PARAM_BOUNDS["DFT_formation_energy"][0],
                PARAM_BOUNDS["DFT_formation_energy"][1],
                size=n_points,
            ),
        }
    )
    return df


# Initialize with 20 historical compounds (transfer learning dataset)
X_literature = generate_literature_dataset(n_points=20, seed=2024)
y_literature = [evaluate_trial(row.to_dict()) for _, row in X_literature.iterrows()]

# Budget
total_budget = 30  # total experiments (including literature points)
n_init = len(X_literature)
n_bo = max(total_budget - n_init, 0)

# Set up Ax optimization
ax_client = AxClient()

ax_client.create_experiment(
    name="max_phase_conductivity_bo",
    parameters=[
        {
            "name": "M_site_electronegativity",
            "type": "range",
            "bounds": [PARAM_BOUNDS["M_site_electronegativity"][0], PARAM_BOUNDS["M_site_electronegativity"][1]],
        },
        {
            "name": "A_site_radius",
            "type": "range",
            "bounds": [PARAM_BOUNDS["A_site_radius"][0], PARAM_BOUNDS["A_site_radius"][1]],
        },
        {
            "name": "X_site_radius",
            "type": "range",
            "bounds": [PARAM_BOUNDS["X_site_radius"][0], PARAM_BOUNDS["X_site_radius"][1]],
        },
        {
            "name": "DFT_formation_energy",
            "type": "range",
            "bounds": [PARAM_BOUNDS["DFT_formation_energy"][0], PARAM_BOUNDS["DFT_formation_energy"][1]],
        },
    ],
    objectives={objective_name: ObjectiveProperties(minimize=False)},
)

# Attach existing literature data
for i in range(n_init):
    param_dict = X_literature.iloc[i].to_dict()
    ax_client.attach_trial(param_dict)
    # Provide noisy observation; Ax will infer noise model if SEM is omitted.
    ax_client.complete_trial(trial_index=i, raw_data=y_literature[i])

# Run Bayesian optimization for the remaining budget
for _ in range(n_bo):
    parameters, trial_index = ax_client.get_next_trial()
    # Evaluate conductivity for suggested features
    conductivity = evaluate_trial(parameters)
    ax_client.complete_trial(trial_index=trial_index, raw_data=conductivity)

# Retrieve best parameters and predicted metrics
best_parameters, best_metrics = ax_client.get_best_parameters()

# Plot optimization trace (maximization)
metric_name = ax_client.objective_names[0]
df = ax_client.get_trials_data_frame()

fig, ax = plt.subplots(figsize=(7, 4), dpi=150)
ax.scatter(df.index, df[metric_name], ec="k", fc="none", label="Observed")
ax.plot(
    df.index,
    np.maximum.accumulate(df[metric_name]),
    color="#0033FF",
    lw=2,
    label="Best to Trial",
)
ax.set_xlabel("Trial Number")
ax.set_ylabel(f"{metric_name} (S/m)")
ax.set_title("MAX Phase Conductivity Optimization (Featurization-based BO)")
ax.legend()
plt.tight_layout()
plt.show()

print("Best parameters (features):")
for k, v in best_parameters.items():
    print(f"  {k}: {v:.4f}")
print("\nModel-predicted objective at best parameters:")
means, covs = best_metrics
print({metric_name: means[metric_name]})