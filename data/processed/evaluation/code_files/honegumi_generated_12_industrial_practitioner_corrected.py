# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


obj1_name = "branin"


def branin(x1, x2, c1):
    y = float(
        (x2 - 5.1 / (4 * np.pi**2) * x1**2 + 5.0 / np.pi * x1 - 6.0) ** 2
        + 10 * (1 - 1.0 / (8 * np.pi)) * np.cos(x1)
        + 10
    )

    # add a made-up penalty based on category
    penalty_lookup = {"A": 1.0, "B": 0.0, "C": 2.0}
    y += penalty_lookup[c1]

    return y


ax_client = AxClient()

ax_client.create_experiment(
    parameters=[
        {"name": "x1", "type": "range", "bounds": [-5.0, 10.0]},
        {"name": "x2", "type": "range", "bounds": [0.0, 10.0]},
        {
            "name": "c1",
            "type": "choice",
            "is_ordered": False,
            "values": ["A", "B", "C"],
        },
    ],
    objectives={
        obj1_name: ObjectiveProperties(minimize=True),
    },
)


for i in range(21):

    parameterization, trial_index = ax_client.get_next_trial()

    # extract parameters
    x1 = parameterization["x1"]
    x2 = parameterization["x2"]

    c1 = parameterization["c1"]

    results = branin(x1, x2, c1)
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)

best_parameters, metrics = ax_client.get_best_parameters()


# Plot results
objectives = ax_client.objective_names
df = ax_client.get_trials_data_frame()

fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
ax.scatter(df.index, df[objectives], ec="k", fc="none", label="Observed")
ax.plot(
    df.index,
    np.minimum.accumulate(df[objectives]),
    color="#0033FF",
    lw=2,
    label="Best to Trial",
)
ax.set_xlabel("Trial Number")
ax.set_ylabel(objectives[0])

ax.legend()
plt.show()

# Generated for universal binder optimization across alumina, zirconia, and SiC ceramics
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from typing import Tuple
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


objective_name = "green_strength"  # MPa


def simulate_green_strength(
    binder_wt_pct: float,
    plasticizer_wt_pct: float,
    dispersant_wt_pct: float,
    ceramic: str,
    rng: np.random.Generator,
) -> Tuple[float, float]:
    """
    Simulate green strength (MPa) for a ceramic compact given organic additions.
    NOTE: Replace this simulator with actual experimental measurement collection.

    Parameters
    - binder_wt_pct: 1.0 - 10.0 wt%
    - plasticizer_wt_pct: 0.0 - 3.0 wt%
    - dispersant_wt_pct: 0.1 - 1.0 wt%
    - ceramic: one of {"alumina", "zirconia", "SiC"}
    - rng: numpy random generator for reproducibility

    Returns
    - (mean_strength_mpa, sem_strength_mpa)
    """
    # Baseline strengths by ceramic (MPa), reflecting powder characteristics.
    base_strength = {"alumina": 4.5, "zirconia": 5.2, "SiC": 3.8}[ceramic]

    # Ceramic-specific optimal loadings (wt%) and curvatures for smooth peaks.
    binder_opt = {"alumina": 6.0, "zirconia": 5.5, "SiC": 6.5}[ceramic]
    plasticizer_opt = {"alumina": 1.1, "zirconia": 1.3, "SiC": 1.0}[ceramic]
    dispersant_opt = {"alumina": 0.35, "zirconia": 0.45, "SiC": 0.30}[ceramic]

    # Peak gains (MPa) achievable from each additive when tuned well.
    binder_peak_gain = {"alumina": 3.0, "zirconia": 3.4, "SiC": 2.8}[ceramic]
    plasticizer_peak_gain = {"alumina": 1.2, "zirconia": 1.4, "SiC": 1.1}[ceramic]
    dispersant_peak_gain = {"alumina": 0.8, "zirconia": 0.9, "SiC": 0.7}[ceramic]

    # Curvature parameters (larger -> narrower optimum).
    k_binder = {"alumina": 0.25, "zirconia": 0.28, "SiC": 0.22}[ceramic]
    k_plasticizer = {"alumina": 1.8, "zirconia": 1.6, "SiC": 1.7}[ceramic]
    k_dispersant = {"alumina": 3.5, "zirconia": 3.2, "SiC": 3.8}[ceramic]

    # Smooth peaked contributions (quadratic wells peaking at the optimum).
    binder_contrib = -k_binder * (binder_wt_pct - binder_opt) ** 2 + binder_peak_gain
    plasticizer_contrib = -k_plasticizer * (plasticizer_wt_pct - plasticizer_opt) ** 2 + plasticizer_peak_gain
    dispersant_contrib = -k_dispersant * (dispersant_wt_pct - dispersant_opt) ** 2 + dispersant_peak_gain

    # Mild positive interaction between binder and dispersant near their optima.
    binder_norm = max(0.0, 1.0 - abs(binder_wt_pct - binder_opt) / 4.0)
    dispersant_norm = max(0.0, 1.0 - abs(dispersant_wt_pct - dispersant_opt) / 0.6)
    interaction_gain = {"alumina": 0.35, "zirconia": 0.40, "SiC": 0.30}[ceramic]
    interaction_contrib = interaction_gain * binder_norm * dispersant_norm

    # Penalty for excessive total organics (green body defects).
    total_organics = binder_wt_pct + plasticizer_wt_pct + dispersant_wt_pct
    excess = max(0.0, total_organics - 10.0)
    organics_penalty = 0.18 * (excess**2)  # quadratic penalty

    # Aggregate deterministic strength.
    deterministic_strength = base_strength + binder_contrib + plasticizer_contrib + dispersant_contrib + interaction_contrib - organics_penalty

    # Clip to a physically reasonable lower bound.
    deterministic_strength = max(0.1, deterministic_strength)

    # Add measurement/process noise.
    noise_sd = {"alumina": 0.45, "zirconia": 0.40, "SiC": 0.50}[ceramic]
    measured_strength = deterministic_strength + rng.normal(0.0, noise_sd)

    # Assume SEM based on measurement repeatability (could be measured empirically).
    sem = {"alumina": 0.20, "zirconia": 0.18, "SiC": 0.22}[ceramic]

    return float(measured_strength), float(sem)


# Initialize Ax client
ax_client = AxClient()

# Create the experiment with the appropriate search space and objective.
ax_client.create_experiment(
    name="ceramic_universal_binder_green_strength",
    parameters=[
        {
            "name": "binder_wt_pct",
            "type": "range",
            "bounds": [1.0, 10.0],
            "value_type": "float",
        },
        {
            "name": "plasticizer_wt_pct",
            "type": "range",
            "bounds": [0.0, 3.0],
            "value_type": "float",
        },
        {
            "name": "dispersant_wt_pct",
            "type": "range",
            "bounds": [0.1, 1.0],
            "value_type": "float",
        },
        {
            "name": "ceramic",
            "type": "choice",
            "is_ordered": False,
            "values": ["alumina", "zirconia", "SiC"],
        },
    ],
    objectives={
        objective_name: ObjectiveProperties(minimize=False),
    },
)

# Optimization loop
rng = np.random.default_rng(12345)
total_trials = 120  # 40 per ceramic target budget; this loop runs total 120 suggestions.

for i in range(total_trials):
    parameterization, trial_index = ax_client.get_next_trial()

    # Extract parameters
    binder_wt_pct = float(parameterization["binder_wt_pct"])
    plasticizer_wt_pct = float(parameterization["plasticizer_wt_pct"])
    dispersant_wt_pct = float(parameterization["dispersant_wt_pct"])
    ceramic = str(parameterization["ceramic"])

    # Evaluate (replace this simulator with actual lab measurements)
    mean_strength, sem_strength = simulate_green_strength(
        binder_wt_pct=binder_wt_pct,
        plasticizer_wt_pct=plasticizer_wt_pct,
        dispersant_wt_pct=dispersant_wt_pct,
        ceramic=ceramic,
        rng=rng,
    )

    # Report results to Ax; include SEM to inform the noise model
    ax_client.complete_trial(
        trial_index=trial_index,
        raw_data={objective_name: (mean_strength, sem_strength)},
    )

# Retrieve best parameters
best_parameters, best_metrics = ax_client.get_best_parameters()

# Plot optimization trace (Observed vs. Best-to-date)
df = ax_client.get_trials_data_frame().sort_values(by="trial_index").reset_index(drop=True)

fig, ax = plt.subplots(figsize=(7, 4.5), dpi=150)
x = df["trial_index"].values
y = df[objective_name].values

ax.scatter(x, y, ec="k", fc="none", label="Observed")
ax.plot(x, np.maximum.accumulate(y), color="#0033FF", lw=2, label="Best to Trial")

ax.set_xlabel("Trial Number")
ax.set_ylabel(f"{objective_name} (MPa)")
ax.set_title("Green Strength Optimization Trace")
ax.legend()
plt.tight_layout()
plt.show()