# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


# Problem: Optimize an extraction process to maximize extraction efficiency (%)
# Parameters:
#   - temperature_celsius: 20 to 60 °C (continuous)
#   - solvent_to_sample_ratio: 1.0 to 5.0 (solvent:sample, continuous)
# Objective:
#   - extraction_efficiency (%), to be maximized
# Budget: 26 trials
# Notes:
#   - This script includes a realistic simulator for the extraction efficiency.
#     Replace the simulator with actual experimental measurement logic when running real experiments.

objective_name = "extraction_efficiency"

_rng = np.random.default_rng(42)  # for reproducibility of simulated measurement noise


def evaluate_extraction_process(temperature_celsius: float, solvent_to_sample_ratio: float) -> dict:
    """
    Simulate the extraction efficiency (%) for given process settings.

    Replace this model with actual measurement logic in production use:
      - Run the extraction at the specified temperature and solvent ratio
      - Measure extraction efficiency (%) using the lab protocol
      - Return {"extraction_efficiency": (measured_value, measurement_sem)}

    Parameters
    ----------
    temperature_celsius : float
        Extraction temperature in degrees Celsius.
    solvent_to_sample_ratio : float
        Solvent-to-sample ratio (v/w or as defined by the protocol), e.g., 3.0 means 3:1.

    Returns
    -------
    dict
        {"extraction_efficiency": (mean_value_percent, standard_error_percent)}
    """
    # Physically plausible response surface with a single broad optimum
    T = float(temperature_celsius)
    R = float(solvent_to_sample_ratio)

    # Hypothetical optimum and spread (domain-specific surrogate)
    T_opt = 48.0
    R_opt = 3.2
    sigma_T = 7.0
    sigma_R = 0.8

    # Elliptical peak with mild interaction term
    zT = (T - T_opt) / sigma_T
    zR = (R - R_opt) / sigma_R
    interaction = -0.25 * zT * zR
    gaussian_peak = np.exp(-0.5 * (zT**2 + zR**2 + interaction))

    # Baseline and amplitude to keep values in a realistic [0, 100] range
    baseline = 35.0
    amplitude = 60.0
    modeled_efficiency = baseline + amplitude * gaussian_peak

    # Light penalties near extreme bounds to nudge away from edges
    edge_penalty = 2.0 * np.exp(-((T - 20.0) / 3.0) ** 2) + 2.0 * np.exp(-((60.0 - T) / 3.0) ** 2)
    modeled_efficiency = modeled_efficiency - edge_penalty

    # Add measurement noise to simulate experimental variability
    noise_sd = 1.5  # percent points
    measured_efficiency = modeled_efficiency + _rng.normal(0.0, noise_sd)

    # Clip to [0, 100] %
    measured_efficiency = float(np.clip(measured_efficiency, 0.0, 100.0))

    # Return mean and an estimate of the standard error of the measurement
    # If you have replicate measurements, replace noise_sd with SEM from replicates.
    return {objective_name: (measured_efficiency, noise_sd)}


def main():
    ax_client = AxClient()

    ax_client.create_experiment(
        name="extraction_process_optimization",
        parameters=[
            {
                "name": "temperature_celsius",
                "type": "range",
                "bounds": [20.0, 60.0],
                "value_type": "float",
                "description": "Extraction temperature in degrees Celsius",
            },
            {
                "name": "solvent_to_sample_ratio",
                "type": "range",
                "bounds": [1.0, 5.0],
                "value_type": "float",
                "description": "Solvent:sample ratio (e.g., 3.0 means 3:1)",
            },
        ],
        objectives={
            objective_name: ObjectiveProperties(minimize=False),
        },
        tracking_metrics=None,
        choose_generation_strategy=True,
        is_test=False,
    )

    # Run optimization for the specified budget
    n_trials = 26
    for _ in range(n_trials):
        parameterization, trial_index = ax_client.get_next_trial()

        # Extract parameters
        temperature_celsius = float(parameterization["temperature_celsius"])
        solvent_to_sample_ratio = float(parameterization["solvent_to_sample_ratio"])

        # Evaluate the experiment (replace with real measurement in production)
        results = evaluate_extraction_process(temperature_celsius, solvent_to_sample_ratio)

        # Report result back to Ax
        ax_client.complete_trial(trial_index=trial_index, raw_data=results)

    best_parameters, best_metrics = ax_client.get_best_parameters()
    best_efficiency = best_metrics[objective_name]["mean"]
    best_sem = best_metrics[objective_name]["sem"]

    print("Best settings found:")
    print(f"  temperature_celsius: {best_parameters['temperature_celsius']:.3f} °C")
    print(f"  solvent_to_sample_ratio: {best_parameters['solvent_to_sample_ratio']:.3f} (solvent:sample)")
    print(f"Best observed extraction efficiency: {best_efficiency:.3f}% ± {best_sem:.3f}% (SEM)")

    # Plot results
    objectives = ax_client.objective_names
    df = ax_client.get_trials_data_frame()

    # Ensure the objective column exists
    if objective_name not in df.columns:
        raise RuntimeError(f"Objective column '{objective_name}' not found in trials data frame.")

    fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
    ax.scatter(df.index, df[objective_name], ec="k", fc="none", label="Observed")
    ax.plot(
        df.index,
        np.maximum.accumulate(df[objective_name].values),
        color="#0033FF",
        lw=2,
        label="Best to Trial",
    )
    ax.set_xlabel("Trial Number")
    ax.set_ylabel(f"{objective_name} (%)")
    ax.set_title("Extraction Efficiency Optimization Progress")
    ax.legend()
    plt.tight_layout()
    plt.show()


if __name__ == "__main__":
    main()