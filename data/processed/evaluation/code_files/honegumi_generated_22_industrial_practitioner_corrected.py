# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


obj1_name = "branin"


def branin(x1, x2):
    y = float(
        (x2 - 5.1 / (4 * np.pi**2) * x1**2 + 5.0 / np.pi * x1 - 6.0) ** 2
        + 10 * (1 - 1.0 / (8 * np.pi)) * np.cos(x1)
        + 10
    )

    return y


ax_client = AxClient()

ax_client.create_experiment(
    parameters=[
        {"name": "x1", "type": "range", "bounds": [-5.0, 10.0]},
        {"name": "x2", "type": "range", "bounds": [0.0, 10.0]},
    ],
    objectives={
        obj1_name: ObjectiveProperties(minimize=True),
    },
)


for i in range(19):

    parameterization, trial_index = ax_client.get_next_trial()

    # extract parameters
    x1 = parameterization["x1"]
    x2 = parameterization["x2"]

    results = branin(x1, x2)
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)

best_parameters, metrics = ax_client.get_best_parameters()


# Plot results
objectives = ax_client.objective_names
df = ax_client.get_trials_data_frame()

fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
ax.scatter(df.index, df[objectives], ec="k", fc="none", label="Observed")
ax.plot(
    df.index,
    np.minimum.accumulate(df[objectives]),
    color="#0033FF",
    lw=2,
    label="Best to Trial",
)
ax.set_xlabel("Trial Number")
ax.set_ylabel(objectives[0])

ax.legend()
plt.show()

# Generated from Honegumi skeleton and adapted for production coating optimization
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


# Problem: Optimize spray-coating process to minimize thickness variation (%)
# Parameters:
#   - spray_distance_cm: 10 - 30 cm
#   - spray_pressure_bar: 1 - 4 bar
# Objective:
#   - thickness_variation_percent: minimize (lower is better)
# Budget: 25 trials
# Noise model: Observations are noisy (simulated below with Gaussian noise)

rng = np.random.default_rng(42)
objective_metric_name = "thickness_variation_percent"


def measure_thickness_variation_percent(spray_distance_cm: float, spray_pressure_bar: float) -> float:
    """
    Simulated measurement of coating thickness variation (%).

    This function approximates how thickness variation depends on spray distance and pressure.
    It encodes a reasonable physical shape (smooth optimum, interaction, diminishing returns)
    and includes measurement/process noise to reflect real lab/production variability.

    Replace this with actual experimental measurement integration if available:
    - Command spray equipment to run at the specified settings
    - Measure thickness at multiple points
    - Compute percent variation (e.g., 100 * std / mean)
    - Return the scalar percentage
    """
    # Idealized operating point (domain-informed guess)
    ideal_distance_cm = 19.5
    ideal_pressure_bar = 2.3

    # Quadratic penalties around the ideal operating point
    dist_dev = spray_distance_cm - ideal_distance_cm
    pres_dev = spray_pressure_bar - ideal_pressure_bar

    # Coefficients tuned to produce realistic variation magnitudes (1–5%)
    coeff_dist = 0.012  # % per cm^2
    coeff_pres = 0.35   # % per bar^2
    coeff_inter = 0.02  # % per (cm*bar)

    # Additional mild penalties to capture edge effects
    edge_distance_term = 10.0 / spray_distance_cm
    edge_pressure_term = 0.1 / max(1e-6, spray_pressure_bar)

    base_floor = 1.0  # irreducible baseline (%)

    deterministic_variation = (
        base_floor
        + coeff_dist * (dist_dev ** 2)
        + coeff_pres * (pres_dev ** 2)
        + coeff_inter * (dist_dev * pres_dev)
        + edge_distance_term
        + edge_pressure_term
    )

    # Additive Gaussian noise to simulate measurement/process variability
    noise_sigma = 0.15  # percentage points
    noisy_variation = deterministic_variation + rng.normal(0.0, noise_sigma)

    # Ensure non-negative and reasonable lower bound
    return float(max(0.5, noisy_variation))


ax_client = AxClient()
ax_client.create_experiment(
    name="coating_uniformity_optimization",
    parameters=[
        {"name": "spray_distance_cm", "type": "range", "bounds": [10.0, 30.0]},
        {"name": "spray_pressure_bar", "type": "range", "bounds": [1.0, 4.0]},
    ],
    objectives={
        objective_metric_name: ObjectiveProperties(minimize=True),
    },
)

# Run optimization for the specified budget
num_trials = 25
for _ in range(num_trials):
    parameterization, trial_index = ax_client.get_next_trial()

    # Extract parameters
    spray_distance_cm = float(parameterization["spray_distance_cm"])
    spray_pressure_bar = float(parameterization["spray_pressure_bar"])

    # Evaluate the process (replace with real experiment if available)
    result_value = measure_thickness_variation_percent(spray_distance_cm, spray_pressure_bar)

    # Report result back to Ax
    ax_client.complete_trial(trial_index=trial_index, raw_data=result_value)

# Retrieve best found settings
best_parameters, best_metrics = ax_client.get_best_parameters()
best_mean = best_metrics[objective_metric_name]["mean"]
best_sem = best_metrics[objective_metric_name]["sem"]

print("Best parameters found:")
print(f"  spray_distance_cm = {best_parameters['spray_distance_cm']:.3f} cm")
print(f"  spray_pressure_bar = {best_parameters['spray_pressure_bar']:.3f} bar")
print(f"Estimated best thickness variation: {best_mean:.3f}% ± {best_sem:.3f}%")

# Plot results
df = ax_client.get_trials_data_frame()
obj_name = ax_client.objective_names[0]
y_series = df[obj_name].astype(float).reset_index(drop=True)
x_vals = np.arange(len(y_series))

fig, ax = plt.subplots(figsize=(7, 4), dpi=150)
ax.scatter(x_vals, y_series.values, ec="k", fc="none", label="Observed")
ax.plot(
    x_vals,
    np.minimum.accumulate(y_series.values),
    color="#0033FF",
    lw=2,
    label="Best so far",
)
ax.set_xlabel("Trial Number")
ax.set_ylabel("Thickness Variation (%)")
ax.set_title("Spray Coating Optimization")
ax.legend()
plt.tight_layout()
plt.show()