# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


from ax.modelbridge.factory import Models
from ax.modelbridge.generation_strategy import GenerationStep, GenerationStrategy


obj1_name = "branin"


def branin3(x1, x2, x3):
    y = float(
        (x2 - 5.1 / (4 * np.pi**2) * x1**2 + 5.0 / np.pi * x1 - 6.0) ** 2
        + 10 * (1 - 1.0 / (8 * np.pi)) * np.cos(x1)
        + 10
    )

    # Contrived way to incorporate x3 into the objective
    y = y * (1 + 0.1 * x1 * x2 * x3)

    return y


# Define total for compositional constraint, where x1 + x2 + x3 == total
total = 10.0


gs = GenerationStrategy(
    steps=[
        GenerationStep(
            model=Models.SOBOL,
            num_trials=6,  # how many sobol trials to perform (rule of thumb: 2 * number of params)
            min_trials_observed=3,
            max_parallelism=5,
            model_kwargs={"seed": 999},
        ),
        GenerationStep(
            model=Models.SAASBO,
            num_trials=-1,
            max_parallelism=3,
            model_kwargs={},
        ),
    ]
)

ax_client = AxClient(generation_strategy=gs)

ax_client.create_experiment(
    parameters=[
        {"name": "x1", "type": "range", "bounds": [0.0, total]},
        {"name": "x2", "type": "range", "bounds": [0.0, total]},
    ],
    objectives={
        obj1_name: ObjectiveProperties(minimize=True),
    },
    parameter_constraints=[
        f"x1 + x2 <= {total}",  # reparameterized compositional constraint, which is a type of sum constraint
        "x1 <= x2",  # example of an order constraint
    ],
)


batch_size = 2


for i in range(21):

    parameterizations, optimization_complete = ax_client.get_next_trials(batch_size)
    for trial_index, parameterization in list(parameterizations.items()):
        # extract parameters
        x1 = parameterization["x1"]
        x2 = parameterization["x2"]
        x3 = total - (x1 + x2)  # composition constraint: x1 + x2 + x3 == total

        results = branin3(x1, x2, x3)
        ax_client.complete_trial(trial_index=trial_index, raw_data=results)

best_parameters, metrics = ax_client.get_best_parameters()


# Plot results
objectives = ax_client.objective_names
df = ax_client.get_trials_data_frame()
df.index = df.index // batch_size

fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
ax.scatter(df.index, df[objectives], ec="k", fc="none", label="Observed")
ax.plot(
    df.index,
    np.minimum.accumulate(df[objectives]),
    color="#0033FF",
    lw=2,
    label="Best to Trial",
)
ax.set_xlabel("Trial Number")
ax.set_ylabel(objectives[0])

ax.legend()
plt.show()

# Generated for anti-corrosion coating optimization with Ax Platform
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

from ax.service.ax_client import AxClient, ObjectiveProperties
from ax.modelbridge.factory import Models
from ax.modelbridge.generation_strategy import GenerationStep, GenerationStrategy


np.random.seed(42)


def evaluate_coating_formulation(
    resin_fraction: float,
    inhibitor_fraction: float,
    insulator_fraction: float,
    stabilizer_fraction: float,
    coating_thickness_mm: float,
) -> dict:
    """
    Simulated evaluation of corrosion damage score for a coating formulation.

    This is a realistic stub that encodes qualitative domain knowledge:
    - More resin generally improves film integrity and lowers corrosion.
    - Corrosion inhibitor provides a saturating protection effect.
    - Insulator aids barrier properties but with diminishing returns.
    - Small amounts of stabilizer can help, excess may worsen performance.
    - Greater thickness improves barrier properties with diminishing returns; too thick may crack.

    Returns:
      dict: {"corrosion_damage_score": (mean_value, sem_value)}
    """
    # Safety: small numerical tolerance to keep fractions in [0, 1]
    resin_fraction = min(max(resin_fraction, 0.0), 1.0)
    inhibitor_fraction = min(max(inhibitor_fraction, 0.0), 1.0)
    insulator_fraction = min(max(insulator_fraction, 0.0), 1.0)
    stabilizer_fraction = min(max(stabilizer_fraction, 0.0), 0.1)
    coating_thickness_mm = float(coating_thickness_mm)

    # Base corrosion rate (arbitrary scale units; higher is worse)
    base_rate = 100.0

    # Protection effects (values between 0 and 1 reduce corrosion multiplicatively)
    # Saturating inhibitor benefit
    inhibitor_effect = 1.0 - np.exp(-8.0 * inhibitor_fraction)  # fast saturation ~0.2-0.3
    resin_effect = 0.55 * resin_fraction  # linear improvement from resin
    insulator_effect = 1.0 - np.exp(-4.0 * insulator_fraction)  # diminishing returns
    stabilizer_opt = 0.04  # around 4% good stabilization
    stabilizer_deviation = max(0.0, abs(stabilizer_fraction - stabilizer_opt) - 0.02)
    stabilizer_benefit = max(0.0, 0.15 - 3.0 * stabilizer_deviation)  # small benefit near optimum

    # Thickness effect: diminishing returns, then potential cracking penalty > ~6 mm
    thickness_barrier = 1.0 - np.exp(-0.55 * coating_thickness_mm)  # 0..~1
    thickness_penalty_factor = 1.0 + max(0.0, (coating_thickness_mm - 6.0)) * 0.08

    # Aggregate multiplicative reduction from protection mechanisms
    protection_factor = (
        1.0
        - (0.40 * resin_effect + 0.38 * inhibitor_effect + 0.25 * insulator_effect + 0.10 * stabilizer_benefit)
    )
    protection_factor = max(0.05, min(protection_factor, 0.98))

    # Barrier effect (thickness): reduce rate further
    barrier_factor = 1.0 - 0.70 * thickness_barrier
    barrier_factor = max(0.1, min(barrier_factor, 1.0))

    # If formulation is resin-lean relative to other solids, add brittleness/microvoid penalty
    # Constraint enforces resin >= inhibitor and resin >= insulator individually,
    # but resin could still be <= inhibitor + insulator; apply mild penalty in that case.
    if resin_fraction < (inhibitor_fraction + insulator_fraction):
        brittleness_penalty = 1.10 + 0.50 * (inhibitor_fraction + insulator_fraction - resin_fraction)
    else:
        brittleness_penalty = 1.0

    # Compute damage score (lower is better)
    damage_mean = base_rate * protection_factor * barrier_factor
    damage_mean *= thickness_penalty_factor
    damage_mean *= brittleness_penalty

    # Add random experimental noise and specify SEM to model measurement uncertainty
    measurement_noise_sd = 2.5  # standard deviation of measurement noise (units of damage score)
    observed_damage = np.maximum(0.0, np.random.normal(damage_mean, measurement_noise_sd))
    sem = 2.0  # standard error of mean (if batching replicates, use empirical SEM)

    return {"corrosion_damage_score": (observed_damage, sem)}


# Generation strategy: Sobol initialization then fully Bayesian SAASBO, with batch parallelism of 6
generation_strategy = GenerationStrategy(
    steps=[
        GenerationStep(
            model=Models.SOBOL,
            num_trials=12,               # two batches of 6 as initialization
            min_trials_observed=12,
            max_parallelism=6,
            model_kwargs={"seed": 2025},
        ),
        GenerationStep(
            model=Models.SAASBO,
            num_trials=-1,               # rest of budget
            max_parallelism=6,           # allow running up to 6 in parallel
            model_kwargs={},
        ),
    ]
)

ax_client = AxClient(generation_strategy=generation_strategy, random_seed=2025)

ax_client.create_experiment(
    name="anti_corrosion_coating_optimization",
    parameters=[
        {
            "name": "inhibitor_fraction",
            "type": "range",
            "bounds": [0.0, 1.0],
            "value_type": "float",
        },
        {
            "name": "insulator_fraction",
            "type": "range",
            "bounds": [0.0, 1.0],
            "value_type": "float",
        },
        {
            "name": "stabilizer_fraction",
            "type": "range",
            "bounds": [0.0, 0.1],
            "value_type": "float",
        },
        {
            "name": "coating_thickness",
            "type": "range",
            "bounds": [0.1, 10.0],
            "value_type": "float",
        },
    ],
    objectives={
        "corrosion_damage_score": ObjectiveProperties(minimize=True),
    },
    # Constraints enforce:
    # 1) Fractions sum to 1 by reparameterizing resin = 1 - (inhibitor + insulator + stabilizer)
    # 2) resin >= 0  -> inhibitor + insulator + stabilizer <= 1
    # 3) resin >= inhibitor -> 1 - 2*inhibitor - insulator - stabilizer >= 0
    #    which is: 2*inhibitor + insulator + stabilizer <= 1
    # 4) resin >= insulator -> 1 - inhibitor - 2*insulator - stabilizer >= 0
    #    which is: inhibitor + 2*insulator + stabilizer <= 1
    parameter_constraints=[
        "inhibitor_fraction + insulator_fraction + stabilizer_fraction <= 1.0",
        "2*inhibitor_fraction + insulator_fraction + stabilizer_fraction <= 1.0",
        "inhibitor_fraction + 2*insulator_fraction + stabilizer_fraction <= 1.0",
    ],
    overwrite_existing_experiment=True,
    is_test=False,
)

# Experimental setup
batch_size = 6
total_trials = 120
num_batches = total_trials // batch_size

for _ in range(num_batches):
    parameterizations, optimization_complete = ax_client.get_next_trials(batch_size)
    for trial_index, p in list(parameterizations.items()):
        inhibitor_fraction = float(p["inhibitor_fraction"])
        insulator_fraction = float(p["insulator_fraction"])
        stabilizer_fraction = float(p["stabilizer_fraction"])
        coating_thickness_mm = float(p["coating_thickness"])

        # Reparameterized resin to satisfy compositional equality
        resin_fraction = 1.0 - (inhibitor_fraction + insulator_fraction + stabilizer_fraction)

        results = evaluate_coating_formulation(
            resin_fraction=resin_fraction,
            inhibitor_fraction=inhibitor_fraction,
            insulator_fraction=insulator_fraction,
            stabilizer_fraction=stabilizer_fraction,
            coating_thickness_mm=coating_thickness_mm,
        )
        ax_client.complete_trial(trial_index=trial_index, raw_data=results)

best_parameters, best_metrics = ax_client.get_best_parameters()

# Compute and print best full formulation, including computed resin fraction
best_record = best_parameters
best_inhibitor = best_record["inhibitor_fraction"]
best_insulator = best_record["insulator_fraction"]
best_stabilizer = best_record["stabilizer_fraction"]
best_resin = 1.0 - (best_inhibitor + best_insulator + best_stabilizer)
best_thickness = best_record["coating_thickness"]

print("Best found formulation:")
print(f"  resin_fraction      = {best_resin:.4f}")
print(f"  inhibitor_fraction  = {best_inhibitor:.4f}")
print(f"  insulator_fraction  = {best_insulator:.4f}")
print(f"  stabilizer_fraction = {best_stabilizer:.4f}")
print(f"  coating_thickness   = {best_thickness:.4f} mm")
print("Best predicted metrics:")
for k, v in best_metrics.items():
    print(f"  {k}: {v}")

# Plot optimization trace by batch
df = ax_client.get_trials_data_frame()
objective_name = ax_client.objective_names[0]
df["_batch"] = df.index // batch_size

fig, ax = plt.subplots(figsize=(7, 4.5), dpi=140)
ax.scatter(df["_batch"], df[objective_name], ec="k", fc="none", label="Observed")
ax.plot(
    df["_batch"],
    np.minimum.accumulate(df[objective_name]),
    color="#0033FF",
    lw=2,
    label="Best to Trial",
)
ax.set_xlabel("Batch Number")
ax.set_ylabel("Corrosion Damage Score (lower is better)")
ax.set_title("Anti-corrosion coating optimization with SAASBO (Ax)")
ax.legend()
plt.tight_layout()
plt.show()