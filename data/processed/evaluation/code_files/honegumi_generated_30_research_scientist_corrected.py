# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib numpy pandas
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


# Domain-specific metric name (units: cc/m²/day)
oxygen_metric_name = "oxygen_permeability_cc_per_m2_day"

# Reproducible randomness for simulated measurement noise (remove/modify for real experiments)
_rng = np.random.default_rng(12345)


def measure_oxygen_permeability(film_thickness_um: float, coating_weight_g_per_m2: float) -> dict:
    """
    Simulated evaluation of oxygen permeability for a packaging barrier film.

    Inputs:
      - film_thickness_um: Film thickness in micrometers (μm), range [20, 80]
      - coating_weight_g_per_m2: Coating weight in grams per square meter (g/m²), range [2, 10]

    Output:
      - Dict mapping objective metric name to (mean, sem) tuple, where the mean is the measured
        oxygen permeability in cc/m²/day (lower is better), and sem is the standard error.

    Notes:
      - This is a realistic stub with diminishing returns from both thickness and coating.
      - Noise is added to emulate experimental variability.
      - Replace this function body with actual lab measurement logic for production use.
    """
    # Base polymer contribution: decreases with thickness, with diminishing returns
    # Example calibration: ~20 cc/m²/day at 20 μm, ~5 cc/m²/day at 80 μm (before coating)
    base_polymer_permeability = 18.0 * (20.0 / film_thickness_um) ** 0.9 + 0.4

    # Coating improves barrier with diminishing returns as coating_weight increases
    # Example: ~0.42x at 2 g/m², ~0.095x at 10 g/m²
    coating_reduction_factor = 1.0 / (1.0 + 0.55 * (coating_weight_g_per_m2 ** 1.2))

    # Combined permeability with a small residual term
    true_value = base_polymer_permeability * coating_reduction_factor + 0.12

    # Add heteroscedastic measurement noise
    noise_sd = 0.05 * true_value + 0.05  # 5% relative + 0.05 absolute
    measured_value = max(true_value + _rng.normal(0.0, noise_sd), 0.001)

    # Provide an SEM estimate (can be from replicate measurements in real experiments)
    sem_estimate = max(0.5 * noise_sd, 0.01)

    return {oxygen_metric_name: (float(measured_value), float(sem_estimate))}


# Initialize Ax client
ax_client = AxClient(random_seed=42)

# Create experiment for single-objective minimization
ax_client.create_experiment(
    name="packaging_barrier_optimization",
    parameters=[
        {
            "name": "film_thickness_um",
            "type": "range",
            "bounds": [20.0, 80.0],
            "value_type": "float",
        },
        {
            "name": "coating_weight_g_per_m2",
            "type": "range",
            "bounds": [2.0, 10.0],
            "value_type": "float",
        },
    ],
    objectives={
        oxygen_metric_name: ObjectiveProperties(minimize=True),
    },
    is_test=True,  # Set False in production
)

# Experiment budget
total_trials = 24

# Optimization loop (sequential, batch size = 1)
for _ in range(total_trials):
    parameterization, trial_index = ax_client.get_next_trial()

    # Extract domain parameters
    film_thickness_um = float(parameterization["film_thickness_um"])
    coating_weight_g_per_m2 = float(parameterization["coating_weight_g_per_m2"])

    # Evaluate experiment (replace with real measurement in production)
    results = measure_oxygen_permeability(
        film_thickness_um=film_thickness_um,
        coating_weight_g_per_m2=coating_weight_g_per_m2,
    )

    # Report results (mean, sem) to Ax
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)

# Retrieve best found parameters and corresponding metric
best_parameters, best_values = ax_client.get_best_parameters()
best_mean = best_values[oxygen_metric_name]["mean"]
best_sem = best_values[oxygen_metric_name]["sem"]

print("Best parameters found:")
for k, v in best_parameters.items():
    print(f"  {k}: {v:.4g}")
print(
    f"Estimated best {oxygen_metric_name}: {best_mean:.4g} cc/m²/day (SEM: {best_sem:.4g})"
)

# Plot results
objective_names = ax_client.objective_names  # list with single element
df = ax_client.get_trials_data_frame()

if len(objective_names) == 1 and objective_names[0] in df.columns:
    metric_col = objective_names[0]
    y = df[metric_col].astype(float)
    x = np.arange(len(y))
    cum_best = y.cummin()

    fig, ax = plt.subplots(figsize=(7, 4), dpi=150)
    ax.scatter(x, y, ec="k", fc="none", label="Observed")
    ax.plot(x, cum_best, color="#0033FF", lw=2, label="Best so far")
    ax.set_xlabel("Trial Number")
    ax.set_ylabel(f"{metric_col} (cc/m²/day)")
    ax.set_title("Oxygen Permeability Optimization Progress")
    ax.legend()
    plt.tight_layout()
    plt.show()
else:
    print("Could not plot results: metric not found in dataframe columns.")