# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


# Metric (objective) names
CONTAMINANT_METRIC = "contaminant_level_ppb"
COST_METRIC = "total_cost_usd_per_m3"

# Random generator for reproducibility of noisy measurements
_rng = np.random.default_rng(seed=42)


def evaluate_water_treatment(
    coagulant_dosage_mg_per_L: float,
    flocculant_dosage_mg_per_L: float,
    disinfectant_dosage_mg_per_L: float,
) -> dict:
    """
    Simulate the water treatment plant outcomes for given chemical dosages.

    Returns a dict of:
      - contaminant_level_ppb: lower is better (ppb)
      - total_cost_usd_per_m3: lower is better ($/m^3)

    This function provides a realistic surrogate for a lab/plant experiment:
      - Organics removal improves with coagulant and flocculant in a saturating manner.
      - Microbial risk decreases with disinfectant and with better clarification (coag/floc).
      - Disinfection byproducts (DBPs) increase with disinfectant dosage and residual organics.
      - Cost is a linear function of dosages using typical per-gram chemical costs.

    Both metrics are reported with experimental noise (SEM provided).
    """

    # Base "true" levels before treatment (ppb-equivalent risk proxies)
    base_organics_ppb = 80.0
    base_micro_ppb = 50.0

    # Process coefficients (tuned for plausible behavior across specified ranges)
    k_org_coag = 0.12
    k_org_floc = 0.22
    k_micro_dis = 0.28
    k_micro_clar = 0.05  # effect of coag + floc on microbial risk reduction
    dbp_factor = 1.5  # scaling for DBP formation

    # Organics residual (ppb), decreasing with coagulant and flocculant
    organics_residual_ppb = base_organics_ppb * np.exp(
        -k_org_coag * coagulant_dosage_mg_per_L - k_org_floc * flocculant_dosage_mg_per_L
    )

    # Microbial risk proxy (ppb-equivalent), reduced by disinfectant and clarification
    microbial_risk_ppb = base_micro_ppb * np.exp(
        -k_micro_dis * disinfectant_dosage_mg_per_L
    ) * np.exp(
        -k_micro_clar * (coagulant_dosage_mg_per_L + flocculant_dosage_mg_per_L)
    )

    # Disinfection byproducts increase with disinfectant and residual organics
    dbp_ppb = dbp_factor * disinfectant_dosage_mg_per_L * (organics_residual_ppb / 50.0)

    # True contaminant level (ppb), aggregate of residuals and DBPs
    true_contaminant_ppb = organics_residual_ppb + microbial_risk_ppb + dbp_ppb

    # Add measurement noise and provide SEM for modeling
    contaminant_sem_ppb = 2.0  # typical analytical repeatability
    observed_contaminant_ppb = float(
        max(0.0, true_contaminant_ppb + _rng.normal(0.0, contaminant_sem_ppb))
    )

    # Chemical unit costs ($/mg for 1 m^3 of water; 1 mg/L = 1 g/m^3)
    coagulant_cost_per_mg = 1.2e-4   # $0.12 per gram
    flocculant_cost_per_mg = 4.5e-4  # $0.45 per gram
    disinfectant_cost_per_mg = 2.0e-4  # $0.20 per gram

    # True cost ($/m3), linear in dosage
    true_cost = (
        coagulant_cost_per_mg * coagulant_dosage_mg_per_L
        + flocculant_cost_per_mg * flocculant_dosage_mg_per_L
        + disinfectant_cost_per_mg * disinfectant_dosage_mg_per_L
    )

    # Add small measurement/accounting noise; ensure non-negative
    cost_sem = 3e-4
    observed_cost = float(max(0.0, true_cost + _rng.normal(0.0, cost_sem)))

    return {
        CONTAMINANT_METRIC: (observed_contaminant_ppb, contaminant_sem_ppb),
        COST_METRIC: (observed_cost, cost_sem),
    }


def compute_pareto_front_observed(df: pd.DataFrame, obj_x: str, obj_y: str) -> pd.DataFrame:
    """
    Compute the empirical Pareto front (non-dominated set) from observed data for two objectives.
    Both objectives are minimized.

    Returns a DataFrame of the Pareto points sorted by obj_x ascending.
    """
    if df.empty:
        return df

    # Drop rows with missing metrics
    df2 = df.dropna(subset=[obj_x, obj_y]).copy()

    # Sort ascending by first objective (primary), then second
    df2.sort_values(by=[obj_x, obj_y], ascending=[True, True], inplace=True)

    pareto_rows = []
    best_y = np.inf
    for _, row in df2.iterrows():
        y = float(row[obj_y])
        if y < best_y - 1e-12:
            pareto_rows.append(row)
            best_y = y

    if not pareto_rows:
        return df2.head(0)

    pareto_df = pd.DataFrame(pareto_rows)
    pareto_df.reset_index(drop=True, inplace=True)
    return pareto_df


def main():
    ax_client = AxClient()

    # Define the experiment: 3 continuous dosage parameters, 2 objectives to minimize
    ax_client.create_experiment(
        parameters=[
            {
                "name": "coagulant_dosage_mg_per_L",
                "type": "range",
                "bounds": [5.0, 20.0],
            },
            {
                "name": "flocculant_dosage_mg_per_L",
                "type": "range",
                "bounds": [1.0, 8.0],
            },
            {
                "name": "disinfectant_dosage_mg_per_L",
                "type": "range",
                "bounds": [2.0, 10.0],
            },
        ],
        objectives={
            CONTAMINANT_METRIC: ObjectiveProperties(minimize=True),
            COST_METRIC: ObjectiveProperties(minimize=True),
        },
    )

    # Run the optimization for the specified budget of trials
    total_trials = 32
    for _ in range(total_trials):
        parameterization, trial_index = ax_client.get_next_trial()

        coagulant = float(parameterization["coagulant_dosage_mg_per_L"])
        flocculant = float(parameterization["flocculant_dosage_mg_per_L"])
        disinfectant = float(parameterization["disinfectant_dosage_mg_per_L"])

        results = evaluate_water_treatment(
            coagulant_dosage_mg_per_L=coagulant,
            flocculant_dosage_mg_per_L=flocculant,
            disinfectant_dosage_mg_per_L=disinfectant,
        )

        ax_client.complete_trial(trial_index=trial_index, raw_data=results)

    # Extract observed data
    df = ax_client.get_trials_data_frame()
    objectives = ax_client.objective_names

    # Compute observed Pareto front
    pareto_df = compute_pareto_front_observed(df, objectives[0], objectives[1])

    # Plot observed points and Pareto front
    fig, ax = plt.subplots(figsize=(7, 5), dpi=150)
    ax.scatter(
        df[objectives[0]],
        df[objectives[1]],
        fc="None",
        ec="k",
        label="Observed",
        alpha=0.7,
    )

    if not pareto_df.empty:
        ax.plot(
            pareto_df[objectives[0]],
            pareto_df[objectives[1]],
            color="#0033FF",
            lw=2,
            label="Pareto Front (Observed)",
        )

    ax.set_xlabel(f"{objectives[0]} (lower is better)")
    ax.set_ylabel(f"{objectives[1]} (lower is better)")
    ax.set_title("Water Treatment Optimization: Pareto Front")
    ax.legend()
    plt.tight_layout()
    plt.show()


if __name__ == "__main__":
    main()