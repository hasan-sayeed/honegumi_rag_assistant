# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


from ax.modelbridge.factory import Models
from ax.modelbridge.generation_strategy import GenerationStep, GenerationStrategy


obj1_name = "branin"


def branin3(x1, x2, x3):
    y = float(
        (x2 - 5.1 / (4 * np.pi**2) * x1**2 + 5.0 / np.pi * x1 - 6.0) ** 2
        + 10 * (1 - 1.0 / (8 * np.pi)) * np.cos(x1)
        + 10
    )

    # Contrived way to incorporate x3 into the objective
    y = y * (1 + 0.1 * x1 * x2 * x3)

    return y


# Define total for compositional constraint, where x1 + x2 + x3 == total
total = 10.0


gs = GenerationStrategy(
    steps=[
        GenerationStep(
            model=Models.SOBOL,
            num_trials=6,  # how many sobol trials to perform (rule of thumb: 2 * number of params)
            min_trials_observed=3,
            max_parallelism=5,
            model_kwargs={"seed": 999},
        ),
        GenerationStep(
            model=Models.SAASBO,
            num_trials=-1,
            max_parallelism=3,
            model_kwargs={},
        ),
    ]
)

ax_client = AxClient(generation_strategy=gs)

ax_client.create_experiment(
    parameters=[
        {"name": "x1", "type": "range", "bounds": [0.0, total]},
        {"name": "x2", "type": "range", "bounds": [0.0, total]},
    ],
    objectives={
        obj1_name: ObjectiveProperties(minimize=True),
    },
    parameter_constraints=[
        f"x1 + x2 <= {total}",  # reparameterized compositional constraint, which is a type of sum constraint
        "x1 <= x2",  # example of an order constraint
    ],
)


batch_size = 2


for i in range(21):

    parameterizations, optimization_complete = ax_client.get_next_trials(batch_size)
    for trial_index, parameterization in list(parameterizations.items()):
        # extract parameters
        x1 = parameterization["x1"]
        x2 = parameterization["x2"]
        x3 = total - (x1 + x2)  # composition constraint: x1 + x2 + x3 == total

        results = branin3(x1, x2, x3)
        ax_client.complete_trial(trial_index=trial_index, raw_data=results)

best_parameters, metrics = ax_client.get_best_parameters()


# Plot results
objectives = ax_client.objective_names
df = ax_client.get_trials_data_frame()
df.index = df.index // batch_size

fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
ax.scatter(df.index, df[objectives], ec="k", fc="none", label="Observed")
ax.plot(
    df.index,
    np.minimum.accumulate(df[objectives]),
    color="#0033FF",
    lw=2,
    label="Best to Trial",
)
ax.set_xlabel("Trial Number")
ax.set_ylabel(objectives[0])

ax.legend()
plt.show()

# Anti-corrosion coating formulation optimization with Ax (Fully Bayesian SAASBO)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

from ax.service.ax_client import AxClient, ObjectiveProperties
from ax.modelbridge.factory import Models
from ax.modelbridge.generation_strategy import GenerationStep, GenerationStrategy


# Problem constants
COMPOSITION_TOTAL = 1.0
BATCH_SIZE = 6
NUM_BATCHES = 20  # 20 batches * 6 = 120 trials
RNG = np.random.default_rng(42)  # for reproducible synthetic noise


def evaluate_coating_formulation(resin_fraction: float,
                                 inhibitor_fraction: float,
                                 insulator_fraction: float,
                                 coating_thickness: float) -> float:
    """
    Synthetic evaluation of corrosion damage score (lower is better).
    This function encodes plausible domain heuristics:
    - More inhibitor and stabilizer reduce corrosion.
    - Higher thickness reduces corrosion with diminishing returns.
    - Too little resin leads to mechanical weakness, increasing corrosion.
    - Some imbalance or excessive insulator can limit protection.

    Returns a single float representing the corrosion_damage_score with added noise.
    """
    # Derive stabilizer from composition equality; constraints ensure it stays in [0, 0.1]
    stabilizer_fraction = COMPOSITION_TOTAL - (resin_fraction + inhibitor_fraction + insulator_fraction)

    # Safety against tiny numerical issues; if out of bounds, add a large penalty
    if stabilizer_fraction < -1e-6 or stabilizer_fraction > 0.100001:
        return 1e6

    # Thickness effect: diminishing returns with thicker coatings
    thickness_effect = np.log1p(coating_thickness)  # grows slowly with thickness
    thickness_gain = np.exp(-0.6 * thickness_effect)  # reduces damage as thickness increases

    # Inhibitor and stabilizer reduce corrosion
    inhibitor_effect = inhibitor_fraction
    stabilizer_effect = stabilizer_fraction
    chemistry_gain = np.exp(-8.0 * (0.9 * inhibitor_effect + 0.4 * stabilizer_effect))

    # Resin structural penalty: if resin < 0.45, penalize (softly); if extremely high, small penalty
    resin_target = 0.5
    resin_penalty = 80.0 * max(0.0, resin_target - resin_fraction) ** 2 + 10.0 * max(0.0, resin_fraction - 0.75) ** 2

    # Insulator penalty: too much insulator can reduce barrier cohesion
    insulator_penalty = 50.0 * max(0.0, insulator_fraction - 0.25) ** 2

    # Balance penalty: encourage resin dominating inhibitor/insulator (constraints ensure ordering already)
    balance_penalty = 20.0 * max(0.0, inhibitor_fraction - 0.35) ** 2 + 20.0 * max(0.0, insulator_fraction - 0.35) ** 2

    # Base scale for damage
    base_damage = 120.0

    # Combine effects (lower is better)
    damage = base_damage * thickness_gain * chemistry_gain + resin_penalty + insulator_penalty + balance_penalty

    # Add realistic measurement/process noise
    noise_std = 2.5
    damage_noisy = float(damage + RNG.normal(0.0, noise_std))
    return max(damage_noisy, 0.0)


# Generation strategy: Sobol initialization followed by Fully Bayesian SAASBO
generation_strategy = GenerationStrategy(
    steps=[
        GenerationStep(
            model=Models.SOBOL,
            num_trials=12,                  # ~2-3x number of effective dimensions
            min_trials_observed=6,
            max_parallelism=BATCH_SIZE,
            model_kwargs={"seed": 12345},
        ),
        GenerationStep(
            model=Models.SAASBO,           # Fully Bayesian GP with MCMC
            num_trials=-1,                 # Use for the remainder
            max_parallelism=BATCH_SIZE,
            model_kwargs={},
        ),
    ]
)

ax_client = AxClient(generation_strategy=generation_strategy)

# Define the experiment (reparameterized: stabilizer_fraction is derived)
ax_client.create_experiment(
    name="anti_corrosion_coating_optimization",
    parameters=[
        {
            "name": "resin_fraction",
            "type": "range",
            "bounds": [0.0, 1.0],
            "value_type": "float",
        },
        {
            "name": "inhibitor_fraction",
            "type": "range",
            "bounds": [0.0, 1.0],
            "value_type": "float",
        },
        {
            "name": "insulator_fraction",
            "type": "range",
            "bounds": [0.0, 1.0],
            "value_type": "float",
        },
        {
            "name": "coating_thickness",
            "type": "range",
            "bounds": [0.1, 10.0],  # mm
            "value_type": "float",
        },
    ],
    objectives={
        "corrosion_damage_score": ObjectiveProperties(minimize=True),
    },
    parameter_constraints=[
        # Composition equality with stabilizer in [0, 0.1] is enforced by:
        # sum of the three explicit fractions in [0.9, 1.0], and stabilizer = 1 - sum
        "resin_fraction + inhibitor_fraction + insulator_fraction <= 1.0",
        "resin_fraction + inhibitor_fraction + insulator_fraction >= 0.9",
        # Ordering constraints: resin must be >= inhibitor and >= insulator
        "inhibitor_fraction <= resin_fraction",
        "insulator_fraction <= resin_fraction",
    ],
)

# Batched ask-tell loop
for _ in range(NUM_BATCHES):
    parameterizations, _ = ax_client.get_next_trials(BATCH_SIZE)
    for trial_index, params in list(parameterizations.items()):
        resin = params["resin_fraction"]
        inhibitor = params["inhibitor_fraction"]
        insulator = params["insulator_fraction"]
        thickness = params["coating_thickness"]

        score = evaluate_coating_formulation(
            resin_fraction=resin,
            inhibitor_fraction=inhibitor,
            insulator_fraction=insulator,
            coating_thickness=thickness,
        )
        # Provide a single mean; Ax will infer noise level (noisy observations)
        ax_client.complete_trial(trial_index=trial_index, raw_data=score)

best_parameters, best_metrics = ax_client.get_best_parameters()

# Compute derived stabilizer for the best parameters
best_resin = best_parameters["resin_fraction"]
best_inhibitor = best_parameters["inhibitor_fraction"]
best_insulator = best_parameters["insulator_fraction"]
best_stabilizer = COMPOSITION_TOTAL - (best_resin + best_inhibitor + best_insulator)
best_thickness = best_parameters["coating_thickness"]

print("Best parameters found:")
print(f"  resin_fraction      = {best_resin:.4f}")
print(f"  inhibitor_fraction  = {best_inhibitor:.4f}")
print(f"  insulator_fraction  = {best_insulator:.4f}")
print(f"  stabilizer_fraction = {best_stabilizer:.4f}  (derived)")
print(f"  coating_thickness   = {best_thickness:.4f} mm")
print("Best metrics (model-predicted):")
print(best_metrics)

# Plot observed corrosion_damage_score over batches
objective_name = ax_client.objective_names[0]
df = ax_client.get_trials_data_frame()
# df may contain multiple rows per trial; ensure sorted by trial_index
df = df.sort_values(by=["trial_index"])
# Group rows per trial and take mean for single metric rows
trial_scores = df.groupby("trial_index")[objective_name].mean()
# Map trial index to batch index
batch_index = (trial_scores.index.to_series() // BATCH_SIZE).values
scores_by_batch = pd.Series(trial_scores.values, index=batch_index)

fig, ax = plt.subplots(figsize=(7, 4.5), dpi=150)
ax.scatter(scores_by_batch.index, scores_by_batch.values, ec="k", fc="none", label="Observed")
ax.plot(
    scores_by_batch.index,
    np.minimum.accumulate(scores_by_batch.values),
    color="#0033FF",
    lw=2,
    label="Best to Trial",
)
ax.set_xlabel("Batch Number")
ax.set_ylabel("corrosion_damage_score")
ax.set_title("Batched optimization of anti-corrosion coating formulation")
ax.legend()
plt.tight_layout()
plt.show()