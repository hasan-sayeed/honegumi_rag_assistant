# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


obj1_name = "branin"


def branin(x1, x2):
    y = float(
        (x2 - 5.1 / (4 * np.pi**2) * x1**2 + 5.0 / np.pi * x1 - 6.0) ** 2
        + 10 * (1 - 1.0 / (8 * np.pi)) * np.cos(x1)
        + 10
    )

    return y


ax_client = AxClient()

ax_client.create_experiment(
    parameters=[
        {"name": "x1", "type": "range", "bounds": [-5.0, 10.0]},
        {"name": "x2", "type": "range", "bounds": [0.0, 10.0]},
    ],
    objectives={
        obj1_name: ObjectiveProperties(minimize=True),
    },
    parameter_constraints=[
        "x1 + x2 <= 15.0",  # example of a sum constraint
    ],
)


for i in range(19):

    parameterization, trial_index = ax_client.get_next_trial()

    # extract parameters
    x1 = parameterization["x1"]
    x2 = parameterization["x2"]

    results = branin(x1, x2)
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)

best_parameters, metrics = ax_client.get_best_parameters()


# Plot results
objectives = ax_client.objective_names
df = ax_client.get_trials_data_frame()

fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
ax.scatter(df.index, df[objectives], ec="k", fc="none", label="Observed")
ax.plot(
    df.index,
    np.minimum.accumulate(df[objectives]),
    color="#0033FF",
    lw=2,
    label="Best to Trial",
)
ax.set_xlabel("Trial Number")
ax.set_ylabel(objectives[0])

ax.legend()
plt.show()

# Optimizing battery electrolyte salt composition with Ax (Bayesian optimization)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from ax.service.ax_client import AxClient, ObjectiveProperties


def measure_ionic_conductivity(
    lipf6_m: float,
    libf4_m: float,
    liclo4_m: float,
    litfsi_m: float,
    rng: np.random.Generator,
) -> tuple[float, float]:
    """
    Simulated measurement of ionic conductivity (mS/cm) for a Li-ion electrolyte
    composed of four lithium salts in a solvent blend. This function provides a
    realistic, smooth surrogate capturing typical trends:
      - Conductivity increases with total salt up to an optimum (~1.2–1.4 M),
        then declines due to viscosity and ion pairing.
      - Different anions contribute differently to ionic mobility.
      - Weak interaction/synergy and competition terms between salts.
      - Additive Gaussian measurement noise.

    Inputs are molar concentrations (M) of each salt. Output is (mean, sem),
    both in mS/cm. Replace this surrogate with actual experimental measurements
    or a high-fidelity simulator to use in production.
    """
    # Safety clamp to non-negative inputs
    lipf6 = max(0.0, float(lipf6_m))
    libf4 = max(0.0, float(libf4_m))
    liclo4 = max(0.0, float(liclo4_m))
    litfsi = max(0.0, float(litfsi_m))

    total_m = lipf6 + libf4 + liclo4 + litfsi

    # Mobility weights: relative conductivity contribution per molarity (unitless scale)
    # LiTFSI ~ high mobility, LiPF6 ~ high, LiClO4 ~ moderate, LiBF4 ~ lower
    w_lipf6 = 1.00
    w_libf4 = 0.65
    w_liclo4 = 0.80
    w_litfsi = 1.10

    effective = (
        w_lipf6 * lipf6 + w_libf4 * libf4 + w_liclo4 * liclo4 + w_litfsi * litfsi
    )

    # Viscosity/ion-pairing penalty away from optimal total concentration
    # Peak around 1.3 M; sharper decline at higher totals
    alpha = 1.7
    peak_center = 1.30
    viscosity_factor = np.exp(-alpha * (total_m - peak_center) ** 2)

    # Mild synergy terms (positive) and competition terms (negative)
    synergy = 0.25 * np.sqrt(max(0.0, lipf6 * litfsi)) + 0.15 * np.sqrt(
        max(0.0, liclo4 * lipf6)
    )
    competition = 0.20 * min(lipf6, libf4) + 0.10 * min(liclo4, libf4)

    # Scale to typical room-temperature conductivity range (mS/cm)
    scale = 10.0
    mean_conductivity = scale * effective * viscosity_factor + synergy - competition

    # Soft floor and cap to plausible lab ranges
    mean_conductivity = float(np.clip(mean_conductivity, 0.1, 20.0))

    # Additive Gaussian measurement noise (simulate noisy lab measurements)
    noise_sd = 0.20  # mS/cm
    measured = mean_conductivity + rng.normal(0.0, noise_sd)

    # Non-negative measurement
    measured = float(max(0.0, measured))

    # Report a reasonable SEM (standard error of mean) to Ax; keep small but nonzero
    sem = 0.15  # mS/cm

    return measured, sem


def main() -> None:
    # Define optimization problem in Ax
    ax_client = AxClient()

    objective_name = "ionic_conductivity"  # mS/cm, maximize

    ax_client.create_experiment(
        name="electrolyte_salt_optimization",
        parameters=[
            {
                "name": "LiPF6_concentration",
                "type": "range",
                "bounds": [0.0, 1.5],
            },
            {
                "name": "LiBF4_concentration",
                "type": "range",
                "bounds": [0.0, 0.5],
            },
            {
                "name": "LiClO4_concentration",
                "type": "range",
                "bounds": [0.0, 0.3],
            },
            {
                "name": "LiTFSI_concentration",
                "type": "range",
                "bounds": [0.0, 0.8],
            },
        ],
        objectives={
            objective_name: ObjectiveProperties(minimize=False),
        },
        parameter_constraints=[
            "LiPF6_concentration + LiBF4_concentration + LiClO4_concentration + LiTFSI_concentration <= 2.0"
        ],
        overwrite_existing_experiment=True,
    )

    # Optimization budget
    n_trials = 40

    # RNG for reproducible noisy measurements
    master_rng = np.random.default_rng(20251030)

    for i in range(n_trials):
        parameterization, trial_index = ax_client.get_next_trial()

        lipf6 = parameterization["LiPF6_concentration"]
        libf4 = parameterization["LiBF4_concentration"]
        liclo4 = parameterization["LiClO4_concentration"]
        litfsi = parameterization["LiTFSI_concentration"]

        # Use an independent RNG stream per trial for clarity
        trial_rng = np.random.default_rng(master_rng.integers(0, 2**32 - 1))
        measured, sem = measure_ionic_conductivity(
            lipf6, libf4, liclo4, litfsi, rng=trial_rng
        )

        ax_client.complete_trial(
            trial_index=trial_index, raw_data={objective_name: (measured, sem)}
        )

    # Retrieve the best found parameters and corresponding objective means
    best_parameters, best_metrics = ax_client.get_best_parameters()
    best_mean = best_metrics[objective_name]["mean"]
    best_sem = best_metrics[objective_name]["sem"]

    print("Best electrolyte composition found (M):")
    for k, v in best_parameters.items():
        print(f"  {k}: {v:.4f}")
    print(
        f"Estimated ionic conductivity: {best_mean:.3f} ± {best_sem:.3f} mS/cm (mean ± SEM)"
    )

    # Plot results across trials
    df = ax_client.get_trials_data_frame()
    metric_col = objective_name

    if metric_col not in df.columns:
        # If the metric column is not present as wide format, try to pivot from long format
        if {"trial_index", "metric_name", "mean"}.issubset(df.columns):
            wide = df.pivot_table(
                index="trial_index", columns="metric_name", values="mean", aggfunc="last"
            ).sort_index()
            series = wide[objective_name]
        else:
            # Fallback: attempt to extract numeric column directly
            series = pd.Series(dtype=float)
    else:
        series = df[metric_col]

    fig, ax = plt.subplots(figsize=(7, 4.5), dpi=140)
    ax.scatter(range(len(series)), series.values, ec="k", fc="none", label="Observed")
    ax.plot(
        range(len(series)),
        np.maximum.accumulate(series.values),
        color="#0033FF",
        lw=2,
        label="Best to Trial",
    )
    ax.set_xlabel("Trial Number")
    ax.set_ylabel("Ionic Conductivity (mS/cm)")
    ax.set_title("Bayesian optimization of electrolyte salt composition")
    ax.legend()
    plt.tight_layout()
    plt.show()


if __name__ == "__main__":
    main()