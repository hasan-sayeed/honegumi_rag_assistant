# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


# Objective metric names
bioavailability_metric = "bioavailability"
shelf_life_metric = "shelf_life"


# Total fraction for compositional constraint (sum of excipients must equal 1.0)
TOTAL_FRACTION = 1.0

# Random generator for reproducible stochastic simulation
_rng = np.random.default_rng(seed=42)


def evaluate_drug_formulation(
    excipient_1: float,
    excipient_2: float,
    excipient_3: float,
    excipient_4: float,
    pH: float,
    storage_temperature: float,
) -> dict:
    """
    Simulate a drug formulation experiment with two objectives:
    - Maximize bioavailability (%)
    - Maximize shelf life (months)

    This function provides a realistic, domain-inspired stochastic simulator:
    - Excipient_2 (surfactant) and excipient_3 (polymer) boost bioavailability.
    - Excipient_4 (antioxidant) and excipient_1 (buffer) primarily enhance shelf life.
    - High surfactant can reduce shelf life; high antioxidant can slightly reduce bioavailability.
    - Bioavailability tends to be best around pH ~ 5.5; stability (shelf life) around pH ~ 6.0.
    - Higher storage temperature reduces shelf life substantially, with mild effect on bioavailability.

    Returns a dict with keys matching objective metric names.
    """
    # Compute the 5th excipient from the simplex constraint
    excipient_5 = max(0.0, TOTAL_FRACTION - (excipient_1 + excipient_2 + excipient_3 + excipient_4))

    # Sanity clip within [0,1]
    e1 = float(np.clip(excipient_1, 0.0, 1.0))
    e2 = float(np.clip(excipient_2, 0.0, 1.0))
    e3 = float(np.clip(excipient_3, 0.0, 1.0))
    e4 = float(np.clip(excipient_4, 0.0, 1.0))
    e5 = float(np.clip(excipient_5, 0.0, 1.0))

    # Clip controls
    pH = float(np.clip(pH, 3.0, 7.0))
    T = float(np.clip(storage_temperature, 15.0, 30.0))

    # -----------------------------
    # Bioavailability (%) model
    # -----------------------------
    # Surfactant-polymer synergy (saturating)
    surf_poly_synergy = 1.0 - np.exp(-4.0 * (0.8 * e2 + 1.0 * e3 + 0.2 * e1))
    # pH effect peaked around 5.5 (Gaussian-like penalty)
    pH_penalty_ba = np.exp(-((pH - 5.5) ** 2) / (2 * (0.6 ** 2)))
    # Antioxidant can slightly reduce BA if very high (micelle stabilization tradeoff)
    antioxidant_drag = 1.0 - 0.15 * e4
    # Temperature has mild negative impact on BA
    temp_effect_ba = 1.0 - 0.01 * (T - 20.0)

    # Assemble with scaling to [0,100] range
    bioavailability_mean = 15.0 + 85.0 * surf_poly_synergy * pH_penalty_ba * antioxidant_drag * temp_effect_ba
    # Slight penalty if filler excipient dominates (dilution)
    bioavailability_mean *= (1.0 - 0.08 * e5)
    # Observation noise (heteroscedastic small)
    bioavailability_noise = _rng.normal(loc=0.0, scale=1.5 + 0.5 * abs(0.5 - pH))
    bioavailability = float(np.clip(bioavailability_mean + bioavailability_noise, 0.0, 100.0))

    # -----------------------------
    # Shelf life (months) model
    # -----------------------------
    # Baseline driven by temperature (Arrhenius-like decay; higher T -> lower stability)
    temp_baseline = 40.0 * np.exp(-0.07 * (T - 15.0))  # ~40 months at 15C, ~16 months at 30C
    # pH stability peak near 6.0
    pH_stability = 1.0 + 0.20 * np.exp(-((pH - 6.0) ** 2) / (2 * (0.7 ** 2))) - 0.10 * np.exp(-((pH - 4.0) ** 2) / (2 * (0.5 ** 2)))
    # Excipient contributions
    antioxidant_boost = 18.0 * e4  # strong positive
    buffer_boost = 6.0 * e1        # moderate positive
    surfactant_drag = -10.0 * (e2 ** 1.2)  # surfactant can destabilize long-term
    polymer_drag = -5.0 * (e3 ** 1.1)      # some polymers can reduce stability
    filler_neutral = 2.0 * e5              # slight positive (dilution of reactive species)

    shelf_life_mean = temp_baseline * pH_stability + antioxidant_boost + buffer_boost + surfactant_drag + polymer_drag + filler_neutral
    # Clip to reasonable range
    shelf_life_mean = float(np.clip(shelf_life_mean, 1.0, 48.0))
    # Observation noise
    shelf_life_noise = _rng.normal(loc=0.0, scale=1.0 + 0.3 * (30.0 - T) / 15.0)
    shelf_life = float(np.clip(shelf_life_mean + shelf_life_noise, 0.0, 60.0))

    return {
        bioavailability_metric: bioavailability,
        shelf_life_metric: shelf_life,
    }


def _compute_pareto_front(df: pd.DataFrame, objective_cols: list[str]) -> pd.DataFrame:
    """
    Compute Pareto frontier (for maximization) from observed data in df.
    Returns a DataFrame with only Pareto-optimal rows, sorted by the first objective.
    """
    df_valid = df.dropna(subset=objective_cols).copy()
    pts = df_valid[objective_cols].to_numpy()
    n = pts.shape[0]
    is_dominated = np.zeros(n, dtype=bool)
    for i in range(n):
        if is_dominated[i]:
            continue
        for j in range(n):
            if i == j:
                continue
            # j dominates i if all objectives >= and at least one strictly >
            if np.all(pts[j] >= pts[i]) and np.any(pts[j] > pts[i]):
                is_dominated[i] = True
                break
    pareto_df = df_valid.loc[~is_dominated].copy()
    pareto_df = pareto_df.sort_values(by=objective_cols[0], ascending=False)
    return pareto_df


# Initialize Ax client
ax_client = AxClient()

# Create experiment with reparameterized simplex: optimize first 4 excipients;
# the 5th is computed as 1 - sum(e1..e4).
ax_client.create_experiment(
    name="drug_formulation_multi_objective",
    parameters=[
        {"name": "excipient_1", "type": "range", "bounds": [0.0, 1.0]},
        {"name": "excipient_2", "type": "range", "bounds": [0.0, 1.0]},
        {"name": "excipient_3", "type": "range", "bounds": [0.0, 1.0]},
        {"name": "excipient_4", "type": "range", "bounds": [0.0, 1.0]},
        {"name": "pH", "type": "range", "bounds": [3.0, 7.0]},
        {"name": "storage_temperature", "type": "range", "bounds": [15.0, 30.0]},
    ],
    objectives={
        bioavailability_metric: ObjectiveProperties(minimize=False),
        shelf_life_metric: ObjectiveProperties(minimize=False),
    },
    parameter_constraints=[
        # Reparameterized compositional (simplex) constraint: excipient_1 + ... + excipient_4 <= 1,
        # and excipient_5 is implicitly 1 - sum(first four), ensuring the full composition sums to 1.
        "excipient_1 + excipient_2 + excipient_3 + excipient_4 <= 1.0",
    ],
    is_test=True,  # Indicates using a simulator; set False when connecting to real experiments
)

# Optimization budget
NUM_TRIALS = 50

for _ in range(NUM_TRIALS):
    parameterization, trial_index = ax_client.get_next_trial()

    # Extract parameters
    e1 = parameterization["excipient_1"]
    e2 = parameterization["excipient_2"]
    e3 = parameterization["excipient_3"]
    e4 = parameterization["excipient_4"]
    pH_value = parameterization["pH"]
    storage_temp_c = parameterization["storage_temperature"]

    # Evaluate experiment
    try:
        results = evaluate_drug_formulation(e1, e2, e3, e4, pH_value, storage_temp_c)
        ax_client.complete_trial(trial_index=trial_index, raw_data=results)
    except Exception as err:
        ax_client.log_trial_failure(trial_index=trial_index)
        print(f"Trial {trial_index} failed with error: {err}")

# Retrieve results and visualize Pareto front
df = ax_client.get_trials_data_frame()
objective_cols = [bioavailability_metric, shelf_life_metric]

# Compute Pareto front from observed data
pareto_df = _compute_pareto_front(df, objective_cols)

# Plot results
fig, ax = plt.subplots(figsize=(7, 5), dpi=140)
ax.scatter(df[bioavailability_metric], df[shelf_life_metric], fc="None", ec="gray", label="Observed")
ax.plot(
    pareto_df[bioavailability_metric],
    pareto_df[shelf_life_metric],
    color="#0072B2",
    lw=2.0,
    marker="o",
    ms=4,
    label="Observed Pareto Front",
)

ax.set_xlabel(f"{bioavailability_metric} (%)")
ax.set_ylabel(f"{shelf_life_metric} (months)")
ax.set_title("Drug Formulation Optimization: Bioavailability vs. Shelf Life")
ax.grid(True, alpha=0.3)
ax.legend()
plt.tight_layout()
plt.show()