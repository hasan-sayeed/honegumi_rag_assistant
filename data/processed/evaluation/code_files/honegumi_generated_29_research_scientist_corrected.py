# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from typing import Dict, Tuple

from ax.service.ax_client import AxClient
from ax.service.utils.instantiation import ObjectiveProperties


# Domain-specific metric names
OBJ_CHARGE_TIME = "charge_time_min"  # minimize
OBJ_CYCLE_LIFE = "cycle_life_cycles"  # maximize


def _clamp(value: float, low: float, high: float) -> float:
    return max(low, min(high, value))


def evaluate_charging_protocol(
    charge_current_c: float, voltage_limit_v: float, temperature_c: float, rng: np.random.Generator
) -> Dict[str, Tuple[float, float]]:
    """
    Simulated evaluation of a lithium-ion battery charging protocol:
    Inputs:
      - charge_current_c: C-rate (0.5C to 3C)
      - voltage_limit_v: upper cutoff voltage (4.1V to 4.3V)
      - temperature_c: ambient/cell temperature (10C to 40C)
    Returns:
      - Dict of metric name -> (mean, sem)
        charge_time_min: minutes to full charge (lower is better)
        cycle_life_cycles: number of full equivalent cycles (higher is better)
    Notes:
      - This is a realistic, physics-inspired stub. Replace with real lab or simulation code.
      - The model captures common tradeoffs: higher current and voltage limit reduce charge time
        but degrade cycle life; low temperature slows charging and can also affect life.
    """

    c = float(charge_current_c)
    v = float(voltage_limit_v)
    t = float(temperature_c)

    # ------------------------
    # Charge time model (minutes)
    # ------------------------
    # CC (constant-current) portion: scales ~ 60 / C
    # Fraction of capacity delivered under CC reduces with higher voltage limit (more time in CV)
    # and higher C-rate (earlier voltage limit hit).
    cc_fraction = 0.5 + (-0.2 * ((v - 4.2) / 0.1)) + (-0.1 * (c - 1.0))
    cc_fraction = _clamp(cc_fraction, low=0.2, high=0.9)

    t_cc_min = 60.0 * cc_fraction / c

    # CV (constant-voltage) portion: base time inflated by higher voltage limit, higher C, and colder temps.
    base_cv_min = 25.0
    voltage_factor = 1.0 + 0.8 * ((v - 4.2) / 0.1)  # +80% per +0.1 V, -80% per -0.1 V
    voltage_factor = _clamp(voltage_factor, low=0.4, high=2.2)

    current_factor = 1.0 + 0.25 * (c - 1.0)  # up to +50% at 3C, down to ~0.875 at 0.5C
    current_factor = _clamp(current_factor, low=0.7, high=1.5)

    temp_factor = 1.0 + 0.5 * ((25.0 - t) / 15.0)  # +50% at 10C, -50% at 40C
    temp_factor = _clamp(temp_factor, low=0.5, high=1.5)

    t_cv_min = base_cv_min * voltage_factor * current_factor * temp_factor

    charge_time_min = t_cc_min + t_cv_min

    # ------------------------
    # Cycle life model (cycles)
    # ------------------------
    # Base life at mild conditions (1C, 4.2 V, 25 C).
    base_life = 1500.0

    # Penalize deviations from mild settings:
    # Higher voltage limit strongly degrades life; lower voltage provides benefit.
    kv = 0.5
    life_v = np.exp(-kv * ((v - 4.2) / 0.1))

    # C-rate penalty (symmetric around 1C via squared deviation).
    kc = 0.7
    life_c = np.exp(-kc * (c - 1.0) ** 2)

    # Temperature penalty (both too cold and too hot are detrimental).
    kt = 0.2
    life_t = np.exp(-kt * ((t - 25.0) / 15.0) ** 2)

    # Interaction: high voltage AND high current amplifies degradation.
    kcv = 1.0
    interaction_penalty = np.exp(-kcv * max(v - 4.22, 0.0) * max(c - 1.5, 0.0) * 3.0)

    cycle_life_cycles = base_life * life_v * life_c * life_t * interaction_penalty
    cycle_life_cycles = float(max(1.0, cycle_life_cycles))

    # ------------------------
    # Add noise to simulate experimental measurement variability
    # ------------------------
    charge_time_sem = 0.8  # minutes
    cycle_life_sem = 30.0  # cycles

    noisy_charge_time = float(charge_time_min + rng.normal(0.0, charge_time_sem))
    noisy_cycle_life = float(cycle_life_cycles + rng.normal(0.0, cycle_life_sem))

    # Ensure physical plausibility after noise
    noisy_charge_time = max(1.0, noisy_charge_time)
    noisy_cycle_life = max(1.0, noisy_cycle_life)

    return {
        OBJ_CHARGE_TIME: (noisy_charge_time, charge_time_sem),
        OBJ_CYCLE_LIFE: (noisy_cycle_life, cycle_life_sem),
    }


def main():
    # Reproducible randomness for the synthetic evaluator
    rng = np.random.default_rng(seed=42)

    ax_client = AxClient()

    ax_client.create_experiment(
        name="battery_charging_moo",
        parameters=[
            {
                "name": "charge_current_c",
                "type": "range",
                "bounds": [0.5, 3.0],
                "value_type": "float",
            },
            {
                "name": "voltage_limit_v",
                "type": "range",
                "bounds": [4.1, 4.3],
                "value_type": "float",
            },
            {
                "name": "temperature_c",
                "type": "range",
                "bounds": [10.0, 40.0],
                "value_type": "float",
            },
        ],
        objectives={
            OBJ_CHARGE_TIME: ObjectiveProperties(minimize=True),   # minutes
            OBJ_CYCLE_LIFE: ObjectiveProperties(minimize=False),   # cycles
        },
    )

    # Run optimization with a budget of 35 trials
    NUM_TRIALS = 35
    for _ in range(NUM_TRIALS):
        parameterization, trial_index = ax_client.get_next_trial()

        charge_current_c = float(parameterization["charge_current_c"])
        voltage_limit_v = float(parameterization["voltage_limit_v"])
        temperature_c = float(parameterization["temperature_c"])

        results = evaluate_charging_protocol(
            charge_current_c=charge_current_c,
            voltage_limit_v=voltage_limit_v,
            temperature_c=temperature_c,
            rng=rng,
        )

        ax_client.complete_trial(trial_index=trial_index, raw_data=results)

    # Retrieve Pareto-optimal parameterizations (observed)
    pareto_map = ax_client.get_pareto_optimal_parameters(use_model_predictions=False)

    # Plot results: observed scatter and observed Pareto front
    objectives = ax_client.objective_names
    df = ax_client.get_trials_data_frame()

    fig, ax = plt.subplots(figsize=(7, 5), dpi=150)
    ax.scatter(
        df[objectives[0]],
        df[objectives[1]],
        fc="None",
        ec="k",
        label="Observed",
    )

    # Build a DataFrame from observed Pareto points
    pareto_data = []
    for _, value in pareto_map.items():
        # value is typically a tuple: (means_dict, cov_matrix)
        means_dict = value[0] if isinstance(value, tuple) and len(value) > 0 else value
        # Ensure keys match objective names
        pareto_data.append(
            {
                objectives[0]: float(means_dict[objectives[0]]),
                objectives[1]: float(means_dict[objectives[1]]),
            }
        )

    if pareto_data:
        pareto_df = pd.DataFrame(pareto_data).sort_values(by=objectives[0])
        ax.plot(
            pareto_df[objectives[0]],
            pareto_df[objectives[1]],
            color="#0033FF",
            lw=2,
            label="Pareto Front (observed)",
        )

    ax.set_xlabel(f"{OBJ_CHARGE_TIME} (min)")
    ax.set_ylabel(f"{OBJ_CYCLE_LIFE} (cycles)")
    ax.legend()
    plt.tight_layout()
    plt.show()


if __name__ == "__main__":
    main()