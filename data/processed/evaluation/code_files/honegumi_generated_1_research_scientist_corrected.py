# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


obj1_name = "branin"


def branin(x1, x2):
    y = float(
        (x2 - 5.1 / (4 * np.pi**2) * x1**2 + 5.0 / np.pi * x1 - 6.0) ** 2
        + 10 * (1 - 1.0 / (8 * np.pi)) * np.cos(x1)
        + 10
    )

    return y


ax_client = AxClient()

ax_client.create_experiment(
    parameters=[
        {"name": "x1", "type": "range", "bounds": [-5.0, 10.0]},
        {"name": "x2", "type": "range", "bounds": [0.0, 10.0]},
    ],
    objectives={
        obj1_name: ObjectiveProperties(minimize=True),
    },
)


for i in range(19):

    parameterization, trial_index = ax_client.get_next_trial()

    # extract parameters
    x1 = parameterization["x1"]
    x2 = parameterization["x2"]

    results = branin(x1, x2)
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)

best_parameters, metrics = ax_client.get_best_parameters()


# Plot results
objectives = ax_client.objective_names
df = ax_client.get_trials_data_frame()

fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
ax.scatter(df.index, df[objectives], ec="k", fc="none", label="Observed")
ax.plot(
    df.index,
    np.minimum.accumulate(df[objectives]),
    color="#0033FF",
    lw=2,
    label="Best to Trial",
)
ax.set_xlabel("Trial Number")
ax.set_ylabel(objectives[0])

ax.legend()
plt.show()

# Generated from Honegumi skeleton and adapted to ceramic sintering study
# %pip install ax-platform==0.4.3 matplotlib numpy pandas
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from typing import Tuple, Dict, Any

from ax.service.ax_client import AxClient, ObjectiveProperties


# Problem-specific configuration
density_metric_name = "density_g_per_cm3"
param_temperature = "sinter_temperature_celsius"
param_time = "sinter_time_hours"

# Set random seed for reproducibility of the synthetic measurement noise
np.random.seed(42)


def evaluate_sintering_density(temperature_celsius: float, time_hours: float) -> Tuple[float, float]:
    """Simulate density (g/cm^3) of a ceramic after sintering at given temperature and time.

    This is a physically-inspired stub based on Arrhenius-type sintering kinetics:
      - Densification fraction increases with temperature and time.
      - A mild 'bloating' penalty is applied for very high temperatures and long times.
      - Additive Gaussian measurement noise is included to reflect experimental variability.

    TODO: Replace with actual experimental measurement integration, e.g.:
      - Run furnace program and measure density (Archimedes or pycnometry).
      - Return the measured mean density and the measurement standard error.

    Returns:
      mean_density_g_per_cm3, sem_density_g_per_cm3
    """
    # Constants and simple kinetics model
    R = 8.314  # J/(mol*K)
    activation_energy_J_per_mol = 220e3  # 220 kJ/mol (tunable)
    k0_per_hour = 1e9  # pre-exponential factor (1/hour), tuned for 800-1200 C regime

    # Theoretical and initial densities (example values; update for your ceramic)
    rho_theoretical = 6.0  # g/cm^3, e.g., dense alumina-like
    rho_green = 2.0        # g/cm^3, unsintered compact

    T_K = float(temperature_celsius) + 273.15
    t_h = float(time_hours)

    # Arrhenius rate
    rate = k0_per_hour * np.exp(-activation_energy_J_per_mol / (R * T_K))
    densification_fraction = 1.0 - np.exp(-rate * t_h)
    densification_fraction = np.clip(densification_fraction, 0.0, 1.0)

    # Base density from densification
    density = rho_green + (rho_theoretical - rho_green) * densification_fraction

    # Bloating penalty for prolonged high T and time (small effect)
    def sigmoid(x: float) -> float:
        return 1.0 / (1.0 + np.exp(-x))

    high_T_factor = sigmoid((temperature_celsius - 1150.0) / 20.0)  # transitions near 1150 C
    long_t_factor = sigmoid((t_h - 4.0) / 1.0)                      # transitions near 4 h
    penalty_fraction = 0.05 * high_T_factor * long_t_factor         # up to 5% density reduction
    density *= (1.0 - penalty_fraction)

    # Measurement noise (represents variability in measurement)
    measurement_sigma = 0.02  # g/cm^3 standard deviation
    observed_density = density + np.random.normal(loc=0.0, scale=measurement_sigma)

    # Clip to physical bounds
    observed_density = float(np.clip(observed_density, rho_green, rho_theoretical))

    # Provide a nominal SEM to Ax (could be from repeated measurements)
    sem_density = 0.01  # g/cm^3

    return observed_density, sem_density


def main() -> None:
    # Initialize Ax client
    ax_client = AxClient()

    # Create experiment: single objective (maximize density), two continuous parameters
    ax_client.create_experiment(
        name="ceramic_sintering_density_optimization",
        parameters=[
            {"name": param_temperature, "type": "range", "bounds": [800.0, 1200.0], "value_type": "float"},
            {"name": param_time, "type": "range", "bounds": [1.0, 6.0], "value_type": "float"},
        ],
        objectives={
            density_metric_name: ObjectiveProperties(minimize=False),
        },
        overwrite_existing_experiment=True,
    )

    # Run optimization for the specified budget
    num_trials = 30
    for _ in range(num_trials):
        parameterization, trial_index = ax_client.get_next_trial()
        try:
            temperature_c = float(parameterization[param_temperature])
            time_h = float(parameterization[param_time])

            mean_density, sem_density = evaluate_sintering_density(temperature_c, time_h)

            # Report result to Ax; provide noise via (mean, SEM)
            ax_client.complete_trial(
                trial_index=trial_index,
                raw_data={density_metric_name: (mean_density, sem_density)},
            )
        except Exception as e:
            # If something goes wrong in evaluation, mark trial as failed
            print(f"Trial {trial_index} failed with error: {e}")
            ax_client.log_trial_failure(trial_index=trial_index)

    # Retrieve best found parameters
    best_parameters, metrics = ax_client.get_best_parameters()
    best_density_mean = metrics[density_metric_name]["mean"]
    best_density_sem = metrics[density_metric_name]["sem"]

    print("Best sintering conditions found:")
    print(f"  {param_temperature}: {best_parameters[param_temperature]:.2f} °C")
    print(f"  {param_time}: {best_parameters[param_time]:.2f} hours")
    print(f"  {density_metric_name}: {best_density_mean:.4f} ± {best_density_sem:.4f} g/cm³")

    # Visualization
    objectives = ax_client.objective_names
    df = ax_client.get_trials_data_frame()

    # Sort by trial index for clean plotting
    if "trial_index" in df.columns:
        df = df.sort_values("trial_index").reset_index(drop=True)

    # Plot density vs trial number with best-so-far
    fig, ax = plt.subplots(figsize=(7, 4), dpi=150)
    y = df[objectives[0]].values
    x = np.arange(1, len(y) + 1)
    ax.scatter(x, y, ec="k", fc="none", label="Observed")
    ax.plot(x, np.maximum.accumulate(y), color="#0033FF", lw=2, label="Best to Trial")
    ax.set_xlabel("Trial Number")
    ax.set_ylabel(f"{density_metric_name} (g/cm³)")
    ax.set_title("Sintering Density Optimization Progress")
    ax.legend()
    plt.tight_layout()
    plt.show()

    # Scatter of parameter space colored by observed density
    if param_temperature in df.columns and param_time in df.columns:
        fig2, ax2 = plt.subplots(figsize=(6, 5), dpi=150)
        sc = ax2.scatter(
            df[param_temperature].values,
            df[param_time].values,
            c=df[objectives[0]].values,
            cmap="viridis",
            s=60,
            edgecolor="k",
        )
        ax2.set_xlabel("Temperature (°C)")
        ax2.set_ylabel("Time (hours)")
        ax2.set_title("Explored Sintering Conditions")
        cbar = plt.colorbar(sc, ax=ax2)
        cbar.set_label("Density (g/cm³)")
        plt.tight_layout()
        plt.show()


if __name__ == "__main__":
    main()