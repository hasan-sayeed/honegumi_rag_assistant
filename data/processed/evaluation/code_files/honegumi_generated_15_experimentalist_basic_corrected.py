# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


# Random generator for reproducibility in this simulation.
# In a real lab setting, remove the fixed seed to reflect true measurement variability.
RNG = np.random.default_rng(2025)


def evaluate_solar_cell_pce(annealing_temperature: float, deposition_rate: float) -> dict:
    """
    Simulated evaluation of solar cell power conversion efficiency (PCE %).

    Parameters:
      - annealing_temperature (°C): 100–200
      - deposition_rate (nm/s): 0.5–3.0

    Returns:
      A dict mapping the metric name to a (mean, sem) tuple as expected by Ax:
        {"power_conversion_efficiency": (pce_mean, pce_sem)}

    Note:
      Replace this simulation with actual experimental measurement logic when integrating with the lab:
        - Set furnace temperature and deposition tool rate
        - Fabricate the cell
        - Measure PCE under standard test conditions (AM1.5G)
        - Return the measured PCE and an estimated SEM based on metrology repeatability
    """
    # Domain-informed synthetic landscape:
    # - Peak PCE near moderate annealing temperature and moderate deposition rate.
    # - Deterioration at extremes due to defects (under/over-annealing, poor morphology).
    # - Mild interaction between parameters.
    T = float(annealing_temperature)
    R = float(deposition_rate)

    # Optima and characteristic widths for the peak in each dimension
    T_opt = 165.0  # °C
    R_opt = 1.4    # nm/s
    sigma_T = 12.0
    sigma_R = 0.35

    # Base and peak levels (in % PCE)
    base_pce = 12.0
    peak_gain = 11.0  # peak above base

    # 2D Gaussian-shaped optimum
    gaussian_peak = np.exp(-0.5 * ((T - T_opt) / sigma_T) ** 2 - 0.5 * ((R - R_opt) / sigma_R) ** 2)

    # Soft penalties outside practical windows
    penalty_T = 0.003 * max(0.0, T - 185.0) ** 1.5 + 0.002 * max(0.0, 115.0 - T) ** 1.5
    penalty_R = 0.8 * max(0.0, R - 2.5) ** 2 + 0.4 * max(0.0, 0.7 - R) ** 2

    # Interaction: at lower anneal temperatures, higher deposition rates hurt more (morphology issues)
    interaction = -0.8 * max(0.0, 1.8 * (1.0 - (T - 100.0) / 100.0)) * (R - R_opt) ** 2

    # Assemble deterministic PCE
    pce_det = base_pce + peak_gain * gaussian_peak - penalty_T - penalty_R + interaction

    # Additive measurement noise (represents device-to-device and measurement variability)
    measurement_noise_sd = 0.25  # absolute % PCE standard deviation
    pce_noisy = pce_det + RNG.normal(0.0, measurement_noise_sd)

    # Clamp to physically plausible range
    pce_noisy = float(np.clip(pce_noisy, 0.0, 30.0))

    # Provide an estimated SEM; in real measurements, derive from repeated readings or historical metrology stats
    pce_sem = 0.25

    return {"power_conversion_efficiency": (pce_noisy, pce_sem)}


# Initialize Ax client
ax_client = AxClient(verbose_logging=False)

# Create experiment for solar cell fabrication optimization
ax_client.create_experiment(
    name="solar_cell_fabrication_optimization",
    parameters=[
        {"name": "annealing_temperature", "type": "range", "bounds": [100.0, 200.0]},   # °C
        {"name": "deposition_rate", "type": "range", "bounds": [0.5, 3.0]},             # nm/s
    ],
    objectives={
        "power_conversion_efficiency": ObjectiveProperties(minimize=False),
    },
    overwrite_existing_experiment=True,
)

# Run optimization for the given budget (25 solar cells)
budget_trials = 25
for _ in range(budget_trials):
    parameterization, trial_index = ax_client.get_next_trial()

    # Extract experimental settings
    temp_c = parameterization["annealing_temperature"]
    rate_nm_s = parameterization["deposition_rate"]

    # Evaluate (simulate or replace with actual lab measurement)
    results = evaluate_solar_cell_pce(temp_c, rate_nm_s)

    # Report back to Ax
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)

# Retrieve best parameters and associated metric
best_parameters, best_metrics = ax_client.get_best_parameters()
best_pce = best_metrics.get("power_conversion_efficiency")

print("Best parameters found:")
print(best_parameters)
print("Best power conversion efficiency (estimated):", best_pce)

# Plot results
objective_names = ax_client.objective_names
df = ax_client.get_trials_data_frame()

# Handle plotting for single objective
obj_name = objective_names[0]
y = pd.to_numeric(df[obj_name], errors="coerce").values

fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
ax.scatter(df.index, y, ec="k", fc="none", label="Observed")
ax.plot(df.index, np.maximum.accumulate(y), color="#0033FF", lw=2, label="Best to Trial")
ax.set_xlabel("Trial Number")
ax.set_ylabel("Power Conversion Efficiency (%)")
ax.set_title("Bayesian Optimization of Solar Cell Fabrication")
ax.legend()
plt.tight_layout()
plt.show()