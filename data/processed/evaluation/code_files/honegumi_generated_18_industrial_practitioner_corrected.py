# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


obj1_name = "branin"
obj2_name = "branin_swapped"


def branin3_moo(x1, x2, x3):
    y = float(
        (x2 - 5.1 / (4 * np.pi**2) * x1**2 + 5.0 / np.pi * x1 - 6.0) ** 2
        + 10 * (1 - 1.0 / (8 * np.pi)) * np.cos(x1)
        + 10
    )

    # Contrived way to incorporate x3 into the objective
    y = y * (1 + 0.1 * x1 * x2 * x3)

    # second objective has x1 and x2 swapped
    y2 = float(
        (x1 - 5.1 / (4 * np.pi**2) * x2**2 + 5.0 / np.pi * x2 - 6.0) ** 2
        + 10 * (1 - 1.0 / (8 * np.pi)) * np.cos(x2)
        + 10
    )

    # Contrived way to incorporate x3 into the second objective
    y2 = y2 * (1 - 0.1 * x1 * x2 * x3)

    return {obj1_name: y, obj2_name: y2}


# Define total for compositional constraint, where x1 + x2 + x3 == total
total = 10.0


ax_client = AxClient()

ax_client.create_experiment(
    parameters=[
        {"name": "x1", "type": "range", "bounds": [0.0, total]},
        {"name": "x2", "type": "range", "bounds": [0.0, total]},
    ],
    objectives={
        obj1_name: ObjectiveProperties(minimize=True),
        obj2_name: ObjectiveProperties(minimize=True),
    },
    parameter_constraints=[
        f"x1 + x2 <= {total}",  # reparameterized compositional constraint, which is a type of sum constraint
    ],
)


for i in range(21):

    parameterization, trial_index = ax_client.get_next_trial()

    # extract parameters
    x1 = parameterization["x1"]
    x2 = parameterization["x2"]
    x3 = total - (x1 + x2)  # composition constraint: x1 + x2 + x3 == total

    results = branin3_moo(x1, x2, x3)
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)
pareto_results = ax_client.get_pareto_optimal_parameters()


# Plot results
objectives = ax_client.objective_names
df = ax_client.get_trials_data_frame()

fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
pareto = ax_client.get_pareto_optimal_parameters(use_model_predictions=False)
pareto_data = [p[1][0] for p in pareto.values()]
pareto = pd.DataFrame(pareto_data).sort_values(objectives[0])

ax.scatter(df[objectives[0]], df[objectives[1]], fc="None", ec="k", label="Observed")
ax.plot(
    pareto[objectives[0]],
    pareto[objectives[1]],
    color="#0033FF",
    lw=2,
    label="Pareto Front",
)
ax.set_xlabel(objectives[0])
ax.set_ylabel(objectives[1])

ax.legend()
plt.show()

# Generated for adhesive formulation optimization using Ax Platform
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


# Seed for reproducibility
rng = np.random.default_rng(42)

# Objective (metric) names
bond_strength_metric = "bond_strength"  # MPa, maximize
cure_time_metric = "cure_time"          # hours, minimize

# Total composition for the system (fractions sum to 1.0)
TOTAL_COMPOSITION = 1.0


def evaluate_adhesive_formulation(
    resin_A_fraction: float,
    resin_B_fraction: float,
    resin_C_fraction: float,
    hardener_fraction: float,
) -> dict:
    """
    Simulated evaluation of an adhesive formulation defined by component fractions.
    Returns noisy measurements for:
      - bond_strength (MPa): to maximize
      - cure_time (hours): to minimize

    This is a realistic stub. Replace with actual lab measurements, LIMS integration,
    or a physics-based model as needed.
    """
    # Small numerical tolerance for constraint satisfaction
    tol = 1e-9

    # Validate composition sums to unity
    total = resin_A_fraction + resin_B_fraction + resin_C_fraction + hardener_fraction
    if abs(total - TOTAL_COMPOSITION) > 1e-6:
        raise ValueError(f"Compositions must sum to {TOTAL_COMPOSITION}, got {total:.6f}")

    # Validate bounds with small tolerance
    if not (0.1 - tol <= resin_A_fraction <= 0.4 + tol):
        raise ValueError("resin_A_fraction out of bounds [0.1, 0.4].")
    if not (0.1 - tol <= resin_B_fraction <= 0.4 + tol):
        raise ValueError("resin_B_fraction out of bounds [0.1, 0.4].")
    if not (0.1 - tol <= resin_C_fraction <= 0.4 + tol):
        raise ValueError("resin_C_fraction out of bounds [0.1, 0.4].")
    if not (0.2 - tol <= hardener_fraction <= 0.5 + tol):
        raise ValueError("hardener_fraction out of bounds [0.2, 0.5].")

    # Targeted "good" formulation (domain-inspired guess)
    target = {
        "A": 0.25,
        "B": 0.25,
        "C": 0.20,
        "H": 0.30,
    }

    A = float(resin_A_fraction)
    B = float(resin_B_fraction)
    C = float(resin_C_fraction)
    H = float(hardener_fraction)

    # Bond strength model (MPa)
    # - Penalize deviation from target composition via quadratic terms
    # - Include mild synergistic interactions among resins
    quad_penalty = 400.0 * (
        (A - target["A"]) ** 2
        + (B - target["B"]) ** 2
        + (C - target["C"]) ** 2
        + (H - target["H"]) ** 2
    )
    synergy = 20.0 * (A * B) + 10.0 * (B * C) + 8.0 * (A * C) - 10.0 * H * (1.0 - H)
    strength_mean = 60.0 - quad_penalty + synergy
    strength_mean = float(np.clip(strength_mean, 0.0, 100.0))

    # Cure time model (hours)
    # - Strongly reduced by higher hardener content
    # - Mild penalties for resin imbalance and off-target C
    time_mean = (
        12.0
        - 18.0 * H
        + 40.0 * (C - target["C"]) ** 2
        + 2.0 * abs(A - B)
        + 1.0 * abs((A + B) / 2.0 - C)
    )
    time_mean = float(np.clip(time_mean, 0.2, 24.0))

    # Measurement noise (assumed homoscedastic for simplicity)
    strength_sd = 1.0
    time_sd = 0.10

    strength_obs = float(rng.normal(strength_mean, strength_sd))
    time_obs = float(rng.normal(time_mean, time_sd))

    # Report SEMs to inform the noise model in Ax
    strength_sem = 0.5 * strength_sd
    time_sem = 0.5 * time_sd

    # Ensure non-negative strength and non-negative time (physical constraints)
    strength_obs = max(0.0, strength_obs)
    time_obs = max(0.0, time_obs)

    return {
        bond_strength_metric: (strength_obs, strength_sem),
        cure_time_metric: (time_obs, time_sem),
    }


def compute_pareto_mask(strength: np.ndarray, time_: np.ndarray) -> np.ndarray:
    """
    Compute Pareto-optimal mask for two objectives:
      - strength: maximize
      - time: minimize
    """
    n = len(strength)
    mask = np.ones(n, dtype=bool)
    for i in range(n):
        if not mask[i]:
            continue
        for j in range(n):
            if i == j:
                continue
            # j dominates i if:
            # strength_j >= strength_i AND time_j <= time_i
            # and strictly better in at least one objective
            if (
                strength[j] >= strength[i]
                and time_[j] <= time_[i]
                and (strength[j] > strength[i] or time_[j] < time_[i])
            ):
                mask[i] = False
                break
    return mask


# Initialize Ax client
ax_client = AxClient()

# We reparameterize the composition by optimizing over A, B, C and deriving H = 1 - (A + B + C).
# To enforce hardener bounds [0.2, 0.5], we constrain A+B+C to be within [0.5, 0.8].
ax_client.create_experiment(
    parameters=[
        {"name": "resin_A_fraction", "type": "range", "bounds": [0.1, 0.4]},
        {"name": "resin_B_fraction", "type": "range", "bounds": [0.1, 0.4]},
        {"name": "resin_C_fraction", "type": "range", "bounds": [0.1, 0.4]},
    ],
    objectives={
        bond_strength_metric: ObjectiveProperties(minimize=False),
        cure_time_metric: ObjectiveProperties(minimize=True),
    },
    parameter_constraints=[
        "resin_A_fraction + resin_B_fraction + resin_C_fraction <= 0.8",
        "-resin_A_fraction - resin_B_fraction - resin_C_fraction <= -0.5",
    ],
)

# Run optimization loop with a budget of 40 batches
NUM_TRIALS = 40
for _ in range(NUM_TRIALS):
    parameters, trial_index = ax_client.get_next_trial()

    A = float(parameters["resin_A_fraction"])
    B = float(parameters["resin_B_fraction"])
    C = float(parameters["resin_C_fraction"])
    H = float(TOTAL_COMPOSITION - (A + B + C))  # derived to satisfy composition constraint

    results = evaluate_adhesive_formulation(A, B, C, H)
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)

# Retrieve Pareto-optimal parameterizations as identified by Ax (not used for plotting)
pareto_params = ax_client.get_pareto_optimal_parameters(use_model_predictions=False)

# Prepare data for visualization
df = ax_client.get_trials_data_frame()
# Keep only completed observations with both metrics present
df = df.dropna(subset=[bond_strength_metric, cure_time_metric])

# Compute observed hardener fraction for display
if {"resin_A_fraction", "resin_B_fraction", "resin_C_fraction"}.issubset(df.columns):
    df["hardener_fraction"] = TOTAL_COMPOSITION - (
        df["resin_A_fraction"] + df["resin_B_fraction"] + df["resin_C_fraction"]
    )

# Compute Pareto front from observed data
strength_vals = df[bond_strength_metric].to_numpy(dtype=float)
time_vals = df[cure_time_metric].to_numpy(dtype=float)
pareto_mask = compute_pareto_mask(strength_vals, time_vals)

pareto_df = df.loc[pareto_mask, [bond_strength_metric, cure_time_metric]].copy()
pareto_df = pareto_df.sort_values(bond_strength_metric)

# Plot results
fig, ax = plt.subplots(figsize=(7, 5), dpi=150)
ax.scatter(
    df[bond_strength_metric],
    df[cure_time_metric],
    fc="None",
    ec="k",
    label="Observed",
)
ax.plot(
    pareto_df[bond_strength_metric],
    pareto_df[cure_time_metric],
    color="#0033FF",
    lw=2,
    label="Observed Pareto Front",
)
ax.set_xlabel(f"{bond_strength_metric} (MPa)")
ax.set_ylabel(f"{cure_time_metric} (hours)")
ax.set_title("Adhesive Formulation Optimization: Strength vs. Cure Time")
ax.legend()
plt.tight_layout()
plt.show()