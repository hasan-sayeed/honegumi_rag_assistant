# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from ax.service.ax_client import AxClient, ObjectiveProperties


# Reproducibility seed for the synthetic evaluation stub
RNG = np.random.default_rng(seed=123)


def evaluate_reactor_experiment(temperature_c: float, pressure_bar: float, residence_time_min: float) -> float:
    """Evaluate the chemical reactor run for conversion yield (%).

    This is a realistic, executable stub built on simplified kinetics and selectivity considerations.
    Replace with actual lab integration (instrument readouts, LIMS/API calls) when available.

    Model:
    - First-order kinetics for desired reaction:
        conversion = 1 - exp(-k_eff * t)
        k_eff(T, P) = A * exp(-Ea/(R*T_K)) * (P / P_ref)^beta
    - Selectivity penalty for excessive temperature and overlong residence time:
        s_T is a bell-shaped function peaking near ~115 °C
        s_t penalizes residence times much beyond ~45 min
    - Observational noise added to mimic experimental measurement uncertainty.

    Returns:
        float: conversion_yield in percent [0, 100]
    """
    # Constants
    R = 8.314  # J/(mol*K)
    T_K = temperature_c + 273.15

    # Kinetic parameters for a hypothetical reaction
    A = 2.0e5  # 1/min (pre-exponential factor)
    Ea = 6.5e4  # J/mol (activation energy)
    beta = 0.7  # pressure reaction order (effective)

    # Effective rate constant (1/min)
    k_eff = A * np.exp(-Ea / (R * T_K)) * (pressure_bar / 1.0) ** beta

    # Ideal conversion for first-order kinetics in a PFR or batch
    conversion_fraction = 1.0 - np.exp(-k_eff * max(residence_time_min, 0.0))
    conversion_fraction = np.clip(conversion_fraction, 0.0, 1.0)

    # Selectivity penalties:
    # Temperature selectivity: bell-shaped around ~115 °C (sigma ~ 18 °C)
    s_T = np.exp(-((temperature_c - 115.0) / 18.0) ** 2)

    # Over-long residence time can form byproducts; mild penalty beyond 45 min
    overlong = max(residence_time_min - 45.0, 0.0)
    s_t = np.exp(-(overlong / 20.0) ** 2)

    # Net yield is conversion times selectivity factors
    ideal_yield_fraction = conversion_fraction * s_T * s_t

    # Convert to percentage
    ideal_yield_percent = 100.0 * ideal_yield_fraction

    # Add measurement noise (Gaussian), e.g., ~1.0% absolute noise
    noise_sigma = 1.0
    observed_yield_percent = ideal_yield_percent + RNG.normal(0.0, noise_sigma)

    # Clamp to physical bounds
    observed_yield_percent = float(np.clip(observed_yield_percent, 0.0, 100.0))

    return observed_yield_percent


# Initialize Ax client
ax_client = AxClient()

# Create experiment: maximize conversion_yield (%) over temperature, pressure, residence time
ax_client.create_experiment(
    parameters=[
        {"name": "temperature_c", "type": "range", "bounds": [50.0, 150.0]},
        {"name": "pressure_bar", "type": "range", "bounds": [1.0, 5.0]},
        {"name": "residence_time_min", "type": "range", "bounds": [10.0, 60.0]},
    ],
    objectives={
        "conversion_yield": ObjectiveProperties(minimize=False),
    },
)

# Run optimization for the allotted budget (35 experiments)
n_trials = 35
for i in range(n_trials):
    parameterization, trial_index = ax_client.get_next_trial()

    # Extract parameters
    temperature_c = parameterization["temperature_c"]
    pressure_bar = parameterization["pressure_bar"]
    residence_time_min = parameterization["residence_time_min"]

    # Evaluate experiment (replace with actual lab measurement call when available)
    yield_percent = evaluate_reactor_experiment(
        temperature_c=temperature_c,
        pressure_bar=pressure_bar,
        residence_time_min=residence_time_min,
    )

    # Report result back to Ax (noisy observation as a single value)
    ax_client.complete_trial(trial_index=trial_index, raw_data=yield_percent)

# Retrieve best found parameters and corresponding metric
best_parameters, best_metrics = ax_client.get_best_parameters()
print("Best parameters found:")
for k, v in best_parameters.items():
    print(f"  {k}: {v}")

print("\nBest observed conversion_yield:")
for metric_name, metric_values in best_metrics.items():
    # metric_values is a dict with keys like "mean", "sem"
    mean_val = metric_values.get("mean", None)
    sem_val = metric_values.get("sem", None)
    if mean_val is not None:
        if sem_val is not None:
            print(f"  {metric_name}: {mean_val:.2f} % (SEM: {sem_val:.2f})")
        else:
            print(f"  {metric_name}: {mean_val:.2f} %")
    else:
        print(f"  {metric_name}: {metric_values}")

# Plot results
obj_name = ax_client.objective_names[0]
df = ax_client.get_trials_data_frame()

fig, ax = plt.subplots(figsize=(7, 4), dpi=150)
ax.scatter(df.index, df[obj_name], ec="k", fc="none", label="Observed")
ax.plot(
    df.index,
    np.maximum.accumulate(df[obj_name].values),
    color="#0033FF",
    lw=2,
    label="Best to Trial",
)
ax.set_xlabel("Trial Number")
ax.set_ylabel(f"{obj_name} (%)")
ax.set_title("Reactor Optimization: Conversion Yield over Trials")
ax.legend()
plt.tight_layout()
plt.show()