# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


obj1_name = "branin"


def branin(x1, x2):
    y = float(
        (x2 - 5.1 / (4 * np.pi**2) * x1**2 + 5.0 / np.pi * x1 - 6.0) ** 2
        + 10 * (1 - 1.0 / (8 * np.pi)) * np.cos(x1)
        + 10
    )

    return y


ax_client = AxClient()

ax_client.create_experiment(
    parameters=[
        {"name": "x1", "type": "range", "bounds": [-5.0, 10.0]},
        {"name": "x2", "type": "range", "bounds": [0.0, 10.0]},
    ],
    objectives={
        obj1_name: ObjectiveProperties(minimize=True),
    },
)


for i in range(19):

    parameterization, trial_index = ax_client.get_next_trial()

    # extract parameters
    x1 = parameterization["x1"]
    x2 = parameterization["x2"]

    results = branin(x1, x2)
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)

best_parameters, metrics = ax_client.get_best_parameters()


# Plot results
objectives = ax_client.objective_names
df = ax_client.get_trials_data_frame()

fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
ax.scatter(df.index, df[objectives], ec="k", fc="none", label="Observed")
ax.plot(
    df.index,
    np.minimum.accumulate(df[objectives]),
    color="#0033FF",
    lw=2,
    label="Best to Trial",
)
ax.set_xlabel("Trial Number")
ax.set_ylabel(objectives[0])

ax.legend()
plt.show()

# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from typing import Dict, Tuple

from ax.service.ax_client import AxClient, ObjectiveProperties


# Problem: Optimize bioreactor conditions (temperature, pH, agitation) to maximize protein yield (g/L)
# Budget: 30 sequential fermentation runs (batch size = 1). Measurements are noisy (biological variability).


RNG = np.random.default_rng(seed=42)


def evaluate_bioreactor_run(temperature_c: float, ph: float, agitation_rpm: float) -> Dict[str, Tuple[float, float]]:
    """
    Evaluate protein yield (g/L) for given bioreactor conditions.
    This function simulates an experimental response with realistic trends and measurement noise.

    Replace this stub with actual experimental measurement integration, for example:
    - Run a bioreactor experiment with the specified settings and measure titer (g/L).
    - Aggregate replicate measurements and compute SEM.
    - Return {"protein_yield_g_per_l": (mean_yield, sem_yield)}.

    Parameters
    ----------
    temperature_c : float
        Temperature in degrees Celsius (25–37 °C).
    ph : float
        pH (6.0–8.0).
    agitation_rpm : float
        Agitation speed in rpm (100–400).

    Returns
    -------
    Dict[str, Tuple[float, float]]
        Mapping from metric name to (mean, sem), where sem reflects measurement noise.
    """
    # Define a smooth response surface with a single broad optimum and interactions.
    # Peak around: 33 °C, pH 7.0, 250 rpm.
    t_opt, ph_opt, ag_opt = 33.0, 7.0, 250.0

    # Characteristic widths for Gaussian-like sensitivity
    t_sigma, ph_sigma, ag_sigma = 3.0, 0.25, 80.0

    # Base peak amplitude (typical mature process might be in single-digit g/L)
    base_peak = 8.5

    # Gaussian components around the optima
    t_term = np.exp(-0.5 * ((temperature_c - t_opt) / t_sigma) ** 2)
    ph_term = np.exp(-0.5 * ((ph - ph_opt) / ph_sigma) ** 2)
    ag_term = np.exp(-0.5 * ((agitation_rpm - ag_opt) / ag_sigma) ** 2)

    # Interaction term to encourage balanced settings
    interaction = 0.3 + 0.7 * (t_term * ph_term * ag_term)

    # Mild penalty for combinations pushing shear or denaturation (high T + high agitation)
    shear_penalty = 0.1 * np.exp(
        -0.5 * ((temperature_c - 36.0) / 1.5) ** 2
    ) * np.exp(-0.5 * ((agitation_rpm - 380.0) / 30.0) ** 2)

    # Compute noiseless yield
    noiseless_yield = base_peak * t_term * ph_term * ag_term * interaction - shear_penalty

    # Add a small baseline and clip to non-negative yields
    noiseless_yield = max(0.0, float(noiseless_yield + 0.1))

    # Measurement noise (biological variability), assume ~0.4 g/L SD for single run
    noise_sd = 0.4
    measured_yield = float(noiseless_yield + RNG.normal(0.0, noise_sd))

    # Prevent negative measured values after noise
    measured_yield = max(0.0, measured_yield)

    # With a single replicate, SEM ~ SD
    sem = float(noise_sd)

    return {"protein_yield_g_per_l": (measured_yield, sem)}


# Initialize Ax client and define experiment
ax_client = AxClient(random_seed=123)

ax_client.create_experiment(
    name="bioreactor_protein_yield_optimization",
    parameters=[
        {
            "name": "temperature_c",
            "type": "range",
            "bounds": [25.0, 37.0],
            "value_type": "float",
        },
        {
            "name": "ph",
            "type": "range",
            "bounds": [6.0, 8.0],
            "value_type": "float",
        },
        {
            "name": "agitation_rpm",
            "type": "range",
            "bounds": [100.0, 400.0],
            "value_type": "float",
        },
    ],
    objectives={
        "protein_yield_g_per_l": ObjectiveProperties(minimize=False),
    },
    # No constraints specified
    # Single-task, single-objective, default GP modeling
)

# Optimization loop (sequential, budget = 30 trials)
N_TRIALS = 30
for _ in range(N_TRIALS):
    parameterization, trial_index = ax_client.get_next_trial()

    temperature_c = float(parameterization["temperature_c"])
    ph = float(parameterization["ph"])
    agitation_rpm = float(parameterization["agitation_rpm"])

    # Evaluate and report results to Ax
    try:
        results = evaluate_bioreactor_run(temperature_c, ph, agitation_rpm)
        ax_client.complete_trial(trial_index=trial_index, raw_data=results)
    except Exception as e:
        # In case an experimental run fails, mark the trial as failed
        ax_client.log_trial_failure(trial_index=trial_index)
        print(f"Trial {trial_index} failed with error: {e}")

# Retrieve best found parameters and corresponding metrics
best_parameters, best_values = ax_client.get_best_parameters()
print("Best parameters found:")
print(best_parameters)
print("\nBest observed metrics:")
print(best_values)

# Visualize observed yields over trials and best-so-far curve
objective_name = ax_client.objective_names[0]
df = ax_client.get_trials_data_frame()

# Ensure we only plot completed trials with observed data
if objective_name in df.columns:
    y_series = df[objective_name].astype(float)
else:
    # If the data frame uses a multi-index or different naming, fallback to extracting from metrics columns
    metric_cols = [c for c in df.columns if "protein_yield_g_per_l" in str(c)]
    if len(metric_cols) == 0:
        raise RuntimeError("Could not find protein_yield_g_per_l in trials data frame.")
    y_series = df[metric_cols[0]].astype(float)

fig, ax = plt.subplots(figsize=(7, 4), dpi=150)
ax.scatter(df.index, y_series, ec="k", fc="none", label="Observed yield (g/L)")
ax.plot(df.index, np.maximum.accumulate(y_series), color="#0033FF", lw=2, label="Best so far")
ax.set_xlabel("Trial Number")
ax.set_ylabel("Protein yield (g/L)")
ax.set_title("Bioreactor optimization: protein yield over trials")
ax.legend()
plt.tight_layout()
plt.show()