# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from typing import Dict
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


# Domain-specific metric names
TEXTURE_METRIC = "texture_score"
TASTE_METRIC = "taste_score"

# Compositional total to ensure feasibility with provided per-ingredient bounds.
# With the given bounds, a feasible equality sum must be in [37, 88].
# We set total to 80 so that flavoring stays within its [2, 8] bounds via linear constraints below.
TOTAL_COMPOSITION = 80.0  # percent by weight of the four optimized ingredients


_rng = np.random.default_rng(seed=42)


def evaluate_food_formulation(
    protein_pct: float,
    sweetener_pct: float,
    binder_pct: float,
    flavoring_pct: float,
) -> Dict[str, float]:
    """
    Simulated evaluation of a multi-objective food formulation.

    Inputs are percentages by weight for a 100 g reference product (units: %).
    This stub simulates:
      - texture_score: driven mainly by protein-binder matrix formation,
                       with synergy between protein and binder and a mild penalty
                       for excessive sweetener/flavoring.
      - taste_score: driven mainly by sweetener and flavoring, with penalties for
                     overly high protein (chalkiness) and binder (gumminess).

    Both scores are clipped to [1, 10] and include small Gaussian noise to emulate
    measurement variability. Replace this with actual lab measurements as needed.
    """
    # Ideal targets (in percent) for a hypothetical product profile
    protein_opt = 30.0
    binder_opt = 18.0
    sweetener_opt = 11.0
    flavoring_opt = 5.0

    # Texture model (Gaussian preferences + synergy + mild penalties)
    prot_term = np.exp(-((protein_pct - protein_opt) ** 2) / (2 * 8.0**2))
    bind_term = np.exp(-((binder_pct - binder_opt) ** 2) / (2 * 5.0**2))
    synergy = np.exp(-((binder_pct - 0.55 * protein_pct) ** 2) / (2 * 4.0**2))

    # Mild penalty for too much sweetener/flavoring on texture
    sweetness_pen = np.exp(-((sweetener_pct - 8.0) ** 2) / (2 * 6.0**2))
    flavor_pen = np.exp(-((flavoring_pct - 4.0) ** 2) / (2 * 2.5**2))

    texture_raw = 10.0 * (0.45 * prot_term + 0.35 * bind_term + 0.15 * synergy + 0.05 * (0.5 * sweetness_pen + 0.5 * flavor_pen))
    texture_noise = _rng.normal(0.0, 0.25)
    texture_score = float(np.clip(texture_raw + texture_noise, 1.0, 10.0))

    # Taste model (preferences for sweetness and flavoring + penalties)
    sweet_pref = np.exp(-((sweetener_pct - sweetener_opt) ** 2) / (2 * 3.5**2))
    flavor_pref = np.exp(-((flavoring_pct - flavoring_opt) ** 2) / (2 * 1.5**2))
    protein_penalty = np.exp(-((protein_pct - 24.0) ** 2) / (2 * 10.0**2))  # prefer moderate protein for taste
    binder_penalty = np.exp(-((binder_pct - 14.0) ** 2) / (2 * 7.0**2))     # prefer moderate binder for palatability

    taste_raw = 10.0 * (0.5 * sweet_pref + 0.35 * flavor_pref + 0.075 * protein_penalty + 0.075 * binder_penalty)
    taste_noise = _rng.normal(0.0, 0.25)
    taste_score = float(np.clip(taste_raw + taste_noise, 1.0, 10.0))

    return {TEXTURE_METRIC: texture_score, TASTE_METRIC: taste_score}


ax_client = AxClient()

# We parameterize three ingredients directly and compute flavoring as the remainder to meet
# the compositional total. Linear sum constraints ensure flavoring stays in its bounds [2, 8].
ax_client.create_experiment(
    parameters=[
        {"name": "protein_pct", "type": "range", "bounds": [20.0, 40.0]},   # %
        {"name": "sweetener_pct", "type": "range", "bounds": [5.0, 15.0]},  # %
        {"name": "binder_pct", "type": "range", "bounds": [10.0, 25.0]},    # %
    ],
    objectives={
        TEXTURE_METRIC: ObjectiveProperties(minimize=False),
        TASTE_METRIC: ObjectiveProperties(minimize=False),
    },
    parameter_constraints=[
        # Enforce flavoring_pct = TOTAL_COMPOSITION - (protein + sweetener + binder)
        # and keep flavoring within [2, 8] using linear constraints on the sum.
        # flavoring >= 2  -> protein + sweetener + binder <= TOTAL_COMPOSITION - 2
        f"protein_pct + sweetener_pct + binder_pct <= {TOTAL_COMPOSITION - 2.0}",
        # flavoring <= 8  -> protein + sweetener + binder >= TOTAL_COMPOSITION - 8
        f"-protein_pct - sweetener_pct - binder_pct <= {- (TOTAL_COMPOSITION - 8.0)}",
    ],
)

# Optimization budget (number of experimental trials to evaluate)
NUM_TRIALS = 35

for _ in range(NUM_TRIALS):
    parameterization, trial_index = ax_client.get_next_trial()

    protein = float(parameterization["protein_pct"])
    sweetener = float(parameterization["sweetener_pct"])
    binder = float(parameterization["binder_pct"])
    flavoring = TOTAL_COMPOSITION - (protein + sweetener + binder)

    results = evaluate_food_formulation(
        protein_pct=protein,
        sweetener_pct=sweetener,
        binder_pct=binder,
        flavoring_pct=flavoring,
    )
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)

# Retrieve Pareto-optimal trials based on observed data
pareto = ax_client.get_pareto_optimal_parameters(use_model_predictions=False)

# Plot results
objectives = ax_client.objective_names
df = ax_client.get_trials_data_frame()

fig, ax = plt.subplots(figsize=(6, 4), dpi=150)

# Scatter all observed trials
ax.scatter(df[objectives[0]], df[objectives[1]], fc="None", ec="k", label="Observed")

# Extract and plot the empirical Pareto front
pareto_data = [p[1][0] for p in pareto.values()]
pareto_df = pd.DataFrame(pareto_data).sort_values(objectives[0])
ax.plot(
    pareto_df[objectives[0]],
    pareto_df[objectives[1]],
    color="#0033FF",
    lw=2,
    label="Pareto Front",
)

ax.set_xlabel(objectives[0])
ax.set_ylabel(objectives[1])
ax.set_title("Multi-objective Optimization of Food Formulation")
ax.legend()
plt.tight_layout()
plt.show()