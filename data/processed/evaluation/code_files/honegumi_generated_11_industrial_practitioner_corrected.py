# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from typing import Tuple, Dict, Any
from ax.service.ax_client import AxClient, ObjectiveProperties


# ------------------------------------------------------------------------------
# MAX phase discovery for electronics
# Objective: maximize electrical conductivity (S/m)
# Parameters (compositional features):
#   - electronegativity (Pauling scale)              [dimensionless]
#   - atomic_radius_angstrom (Å)                     [Å]
#   - formation_energy_eV_per_atom (eV/atom)         [eV/atom]
#
# Experimental setup:
#   - Historical measurements: 20
#   - Budget (total syntheses): 30
#   - Batch size: 1 (sequential optimization)
#   - No explicit constraints
#   - Noisy measurements (we report mean and SEM)
# ------------------------------------------------------------------------------

# Reproducibility
RNG = np.random.default_rng(42)

# Define realistic bounds for the compositional features
ELECTRONEGATIVITY_BOUNDS = (0.7, 3.5)           # Pauling scale (dimensionless)
ATOMIC_RADIUS_BOUNDS = (1.0, 1.8)               # Å
FORMATION_ENERGY_BOUNDS = (-3.0, 0.5)           # eV/atom (more negative -> more stable)

# Objective (metric) name
CONDUCTIVITY_METRIC = "conductivity"            # S/m


def measure_synthetic_conductivity(
    electronegativity: float,
    atomic_radius_angstrom: float,
    formation_energy_eV_per_atom: float,
    rng: np.random.Generator = RNG,
) -> Tuple[float, float]:
    """
    Synthetic but domain-inspired model of electrical conductivity for MAX phases.

    This function simulates a plausible relationship between compositional features and
    conductivity. It includes a stability term (favoring more negative formation energies),
    resonance peaks around typical metallic bonding characteristics, and observation noise.

    IMPORTANT:
      - Replace this stub with actual experimental measurement or a high-fidelity simulator.
      - The function must return (mean, sem) for the objective metric.

    Returns:
      mean_conductivity_s_per_m: float, measured mean conductivity in S/m
      sem_conductivity_s_per_m: float, standard error of the mean (SEM) in S/m
    """

    # Normalize features to [0, 1] within their bounds for shaping terms
    def normalize(val: float, lo: float, hi: float) -> float:
        return (val - lo) / (hi - lo)

    en = np.clip(electronegativity, *ELECTRONEGATIVITY_BOUNDS)
    ar = np.clip(atomic_radius_angstrom, *ATOMIC_RADIUS_BOUNDS)
    fe = np.clip(formation_energy_eV_per_atom, *FORMATION_ENERGY_BOUNDS)

    en_n = normalize(en, *ELECTRONEGATIVITY_BOUNDS)  # 0..1
    ar_n = normalize(ar, *ATOMIC_RADIUS_BOUNDS)      # 0..1
    fe_n = normalize(fe, *FORMATION_ENERGY_BOUNDS)   # 0..1, 0 => -3.0 (stable), 1 => 0.5 (unstable)

    # Baseline scale (S/m), typical metals ~1e7 S/m; MAX phases can be high but variable
    baseline = 1.0e6

    # Favor more negative formation energy (stability)
    stability_term = 3.0e6 * (1.0 - fe_n) ** 1.5  # higher when fe is more negative

    # Electronegativity "sweet spot" around ~2.0 Pauling for metallic bonding character
    en_opt = 2.0
    en_sigma = 0.35
    en_term = 2.0e6 * np.exp(-((en - en_opt) ** 2) / (2 * en_sigma**2))

    # Atomic radius preference around ~1.35 Å (packing/overlap heuristic)
    ar_opt = 1.35
    ar_sigma = 0.12
    ar_term = 1.5e6 * np.exp(-((ar - ar_opt) ** 2) / (2 * ar_sigma**2))

    # Weak interaction term: coupling between en and ar
    interaction_center = 0.55 + 0.25 * (1.0 - fe_n)  # shifts with stability
    interaction_strength = 1.0e6 * np.exp(-((en_n - interaction_center) ** 2) / (2 * 0.12**2))
    interaction_strength *= np.exp(-((ar_n - 0.45) ** 2) / (2 * 0.18**2))

    # Combine deterministic components
    deterministic = baseline + stability_term + en_term + ar_term + interaction_strength

    # Add heteroscedastic observation noise (mean 0, std depends on magnitude)
    noise_std = 1.0e5 + 0.03 * deterministic
    observed = deterministic + rng.normal(0.0, noise_std)

    # SEM estimate (e.g., 3% of measured magnitude plus floor)
    sem = 2.0e4 + 0.02 * abs(observed)

    # Ensure physically non-negative conductivity
    mean_conductivity = float(max(observed, 1.0e3))
    sem_conductivity = float(max(sem, 1.0e3))
    return mean_conductivity, sem_conductivity


def sample_historical_feature_dataframe(
    n: int,
    rng: np.random.Generator = RNG,
) -> pd.DataFrame:
    """
    Create a synthetic historical dataset of compositional features.
    Each row is one historical synthesis with averaged/engineered features.
    """
    en_vals = rng.uniform(*ELECTRONEGATIVITY_BOUNDS, size=n)
    ar_vals = rng.uniform(*ATOMIC_RADIUS_BOUNDS, size=n)
    fe_vals = rng.uniform(*FORMATION_ENERGY_BOUNDS, size=n)

    return pd.DataFrame(
        {
            "electronegativity": en_vals,
            "atomic_radius_angstrom": ar_vals,
            "formation_energy_eV_per_atom": fe_vals,
        }
    )


def main() -> None:
    # Problem/budget setup
    n_historical = 20
    total_budget = 30
    n_new_trials = total_budget - n_historical
    assert n_new_trials >= 0, "Total budget must be >= number of historical points."

    # Generate synthetic historical data (replace with your real measurements if available)
    X_hist = sample_historical_feature_dataframe(n_historical, rng=RNG)

    ax_client = AxClient()

    # Create experiment with a single objective: maximize conductivity
    ax_client.create_experiment(
        name="max_phase_conductivity_optimization",
        parameters=[
            {
                "name": "electronegativity",
                "type": "range",
                "bounds": list(ELECTRONEGATIVITY_BOUNDS),
            },
            {
                "name": "atomic_radius_angstrom",
                "type": "range",
                "bounds": list(ATOMIC_RADIUS_BOUNDS),
            },
            {
                "name": "formation_energy_eV_per_atom",
                "type": "range",
                "bounds": list(FORMATION_ENERGY_BOUNDS),
            },
        ],
        objectives={
            CONDUCTIVITY_METRIC: ObjectiveProperties(minimize=False),
        },
        tracking_metric_names=[CONDUCTIVITY_METRIC],
    )

    # Attach historical measurements
    for i in range(n_historical):
        params: Dict[str, Any] = X_hist.iloc[i].to_dict()
        mean, sem = measure_synthetic_conductivity(**params, rng=RNG)
        trial_index = ax_client.attach_trial(params)
        ax_client.complete_trial(trial_index=trial_index, raw_data=(mean, sem))

    # Sequential Bayesian optimization for remaining budget
    for _ in range(n_new_trials):
        parameterization, trial_index = ax_client.get_next_trial()
        mean, sem = measure_synthetic_conductivity(**parameterization, rng=RNG)
        ax_client.complete_trial(trial_index=trial_index, raw_data=(mean, sem))

    # Retrieve best found parameters and their observed performance
    best_parameters, best_metrics = ax_client.get_best_parameters()
    best_mean = best_metrics[CONDUCTIVITY_METRIC]["mean"]
    best_sem = best_metrics[CONDUCTIVITY_METRIC]["sem"]
    print("Best parameters found:")
    for k, v in best_parameters.items():
        print(f"  {k}: {v:.6g}")
    print(f"Best observed {CONDUCTIVITY_METRIC} = {best_mean:.6g} S/m (SEM={best_sem:.3g})")

    # Visualization: objective trace over trials
    df = ax_client.get_trials_data_frame()
    if CONDUCTIVITY_METRIC in df.columns:
        y = df[CONDUCTIVITY_METRIC].to_numpy()
        x = np.arange(len(y))
        best_so_far = np.maximum.accumulate(y)

        fig, ax = plt.subplots(figsize=(7, 4), dpi=150)
        ax.scatter(x, y, ec="k", fc="none", label="Observed")
        ax.plot(x, best_so_far, color="#0033FF", lw=2, label="Best so far")
        ax.set_xlabel("Trial Number")
        ax.set_ylabel(f"{CONDUCTIVITY_METRIC} (S/m)")
        ax.set_title("MAX Phase Conductivity Optimization")
        ax.legend()
        plt.tight_layout()
        plt.show()
    else:
        # Fallback: print if the expected metric column is missing
        print("Warning: Could not find conductivity column in trials data frame for plotting.")


if __name__ == "__main__":
    main()