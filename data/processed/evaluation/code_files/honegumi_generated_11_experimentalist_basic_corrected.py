# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import os
import numpy as np
import pandas as pd
from typing import Dict, Tuple
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


# Domain-specific objective and parameters for MAX phase electrical conductivity optimization
objective_name = "electrical_conductivity"  # Units: S/m

# Parameter bounds (domain-informed; adjust if you have tighter priors)
# - M_site_electronegativity: Pauling scale for common M elements in MAX phases (approx. 1.0–2.3)
# - A_site_atomic_radius: covalent radius for A elements (Å; approx. 1.0–1.6)
# - X_site_covalent_radius: covalent radius for X = C or N (Å; approx. 0.65–0.85)
# - formation_energy: eV/atom; more negative implies more stable (approx. -2.0–0.5)
PARAM_BOUNDS: Dict[str, Tuple[float, float]] = {
    "M_site_electronegativity": (1.0, 2.3),      # Pauling
    "A_site_atomic_radius": (1.0, 1.6),          # Å
    "X_site_covalent_radius": (0.65, 0.85),      # Å
    "formation_energy": (-2.0, 0.5),             # eV/atom
}

# Budget: 30 new syntheses
NEW_TRIAL_BUDGET = 30

# Historical database size (if no CSV is provided, we will synthesize 20 initial data points)
HISTORICAL_COUNT = 20

# Optional: If you have historical data, place a CSV named "historical_max_phase_data.csv"
# with columns:
#   M_site_electronegativity, A_site_atomic_radius, X_site_covalent_radius, formation_energy,
#   electrical_conductivity[, electrical_conductivity_sem]
HISTORICAL_CSV = "historical_max_phase_data.csv"


def evaluate_max_phase_conductivity(
    M_site_electronegativity: float,
    A_site_atomic_radius: float,
    X_site_covalent_radius: float,
    formation_energy: float,
    rng: np.random.Generator = np.random.default_rng(),
) -> Tuple[float, float]:
    """
    Domain-inspired surrogate to simulate measured electrical conductivity (S/m).
    Replace this function with real experimental measurement or a physics-based simulator.

    Inputs:
      - M_site_electronegativity: Pauling scale
      - A_site_atomic_radius: Å
      - X_site_covalent_radius: Å
      - formation_energy: eV/atom (more negative = more stable)

    Returns:
      - mean_conductivity (S/m)
      - sem_conductivity (S/m)  approximate standard error of the mean measurement

    Notes on the surrogate:
      - Peaks near known good regions for MAX phases:
          M electronegativity ~ 1.7–1.9
          A atomic radius ~ 1.30–1.40 Å
          X covalent radius ~ 0.74–0.76 Å (between N and C)
          formation energy more negative is beneficial
      - Includes smooth interactions and heteroskedastic noise.
    """

    # Gaussian-like preferences around empirically reasonable targets
    m_peak = np.exp(-((M_site_electronegativity - 1.8) / 0.28) ** 2)
    a_peak = np.exp(-((A_site_atomic_radius - 1.35) / 0.13) ** 2)
    x_peak = np.exp(-((X_site_covalent_radius - 0.75) / 0.05) ** 2)

    # Formation energy contribution: more negative = higher score via logistic mapping
    fe_score = 1.0 / (1.0 + np.exp((formation_energy + 0.3) / 0.25))  # 0..1

    # Interaction terms that reward synergistic combinations
    mx_interaction = np.exp(-((M_site_electronegativity - 1.85) / 0.22) ** 2 - ((X_site_covalent_radius - 0.76) / 0.04) ** 2)
    ax_interaction = np.exp(-((A_site_atomic_radius - 1.32) / 0.10) ** 2 - ((X_site_covalent_radius - 0.74) / 0.05) ** 2)

    # Combine contributions into a conductivity estimate (S/m), scaled to a plausible range for MAX phases
    # Base scale ~ 1e6–1e7 S/m for highly conductive ceramics/carbides; this is illustrative.
    base = 0.6e6
    peak_terms = 2.0e6 * m_peak + 1.5e6 * a_peak + 2.0e6 * x_peak
    fe_term = 1.8e6 * fe_score
    interaction_terms = 1.2e6 * mx_interaction + 0.8e6 * ax_interaction

    deterministic_conductivity = base + peak_terms + fe_term + interaction_terms

    # Small penalties for out-of-ideal regions to shape smoother landscape
    penalty = 2.0e5 * max(0.0, M_site_electronegativity - 2.2) + 1.5e5 * max(0.0, 1.05 - A_site_atomic_radius)
    deterministic_conductivity = max(5.0e4, deterministic_conductivity - penalty)

    # Heteroskedastic measurement noise (5% relative + absolute floor)
    noise_sd = 0.05 * deterministic_conductivity + 1.0e4
    measured = deterministic_conductivity + rng.normal(0.0, noise_sd)

    # Ensure physical non-negativity
    measured = float(max(1.0e4, measured))

    # Standard error of the mean (could be from repeated measurements; here a proxy)
    sem = float(noise_sd / np.sqrt(3.0))  # assume triplicate measurement equivalent

    return measured, sem


def load_or_generate_historical_data(
    csv_path: str,
    param_bounds: Dict[str, Tuple[float, float]],
    n: int,
    seed: int = 123,
) -> pd.DataFrame:
    """
    Load historical MAX phase data from CSV or generate synthetic seed data.

    CSV expected columns:
      - Parameters: M_site_electronegativity, A_site_atomic_radius, X_site_covalent_radius, formation_energy
      - Metrics: electrical_conductivity[, electrical_conductivity_sem]

    Generated data will use the surrogate evaluation for realism.
    """
    if os.path.exists(csv_path):
        df = pd.read_csv(csv_path)
        required_params = list(param_bounds.keys())
        if not all(col in df.columns for col in required_params + [objective_name]):
            missing = set(required_params + [objective_name]) - set(df.columns)
            raise ValueError(f"Historical CSV missing required columns: {missing}")
        # Ensure SEM exists; if not, approximate a small SEM
        if f"{objective_name}_sem" not in df.columns:
            df[f"{objective_name}_sem"] = 0.05 * df[objective_name].astype(float) + 1.0e4
        return df[required_params + [objective_name, f"{objective_name}_sem"]].copy()

    # Generate synthetic historical data
    rng = np.random.default_rng(seed)
    samples = []
    for _ in range(n):
        params = {
            name: rng.uniform(low, high)
            for name, (low, high) in param_bounds.items()
        }
        mean_val, sem_val = evaluate_max_phase_conductivity(
            M_site_electronegativity=params["M_site_electronegativity"],
            A_site_atomic_radius=params["A_site_atomic_radius"],
            X_site_covalent_radius=params["X_site_covalent_radius"],
            formation_energy=params["formation_energy"],
            rng=rng,
        )
        row = dict(params)
        row[objective_name] = mean_val
        row[f"{objective_name}_sem"] = sem_val
        samples.append(row)
    return pd.DataFrame(samples)


def main() -> None:
    # Prepare historical data (20 seed points by default)
    historical_df = load_or_generate_historical_data(
        csv_path=HISTORICAL_CSV,
        param_bounds=PARAM_BOUNDS,
        n=HISTORICAL_COUNT,
        seed=42,
    )

    # Initialize Ax client and experiment
    ax_client = AxClient()

    ax_client.create_experiment(
        name="max_phase_electrical_conductivity_optimization",
        parameters=[
            {
                "name": "M_site_electronegativity",
                "type": "range",
                "bounds": list(PARAM_BOUNDS["M_site_electronegativity"]),
            },
            {
                "name": "A_site_atomic_radius",
                "type": "range",
                "bounds": list(PARAM_BOUNDS["A_site_atomic_radius"]),
            },
            {
                "name": "X_site_covalent_radius",
                "type": "range",
                "bounds": list(PARAM_BOUNDS["X_site_covalent_radius"]),
            },
            {
                "name": "formation_energy",
                "type": "range",
                "bounds": list(PARAM_BOUNDS["formation_energy"]),
            },
        ],
        objectives={
            objective_name: ObjectiveProperties(minimize=False),
        },
        overwrite_existing_experiment=True,
    )

    # Attach historical trials
    for i, row in historical_df.iterrows():
        parameterization = {
            "M_site_electronegativity": float(row["M_site_electronegativity"]),
            "A_site_atomic_radius": float(row["A_site_atomic_radius"]),
            "X_site_covalent_radius": float(row["X_site_covalent_radius"]),
            "formation_energy": float(row["formation_energy"]),
        }
        ax_client.attach_trial(parameterization)
        ax_client.complete_trial(
            trial_index=i,
            raw_data={
                objective_name: (
                    float(row[objective_name]),
                    float(row[f"{objective_name}_sem"]),
                )
            },
        )

    # Optimization loop for 30 new syntheses
    rng = np.random.default_rng(2025)
    for _ in range(NEW_TRIAL_BUDGET):
        parameterization, trial_index = ax_client.get_next_trial()

        # Evaluate the new suggestion (replace with real experiment or simulation call)
        mean_val, sem_val = evaluate_max_phase_conductivity(
            M_site_electronegativity=float(parameterization["M_site_electronegativity"]),
            A_site_atomic_radius=float(parameterization["A_site_atomic_radius"]),
            X_site_covalent_radius=float(parameterization["X_site_covalent_radius"]),
            formation_energy=float(parameterization["formation_energy"]),
            rng=rng,
        )

        ax_client.complete_trial(
            trial_index=trial_index,
            raw_data={objective_name: (mean_val, sem_val)},
        )

    # Retrieve best parameters and metrics
    best_parameters, best_metrics = ax_client.get_best_parameters()
    print("Best parameters found:")
    for k, v in best_parameters.items():
        print(f"  {k}: {v:.6g}")
    print("Best observed electrical conductivity (S/m):")
    for metric, val in best_metrics.items():
        # val is a dict like {'mean': x, 'sem': y}
        print(f"  {metric}: mean={val['mean']:.6g}, sem={val.get('sem', float('nan')):.6g}")

    # Plot optimization progress
    objectives = ax_client.objective_names  # list with single item
    df = ax_client.get_trials_data_frame()

    # Extract only completed observations with the objective present
    if objectives[0] in df.columns:
        y = df[objectives[0]].astype(float).values
        trial_indices = df.index.values
        best_to_date = np.maximum.accumulate(y)
        fig, ax = plt.subplots(figsize=(7, 4), dpi=150)
        ax.scatter(trial_indices, y, ec="k", fc="none", label="Observed")
        ax.plot(trial_indices, best_to_date, color="#0033FF", lw=2, label="Best so far")
        ax.set_xlabel("Trial Number")
        ax.set_ylabel(f"{objectives[0]} (S/m)")
        ax.set_title("MAX Phase Electrical Conductivity Optimization")
        ax.legend()
        plt.tight_layout()
        plt.show()
    else:
        print("Could not find the objective column in trials data frame for plotting.")


if __name__ == "__main__":
    main()