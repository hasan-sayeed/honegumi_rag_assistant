# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


obj1_name = "branin"
obj2_name = "branin_swapped"


def branin3_moo(x1, x2, x3):
    y = float(
        (x2 - 5.1 / (4 * np.pi**2) * x1**2 + 5.0 / np.pi * x1 - 6.0) ** 2
        + 10 * (1 - 1.0 / (8 * np.pi)) * np.cos(x1)
        + 10
    )

    # Contrived way to incorporate x3 into the objective
    y = y * (1 + 0.1 * x1 * x2 * x3)

    # second objective has x1 and x2 swapped
    y2 = float(
        (x1 - 5.1 / (4 * np.pi**2) * x2**2 + 5.0 / np.pi * x2 - 6.0) ** 2
        + 10 * (1 - 1.0 / (8 * np.pi)) * np.cos(x2)
        + 10
    )

    # Contrived way to incorporate x3 into the second objective
    y2 = y2 * (1 - 0.1 * x1 * x2 * x3)

    return {obj1_name: y, obj2_name: y2}


# Define total for compositional constraint, where x1 + x2 + x3 == total
total = 10.0


ax_client = AxClient()

ax_client.create_experiment(
    parameters=[
        {"name": "x1", "type": "range", "bounds": [0.0, total]},
        {"name": "x2", "type": "range", "bounds": [0.0, total]},
    ],
    objectives={
        obj1_name: ObjectiveProperties(minimize=True),
        obj2_name: ObjectiveProperties(minimize=True),
    },
    parameter_constraints=[
        f"x1 + x2 <= {total}",  # reparameterized compositional constraint, which is a type of sum constraint
    ],
)


for i in range(21):

    parameterization, trial_index = ax_client.get_next_trial()

    # extract parameters
    x1 = parameterization["x1"]
    x2 = parameterization["x2"]
    x3 = total - (x1 + x2)  # composition constraint: x1 + x2 + x3 == total

    results = branin3_moo(x1, x2, x3)
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)
pareto_results = ax_client.get_pareto_optimal_parameters()


# Plot results
objectives = ax_client.objective_names
df = ax_client.get_trials_data_frame()

fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
pareto = ax_client.get_pareto_optimal_parameters(use_model_predictions=False)
pareto_data = [p[1][0] for p in pareto.values()]
pareto = pd.DataFrame(pareto_data).sort_values(objectives[0])

ax.scatter(df[objectives[0]], df[objectives[1]], fc="None", ec="k", label="Observed")
ax.plot(
    pareto[objectives[0]],
    pareto[objectives[1]],
    color="#0033FF",
    lw=2,
    label="Pareto Front",
)
ax.set_xlabel(objectives[0])
ax.set_ylabel(objectives[1])

ax.legend()
plt.show()

# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from typing import Dict, Tuple
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt
import random

# Seed for reproducibility of the synthetic evaluation
np.random.seed(42)
random.seed(42)

# Domain-specific objective names
BOND_STRENGTH = "bond_strength"  # MPa, to maximize
CURE_TIME = "cure_time"          # hours, to minimize

TOTAL_PERCENT = 100.0

def evaluate_adhesive_formulation(resin_1: float, resin_2: float, resin_3: float) -> Dict[str, Tuple[float, float]]:
    """
    Synthetic evaluation of an adhesive formulation with three resins and one hardener.
    The hardener fraction is computed to satisfy the compositional equality constraint:
        resin_1 + resin_2 + resin_3 + hardener = 100%

    Returns a dict of:
      - "bond_strength": (MPa, SEM)
      - "cure_time": (hours, SEM)

    Note: This is a realistic stub for demonstration. Replace the internals with actual
    experimental measurements or a validated simulator if available.
    """
    # Derived hardener (composition constraint)
    hardener = TOTAL_PERCENT - (resin_1 + resin_2 + resin_3)

    # Convert to fractions for modeling
    r1 = resin_1 / 100.0
    r2 = resin_2 / 100.0
    r3 = resin_3 / 100.0
    h = hardener / 100.0

    # Synthetic model for bond strength (MPa)
    # - Peak around a plausible resin/hardener ratio
    # - Mild positive synergy for balanced resins
    # - Penalize extremes
    target = np.array([0.30, 0.25, 0.25, 0.20])  # target fractions: r1, r2, r3, h
    x = np.array([r1, r2, r3, h])
    # Gaussian-like peak around target
    distance2 = np.sum(((x - target) / np.array([0.12, 0.12, 0.12, 0.10])) ** 2)
    strength_peak = 42.0 * np.exp(-2.5 * distance2)

    # Synergy: encourage diversity among resins (balance raises strength)
    balance = 1.0 - np.std([r1, r2, r3]) / 0.15
    synergy = 6.0 * max(0.0, balance)

    # Hardener penalty if outside the ideal 0.18-0.28 window (still feasible by constraints)
    hardener_penalty = -30.0 * max(0.0, abs(h - 0.23) - 0.05)

    # Aggregate bond strength before noise
    bond_strength_true = max(5.0, strength_peak + synergy + hardener_penalty)

    # Synthetic model for cure time (hours)
    # - More hardener speeds cure markedly
    # - Resin_3 (accelerator-like) slightly speeds cure; Resin_1 slightly slows
    base_time = 10.0
    hardener_effect = -28.0 * (h - 0.25)  # faster cure when hardener increases
    resin_effect = 5.0 * (r1 - 0.25) - 6.0 * (r3 - 0.25)
    cure_time_true = max(0.5, base_time + hardener_effect + resin_effect)

    # Add measurement noise (mean observed value) and provide SEM estimates
    bond_strength_noise = np.random.normal(0.0, 0.8)
    cure_time_noise = np.random.normal(0.0, 0.2)

    bond_strength_obs = float(bond_strength_true + bond_strength_noise)
    cure_time_obs = float(max(0.05, cure_time_true + cure_time_noise))

    # Assume we can estimate SEM (constant here; in reality use repeated measures/uncertainty model)
    bond_strength_sem = 0.5
    cure_time_sem = 0.15

    return {
        BOND_STRENGTH: (bond_strength_obs, bond_strength_sem),
        CURE_TIME: (cure_time_obs, cure_time_sem),
    }


def is_dominated(p: Tuple[float, float], others: np.ndarray) -> bool:
    """
    Check if point p = (strength, time) is dominated by any row in others.
    For our objectives: maximize strength, minimize time.
    q dominates p if q_strength >= p_strength and q_time <= p_time, with at least one strict.
    """
    for q_strength, q_time in others:
        if (q_strength >= p[0] and q_time <= p[1]) and (q_strength > p[0] or q_time < p[1]):
            return True
    return False


def compute_pareto_front(points: np.ndarray) -> np.ndarray:
    """
    Compute Pareto front from an array of shape (n, 2) with columns [bond_strength, cure_time].
    Returns subset of points that are non-dominated, sorted by bond_strength ascending (for plotting).
    """
    if points.size == 0:
        return points
    pareto = []
    for i in range(points.shape[0]):
        p = (points[i, 0], points[i, 1])
        others = np.delete(points, i, axis=0)
        if not is_dominated(p, others):
            pareto.append(p)
    pareto_arr = np.array(pareto)
    # Sort for plotting aesthetics: often increasing strength and decreasing time
    order = np.argsort(pareto_arr[:, 0])
    return pareto_arr[order]


def main():
    budget = 40  # number of formulations to evaluate

    ax_client = AxClient()
    ax_client.create_experiment(
        name="adhesive_formulation_optimization",
        parameters=[
            # We parameterize the three resins directly (in percent) and derive hardener as 100 - sum(resins)
            {"name": "resin_1", "type": "range", "bounds": [10.0, 40.0], "value_type": "float"},
            {"name": "resin_2", "type": "range", "bounds": [10.0, 40.0], "value_type": "float"},
            {"name": "resin_3", "type": "range", "bounds": [10.0, 40.0], "value_type": "float"},
        ],
        objectives={
            BOND_STRENGTH: ObjectiveProperties(minimize=False),
            CURE_TIME: ObjectiveProperties(minimize=True),
        },
        # Enforce hardener bounds [20, 50] by constraining sum of resins:
        # hardener = 100 - (r1 + r2 + r3) in [20, 50] -> r1 + r2 + r3 in [50, 80]
        parameter_constraints=[
            "resin_1 + resin_2 + resin_3 >= 50.0",
            "resin_1 + resin_2 + resin_3 <= 80.0",
        ],
        overwrite_existing_experiment=True,
        is_test=True,
    )

    for i in range(budget):
        params, trial_index = ax_client.get_next_trial()

        r1 = float(params["resin_1"])
        r2 = float(params["resin_2"])
        r3 = float(params["resin_3"])
        # Derived hardener (not a parameter of the search space; used in evaluation/reporting)
        hardener = TOTAL_PERCENT - (r1 + r2 + r3)

        results = evaluate_adhesive_formulation(r1, r2, r3)
        ax_client.complete_trial(trial_index=trial_index, raw_data=results)

        print(
            f"Trial {trial_index:02d} | resin_1={r1:.2f}%, resin_2={r2:.2f}%, "
            f"resin_3={r3:.2f}%, hardener={hardener:.2f}% -> "
            f"bond_strength={results[BOND_STRENGTH][0]:.2f} MPa, "
            f"cure_time={results[CURE_TIME][0]:.2f} h"
        )

    # Collect results
    df = ax_client.get_trials_data_frame()
    # Filter to completed observations
    df = df.dropna(subset=[BOND_STRENGTH, CURE_TIME])

    # Compute observed Pareto front
    points = df[[BOND_STRENGTH, CURE_TIME]].to_numpy(dtype=float)
    pareto_points = compute_pareto_front(points)

    # Plot observed data and Pareto front
    fig, ax = plt.subplots(figsize=(7, 5), dpi=150)
    ax.scatter(df[BOND_STRENGTH], df[CURE_TIME], fc="None", ec="gray", label="Observed")

    if pareto_points.size > 0:
        ax.plot(
            pareto_points[:, 0],
            pareto_points[:, 1],
            color="#0033FF",
            lw=2,
            marker="o",
            label="Pareto Front (Observed)",
        )

    ax.set_xlabel("Bond strength (MPa)  [maximize]")
    ax.set_ylabel("Cure time (hours)  [minimize]")
    ax.set_title("Adhesive Formulation Optimization: Strength vs Cure Time")
    ax.grid(True, alpha=0.3)
    ax.legend()
    plt.tight_layout()
    plt.show()

    # Print a few Pareto-optimal formulations (if available)
    if pareto_points.size > 0:
        print("\nPareto-optimal observed points (bond_strength MPa, cure_time h):")
        for s, t in pareto_points:
            print(f"  strength={s:.2f} MPa, cure_time={t:.2f} h")

if __name__ == "__main__":
    main()