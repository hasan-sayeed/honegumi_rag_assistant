# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


objective_name = "power_conversion_efficiency"  # %


# Synthetic evaluator for solar cell efficiency (PCE, %).
# Replace with actual QC measurement integration if available.
_rng = np.random.default_rng(12345)


def evaluate_solar_cell_efficiency(annealing_temperature_celsius: float, deposition_rate_nm_per_s: float) -> float:
    """
    Simulate power conversion efficiency (%) for a solar cell production run.

    This surrogate includes a smooth optimum around realistic process settings,
    plus minor non-convexities and observation noise to mimic QC measurements.

    Args:
        annealing_temperature_celsius: Annealing temperature in °C (100-200)
        deposition_rate_nm_per_s: Thin-film deposition rate in nm/s (0.5-3.0)

    Returns:
        Simulated power conversion efficiency in percent (%).
    """
    T = annealing_temperature_celsius
    R = deposition_rate_nm_per_s

    # Assume an optimum near T_opt and R_opt
    T_opt = 160.0
    R_opt = 1.6

    # Scaled deviations
    dt = (T - T_opt) / 20.0
    dr = (R - R_opt) / 0.5

    # Smooth response surface with interaction
    base_peak = 18.0
    response = base_peak - (dt**2) * 6.0 - (dr**2) * 4.0 - 1.5 * dt * dr

    # Minor process ripples to add non-convexity
    response += 0.8 * np.sin((T - 120.0) / 25.0) + 0.5 * np.cos(R * 2.0)

    # Edge penalties for extreme processing
    response -= 1.2 / (1.0 + np.exp(-(T - 185.0) / 2.0))  # high-T degradation
    response -= 0.7 / (1.0 + np.exp(-(0.8 - R) / 0.1))    # very slow deposition issues
    response -= 0.7 / (1.0 + np.exp(-(R - 2.5) / 0.1))    # very fast deposition defects

    # Observation noise to reflect QC measurement variability
    noise = _rng.normal(loc=0.0, scale=0.3)  # ±0.3% absolute noise (1σ)
    efficiency_pct = float(np.clip(response + noise, 0.0, 30.0))

    return efficiency_pct


# Configure Ax experiment
ax_client = AxClient(random_seed=42)
ax_client.create_experiment(
    name="solar_cell_pce_optimization",
    parameters=[
        {
            "name": "annealing_temperature_celsius",
            "type": "range",
            "bounds": [100.0, 200.0],
        },
        {
            "name": "deposition_rate_nm_per_s",
            "type": "range",
            "bounds": [0.5, 3.0],
        },
    ],
    objectives={
        objective_name: ObjectiveProperties(minimize=False),
    },
)

# Budget: 25 production cells with QC testing
num_trials = 25
for _ in range(num_trials):
    parameterization, trial_index = ax_client.get_next_trial()

    # Extract parameters
    annealing_temperature_celsius = parameterization["annealing_temperature_celsius"]
    deposition_rate_nm_per_s = parameterization["deposition_rate_nm_per_s"]

    # Evaluate (replace with actual QC measurement integration when available)
    pce_value = evaluate_solar_cell_efficiency(
        annealing_temperature_celsius=annealing_temperature_celsius,
        deposition_rate_nm_per_s=deposition_rate_nm_per_s,
    )

    # Report result back to Ax
    ax_client.complete_trial(trial_index=trial_index, raw_data=pce_value)

# Retrieve best found parameters and metrics
best_parameters, best_metrics = ax_client.get_best_parameters()

# Plot results
metric_col = objective_name
df = ax_client.get_trials_data_frame()

# Ensure plotting works if index is not contiguous
y = df[metric_col].astype(float).values
x = np.arange(1, len(y) + 1)
best_to_date = np.maximum.accumulate(y)

fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
ax.scatter(x, y, ec="k", fc="none", label="Observed")
ax.plot(x, best_to_date, color="#0033FF", lw=2, label="Best to Trial")
ax.set_xlabel("Trial Number")
ax.set_ylabel("Power Conversion Efficiency (%)")
ax.set_title("Solar Cell PCE Optimization (Ax)")
ax.legend()
plt.tight_layout()
plt.show()