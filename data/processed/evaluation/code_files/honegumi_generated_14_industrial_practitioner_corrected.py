# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


obj1_name = "branin"


def branin3(x1, x2, x3):
    y = float(
        (x2 - 5.1 / (4 * np.pi**2) * x1**2 + 5.0 / np.pi * x1 - 6.0) ** 2
        + 10 * (1 - 1.0 / (8 * np.pi)) * np.cos(x1)
        + 10
    )

    # Contrived way to incorporate x3 into the objective
    y = y * (1 + 0.1 * x1 * x2 * x3)

    return y


# Define total for compositional constraint, where x1 + x2 + x3 == total
total = 10.0


ax_client = AxClient()

ax_client.create_experiment(
    parameters=[
        {"name": "x1", "type": "range", "bounds": [0.0, total]},
        {"name": "x2", "type": "range", "bounds": [0.0, total]},
    ],
    objectives={
        obj1_name: ObjectiveProperties(minimize=True),
    },
    parameter_constraints=[
        f"x1 + x2 <= {total}",  # reparameterized compositional constraint, which is a type of sum constraint
    ],
)


for i in range(21):

    parameterization, trial_index = ax_client.get_next_trial()

    # extract parameters
    x1 = parameterization["x1"]
    x2 = parameterization["x2"]
    x3 = total - (x1 + x2)  # composition constraint: x1 + x2 + x3 == total

    results = branin3(x1, x2, x3)
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)

best_parameters, metrics = ax_client.get_best_parameters()


# Plot results
objectives = ax_client.objective_names
df = ax_client.get_trials_data_frame()

fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
ax.scatter(df.index, df[objectives], ec="k", fc="none", label="Observed")
ax.plot(
    df.index,
    np.minimum.accumulate(df[objectives]),
    color="#0033FF",
    lw=2,
    label="Best to Trial",
)
ax.set_xlabel("Trial Number")
ax.set_ylabel(objectives[0])

ax.legend()
plt.show()

# Automated color matching optimization with Ax (R/Y/B fractions summing to 1)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


# --------------------------
# Problem configuration
# --------------------------
np.random.seed(42)

# AS7341 approximate center wavelengths (nm) for the 8 channels
AS7341_WAVELENGTHS_NM = np.array([415, 445, 480, 515, 555, 590, 630, 680], dtype=float)

# Choose the mismatch metric:
# - "spectral_rmse": RMSE between normalized 8-channel spectra (unitless)
# - "delta_e76_approx": ΔE76 after approximate mapping 8-ch spectra to Lab (rough)
MISMATCH_METRIC = "spectral_rmse"  # Options: "spectral_rmse" or "delta_e76_approx"

# Trial budget for optimization
TRIAL_BUDGET = 30

# Objective name
objective_name = "color_mismatch"  # lower is better


# --------------------------
# Target spectrum
# --------------------------
def generate_target_spectrum() -> np.ndarray:
    """
    Create or load the target spectrum measured by AS7341 (8 channels).

    In production:
    - Replace this with a single real measurement of the target color using the AS7341,
      returning an array shape (8, ) with raw or calibrated counts.

    For this script (executable without hardware), we simulate a target spectrum from
    a hidden mixture of R/Y/B primaries.
    """
    # Hidden "true" target fractions (sum to 1). Adjust to emulate a realistic target.
    target_R = 0.22
    target_Y = 0.55
    target_B = 0.23
    target = simulate_as7341_counts_from_fractions(target_R, target_Y, target_B, add_noise=False)
    return target


# --------------------------
# Spectral simulation model
# --------------------------
def gaussian_spectrum(peak_nm: float, sigma_nm: float, wavelengths_nm: np.ndarray) -> np.ndarray:
    """Gaussian spectral line shape sampled at given wavelengths."""
    return np.exp(-0.5 * ((wavelengths_nm - peak_nm) / sigma_nm) ** 2)


def simulate_as7341_counts_from_fractions(
    R_fraction: float,
    Y_fraction: float,
    B_fraction: float,
    add_noise: bool = True,
) -> np.ndarray:
    """
    Simulate AS7341 8-channel spectral counts for a tri-chromatic mixture (R/Y/B) in fractions summing to 1.

    The basis spectra are modeled as Gaussians:
      - Blue:   center 480 nm, sigma 18 nm
      - Yellow: center 590 nm, sigma 18 nm
      - Red:    center 630 nm, sigma 20 nm

    Returns:
      counts: np.ndarray of shape (8,) representing the sensor channels.
    """
    wavelengths = AS7341_WAVELENGTHS_NM

    # Primary basis spectra (choose centers/FWHM resembling narrowband LEDs)
    blue = gaussian_spectrum(peak_nm=480.0, sigma_nm=18.0, wavelengths_nm=wavelengths)
    yellow = gaussian_spectrum(peak_nm=590.0, sigma_nm=18.0, wavelengths_nm=wavelengths)
    red = gaussian_spectrum(peak_nm=630.0, sigma_nm=20.0, wavelengths_nm=wavelengths)

    # Normalize bases so they are comparable in peak amplitude
    blue /= blue.max()
    yellow /= yellow.max()
    red /= red.max()

    # Mixture (linear in spectral power)
    spectrum = (B_fraction * blue) + (Y_fraction * yellow) + (R_fraction * red)

    # Simulate sensor scaling to counts (arbitrary gain)
    counts = spectrum * 1000.0

    # Add mild sensor noise
    if add_noise:
        noise_std = 5.0 + 0.01 * counts  # Poisson-like + baseline electronic
        noisy_counts = counts + np.random.normal(loc=0.0, scale=noise_std, size=counts.shape)
        noisy_counts = np.clip(noisy_counts, a_min=0.0, a_max=None)
        return noisy_counts

    return counts


# --------------------------
# Color mismatch metrics
# --------------------------
def spectral_rmse(mix_spec: np.ndarray, target_spec: np.ndarray) -> float:
    """
    RMSE between normalized spectra (unit area). Unitless "spectral distance".
    """
    mix = np.array(mix_spec, dtype=float)
    target = np.array(target_spec, dtype=float)

    # Normalize to unit area to remove brightness differences
    mix /= (np.sum(mix) + 1e-12)
    target /= (np.sum(target) + 1e-12)

    rmse = float(np.sqrt(np.mean((mix - target) ** 2)))
    return rmse


def delta_e76_approx_from_8ch(mix_spec: np.ndarray, target_spec: np.ndarray) -> float:
    """
    Approximate ΔE76 between two 8-channel spectra by mapping them to CIE Lab.

    NOTE: This is an approximation because we are mapping from coarse 8-channel data.
    It uses a simple linear mapping from 8-ch to XYZ via approximate 1931 CMFs at the
    channel centers, then standard XYZ->Lab conversion with D65 reference.

    For high accuracy in production, calibrate the AS7341 to XYZ via a proper
    characterization matrix using reference spectra.

    Returns:
      ΔE76 (unitless)
    """
    # Approximate 1931 2-deg CMFs at AS7341 channel centers (rough values).
    # x̄, ȳ, z̄ sampled at [415, 445, 480, 515, 555, 590, 630, 680] nm.
    # These are coarse, plausible values to enable an executable example.
    x_bar = np.array([0.0014, 0.0160, 0.0170, 0.0640, 0.9950, 0.6310, 0.0620, 0.0030])
    y_bar = np.array([0.0000, 0.0040, 0.0900, 0.3230, 0.9970, 0.3810, 0.0170, 0.0005])
    z_bar = np.array([0.0065, 0.0900, 0.8230, 0.2720, 0.0005, 0.0000, 0.0000, 0.0000])

    # Normalize spectra to unit area to reduce brightness dependence
    def to_xyz(spec: np.ndarray) -> np.ndarray:
        s = spec.astype(float)
        s /= (np.sum(s) + 1e-12)
        X = float(np.sum(s * x_bar))
        Y = float(np.sum(s * y_bar))
        Z = float(np.sum(s * z_bar))
        return np.array([X, Y, Z], dtype=float)

    XYZ_mix = to_xyz(mix_spec)
    XYZ_tgt = to_xyz(target_spec)

    # Use D65 normalized reference white (approximate in this scaled domain)
    # Scale XYZ so that reference white is [Xn, Yn, Zn] = [0.95047, 1.00000, 1.08883]
    # Here, since values are relative, we normalize both to Y=1 using their own Y
    def xyz_to_lab(XYZ: np.ndarray) -> np.ndarray:
        X, Y, Z = XYZ
        # Normalize by Yn=1 (already unit normalized)
        def f(t: float) -> float:
            eps = 216 / 24389
            kappa = 24389 / 27
            return t ** (1 / 3) if t > eps else (kappa * t + 16) / 116

        fx = f(X)
        fy = f(Y)
        fz = f(Z)
        L = 116 * fy - 16
        a = 500 * (fx - fy)
        b = 200 * (fy - fz)
        return np.array([L, a, b], dtype=float)

    Lab_mix = xyz_to_lab(XYZ_mix)
    Lab_tgt = xyz_to_lab(XYZ_tgt)

    delta_e76 = float(np.sqrt(np.sum((Lab_mix - Lab_tgt) ** 2)))
    return delta_e76


def compute_color_mismatch(mix_spec: np.ndarray, target_spec: np.ndarray, metric: str) -> float:
    if metric == "delta_e76_approx":
        return delta_e76_approx_from_8ch(mix_spec, target_spec)
    # Default to spectral RMSE
    return spectral_rmse(mix_spec, target_spec)


# --------------------------
# Evaluation function
# --------------------------
def evaluate_color_matching(R_fraction: float, Y_fraction: float, B_fraction: float, target_spec_8ch: np.ndarray) -> float:
    """
    Evaluate color mismatch for given R/Y/B fractions against the target AS7341 spectrum.

    Returns:
      color_mismatch (float): Lower is better.
    """
    # Clamp and renormalize fractions to ensure non-negativity and sum to 1 (for safety)
    fractions = np.clip(np.array([R_fraction, Y_fraction, B_fraction], dtype=float), 0.0, 1.0)
    total = np.sum(fractions)
    if total <= 0:
        fractions = np.array([1.0, 0.0, 0.0])
    else:
        fractions = fractions / total

    R_f, Y_f, B_f = fractions.tolist()

    # Simulate sensor measurement for these fractions
    mix_spec = simulate_as7341_counts_from_fractions(R_f, Y_f, B_f, add_noise=True)

    # Compute mismatch w.r.t. target
    mismatch = compute_color_mismatch(mix_spec, target_spec_8ch, metric=MISMATCH_METRIC)
    return float(mismatch)


# --------------------------
# Ax experiment setup
# --------------------------
def main():
    # Load or simulate target spectrum once
    target_spec = generate_target_spectrum()

    # Reparameterized composition constraint:
    # We optimize R_fraction and Y_fraction in [0, 1], with R + Y <= 1, and derive B = 1 - (R + Y)
    total_fraction = 1.0

    ax_client = AxClient()

    ax_client.create_experiment(
        name="as7341_color_matching_r_y_b",
        parameters=[
            {
                "name": "R_fraction",
                "type": "range",
                "bounds": [0.0, total_fraction],
                "value_type": "float",
            },
            {
                "name": "Y_fraction",
                "type": "range",
                "bounds": [0.0, total_fraction],
                "value_type": "float",
            },
        ],
        objectives={
            objective_name: ObjectiveProperties(minimize=True),
        },
        parameter_constraints=[
            f"R_fraction + Y_fraction <= {total_fraction}",
        ],
    )

    # Optimization loop
    for _ in range(TRIAL_BUDGET):
        params, trial_index = ax_client.get_next_trial()
        R = float(params["R_fraction"])
        Y = float(params["Y_fraction"])
        B = max(0.0, total_fraction - (R + Y))  # derived from composition constraint

        try:
            mismatch = evaluate_color_matching(R, Y, B, target_spec_8ch=target_spec)
        except Exception as e:
            # Fail trial on exception
            ax_client.log_trial_failure(trial_index=trial_index)
            print(f"Trial {trial_index} failed with error: {e}")
            continue

        # Report result to Ax
        ax_client.complete_trial(trial_index=trial_index, raw_data=mismatch)

    # Retrieve best parameters
    best_parameters, best_metrics = ax_client.get_best_parameters()
    best_R = best_parameters.get("R_fraction", 0.0)
    best_Y = best_parameters.get("Y_fraction", 0.0)
    best_B = max(0.0, total_fraction - (best_R + best_Y))

    print("Best fractions found:")
    print(f"  R_fraction: {best_R:.4f}")
    print(f"  Y_fraction: {best_Y:.4f}")
    print(f"  B_fraction: {best_B:.4f}")
    print(f"Best observed {objective_name}: {best_metrics[objective_name]:.6f}")

    # Plot results
    objectives = ax_client.objective_names
    df = ax_client.get_trials_data_frame()

    # df[objectives] returns a DataFrame with a single column objective
    yvals = df[objectives[0]].values

    fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
    ax.scatter(df.index, yvals, ec="k", fc="none", label="Observed")
    ax.plot(df.index, np.minimum.accumulate(yvals), color="#0033FF", lw=2, label="Best to Trial")
    ax.set_xlabel("Trial Number")
    ylabel = f"{objectives[0]} ({'ΔE' if MISMATCH_METRIC=='delta_e76_approx' else 'unitless'})"
    ax.set_ylabel(ylabel)
    ax.set_title("AS7341 Color Matching Optimization")
    ax.legend()
    plt.tight_layout()
    plt.show()


if __name__ == "__main__":
    main()