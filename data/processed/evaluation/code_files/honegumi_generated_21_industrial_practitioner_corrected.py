# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


# Metric names (both are to be minimized)
CONTAMINANTS_METRIC = "contaminants_ppb"
COST_METRIC = "treatment_cost_per_m3"

# Reproducible RNG for simulated measurement noise
rng = np.random.default_rng(2025)


def evaluate_treatment_plant(
    coagulant_dose_mg_per_L: float,
    flocculant_dose_mg_per_L: float,
    disinfectant_dose_mg_per_L: float,
) -> dict:
    """
    Simulated evaluation of a water treatment step.

    Inputs (all in mg/L):
      - coagulant_dose_mg_per_L: 5–20 mg/L typical (e.g., alum)
      - flocculant_dose_mg_per_L: 1–8 mg/L typical (e.g., polymer)
      - disinfectant_dose_mg_per_L: 2–10 mg/L typical (e.g., chlorine)

    Outputs:
      - contaminants_ppb: Lower is better
      - treatment_cost_per_m3: USD per m^3 of treated water, lower is better

    This function uses a plausible process-response model with diminishing returns,
    synergy between coagulant and flocculant, and penalties for overdosing that
    can drive up residuals/byproducts. It injects small Gaussian noise to mimic
    measurement variability (noisy setting).
    """
    # Chemical prices (USD per kg)
    price_coagulant_per_kg = 0.55
    price_flocculant_per_kg = 3.80
    price_disinfectant_per_kg = 0.70

    # Convert mg/L to kg per m^3 (1 mg/L == 1 g/m^3 == 0.001 kg/m^3)
    kg_per_m3_coag = coagulant_dose_mg_per_L / 1000.0
    kg_per_m3_floc = flocculant_dose_mg_per_L / 1000.0
    kg_per_m3_dis = disinfectant_dose_mg_per_L / 1000.0

    # Base chemical cost (USD/m^3)
    chemical_cost = (
        price_coagulant_per_kg * kg_per_m3_coag
        + price_flocculant_per_kg * kg_per_m3_floc
        + price_disinfectant_per_kg * kg_per_m3_dis
    )

    # Sludge/handling cost grows mainly with coagulant + flocculant (USD/m^3)
    sludge_and_handling_cost = 0.00020 * (coagulant_dose_mg_per_L + flocculant_dose_mg_per_L)

    # Small fixed operational overhead per m^3 (does not affect optimization structure)
    fixed_overhead = 0.005

    treatment_cost = chemical_cost + sludge_and_handling_cost + fixed_overhead

    # Contaminant model (ppb): diminishing returns + synergy + overdosing penalties
    baseline_contaminants = 120.0  # ppb baseline influent
    removal_from_coag = 26.0 * np.log1p(coagulant_dose_mg_per_L / 5.0)
    removal_from_floc = 18.0 * np.log1p(flocculant_dose_mg_per_L)
    removal_from_dis = 22.0 * np.log1p(disinfectant_dose_mg_per_L / 2.0)

    # Synergy term: coagulant aids floc formation, mild diminishing returns
    synergy = 0.12 * coagulant_dose_mg_per_L * np.sqrt(max(flocculant_dose_mg_per_L, 0.0))

    # Overdosing penalties: residuals or disinfection byproducts can increase ppb
    penalty_coag = 0.60 * max(coagulant_dose_mg_per_L - 16.0, 0.0) ** 2
    penalty_dis = 1.20 * max(disinfectant_dose_mg_per_L - 7.0, 0.0) ** 2

    contaminants = (
        baseline_contaminants
        - removal_from_coag
        - removal_from_floc
        - removal_from_dis
        - synergy
        + penalty_coag
        + penalty_dis
    )

    # Floor to represent detection/irreducible background
    contaminants = max(5.0, contaminants)

    # Inject small Gaussian noise to mimic measurement variability
    contaminants_obs = max(5.0, contaminants + rng.normal(0.0, 2.5))
    treatment_cost_obs = max(0.0, treatment_cost + rng.normal(0.0, 0.0015))

    return {
        CONTAMINANTS_METRIC: float(contaminants_obs),
        COST_METRIC: float(treatment_cost_obs),
    }


# Ax optimization setup (multi-objective, single task, default GP model)
ax_client = AxClient()

ax_client.create_experiment(
    parameters=[
        {
            "name": "coagulant_dose_mg_per_L",
            "type": "range",
            "bounds": [5.0, 20.0],
        },
        {
            "name": "flocculant_dose_mg_per_L",
            "type": "range",
            "bounds": [1.0, 8.0],
        },
        {
            "name": "disinfectant_dose_mg_per_L",
            "type": "range",
            "bounds": [2.0, 10.0],
        },
    ],
    objectives={
        CONTAMINANTS_METRIC: ObjectiveProperties(minimize=True),
        COST_METRIC: ObjectiveProperties(minimize=True),
    },
)

# Budget: 32 trials
for _ in range(32):
    parameterization, trial_index = ax_client.get_next_trial()

    # Extract parameters
    coagulant = float(parameterization["coagulant_dose_mg_per_L"])
    flocculant = float(parameterization["flocculant_dose_mg_per_L"])
    disinfectant = float(parameterization["disinfectant_dose_mg_per_L"])

    # Run (or simulate) the experiment
    results = evaluate_treatment_plant(
        coagulant_dose_mg_per_L=coagulant,
        flocculant_dose_mg_per_L=flocculant,
        disinfectant_dose_mg_per_L=disinfectant,
    )

    # Report results to Ax
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)

# Retrieve Pareto-optimal parameterizations based on observed data
pareto_parameters = ax_client.get_pareto_optimal_parameters(use_model_predictions=False)

# Plot results
objectives = ax_client.objective_names  # [CONTAMINANTS_METRIC, COST_METRIC]
df = ax_client.get_trials_data_frame()

fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
pareto = ax_client.get_pareto_optimal_parameters(use_model_predictions=False)
pareto_data = [p[1][0] for p in pareto.values()]
pareto_df = pd.DataFrame(pareto_data).sort_values(objectives[0])

ax.scatter(df[objectives[0]], df[objectives[1]], fc="None", ec="k", label="Observed")
ax.plot(
    pareto_df[objectives[0]],
    pareto_df[objectives[1]],
    color="#0033FF",
    lw=2,
    label="Pareto Front",
)
ax.set_xlabel(objectives[0])
ax.set_ylabel(objectives[1])
ax.set_title("Treatment Plant Optimization: Contaminants vs Cost")

ax.legend()
plt.tight_layout()
plt.show()