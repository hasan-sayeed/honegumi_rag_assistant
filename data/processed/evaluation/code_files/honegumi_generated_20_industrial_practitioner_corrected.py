# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


objective_name = "junction_temperature_celsius"


def evaluate_led_thermal_performance(
    heat_sink_area_mm2: float, paste_thickness_um: float, *, rng: np.random.Generator
) -> float:
    """
    Compute LED junction temperature (°C) for a given thermal stack-up.

    Parameters
    - heat_sink_area_mm2: Heat sink effective area in mm^2 (100 - 500)
    - paste_thickness_um: TIM (thermal interface material) thickness in micrometers (50 - 200)

    Model
    Tj = Tamb + P * (R_jc + R_tim + R_contact_extra + R_conv)

    Where:
    - R_jc: Junction-to-case/package thermal resistance (assumed constant)
    - R_tim: TIM conduction resistance = t / (k * A)
    - R_contact_extra: Extra interface/contact resistance penalty for very thin TIM
    - R_conv: Convective resistance of heat sink = 1 / (h * A)

    This function includes small stochastic noise to emulate experimental variability.
    """
    # Constants and nominal properties
    tambient_c = 25.0           # °C
    power_w = 3.0               # LED dissipated power [W]
    r_junction_to_case = 2.0    # K/W (package + board path)
    k_tim_w_mk = 3.0            # W/m-K (TIM conductivity)
    h_conv_w_m2k = 30.0         # W/m^2-K (natural convection, small heatsink)

    # Unit conversions
    area_m2 = heat_sink_area_mm2 * 1e-6           # mm^2 -> m^2
    thickness_m = paste_thickness_um * 1e-6       # μm -> m

    # Guard against pathological values (numerical safety)
    area_m2 = max(area_m2, 1e-8)
    thickness_m = max(thickness_m, 1e-7)

    # Thermal resistances
    r_tim = thickness_m / (k_tim_w_mk * area_m2)          # K/W
    r_conv = 1.0 / (h_conv_w_m2k * area_m2)               # K/W

    # Extra contact/interface penalty when TIM is very thin (voiding, incomplete wet-out)
    # Logistic decay: ~0.3 K/W penalty near 50 μm, tapering to ~0 for >= ~120 μm
    r_contact_extra = 0.3 / (1.0 + np.exp((thickness_m - 80e-6) / (10e-6)))

    total_r = r_junction_to_case + r_tim + r_contact_extra + r_conv

    # Base junction temperature
    tj_c = tambient_c + power_w * total_r

    # Add realistic experimental noise (process + measurement)
    process_noise_c = rng.normal(loc=0.0, scale=0.6)  # °C
    gain_jitter = 1.0 + rng.normal(loc=0.0, scale=0.02)

    tj_noisy_c = tambient_c + power_w * total_r * gain_jitter + process_noise_c
    return float(tj_noisy_c)


# Reproducible randomness for the synthetic evaluator
rng = np.random.default_rng(2025)

ax_client = AxClient()

ax_client.create_experiment(
    parameters=[
        {"name": "heat_sink_area_mm2", "type": "range", "bounds": [100.0, 500.0]},
        {"name": "paste_thickness_um", "type": "range", "bounds": [50.0, 200.0]},
    ],
    objectives={
        objective_name: ObjectiveProperties(minimize=True),
    },
)

# Budget: 28 prototypes (trials)
for i in range(28):
    parameterization, trial_index = ax_client.get_next_trial()

    heat_sink_area_mm2 = float(parameterization["heat_sink_area_mm2"])
    paste_thickness_um = float(parameterization["paste_thickness_um"])

    try:
        tj_c = evaluate_led_thermal_performance(
            heat_sink_area_mm2=heat_sink_area_mm2,
            paste_thickness_um=paste_thickness_um,
            rng=rng,
        )
        ax_client.complete_trial(
            trial_index=trial_index,
            raw_data={objective_name: tj_c},
        )
    except Exception:
        ax_client.log_trial_failure(trial_index=trial_index)

best_parameters, best_metrics = ax_client.get_best_parameters()
print("Best parameters found:", best_parameters)
print("Best observed metrics:", best_metrics)

# Plot results
df = ax_client.get_trials_data_frame()

# Extract the objective series and drop NaNs (failed or pending trials)
y = df[objective_name]
mask = y.notna()
x_idx = df.index[mask]
y_vals = y[mask].values

fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
ax.scatter(x_idx, y_vals, ec="k", fc="none", label="Observed")

if len(y_vals) > 0:
    best_to_trial = np.minimum.accumulate(y_vals)
    ax.plot(x_idx, best_to_trial, color="#0033FF", lw=2, label="Best to Trial")

ax.set_xlabel("Trial Number")
ax.set_ylabel("Junction Temperature (°C)")
ax.set_title("LED Package Thermal Design Optimization")
ax.legend()
plt.tight_layout()
plt.show()