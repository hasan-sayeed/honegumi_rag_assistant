# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


obj1_name = "branin"


def branin(x1, x2):
    y = float(
        (x2 - 5.1 / (4 * np.pi**2) * x1**2 + 5.0 / np.pi * x1 - 6.0) ** 2
        + 10 * (1 - 1.0 / (8 * np.pi)) * np.cos(x1)
        + 10
    )

    return y


ax_client = AxClient()

ax_client.create_experiment(
    parameters=[
        {"name": "x1", "type": "range", "bounds": [-5.0, 10.0]},
        {"name": "x2", "type": "range", "bounds": [0.0, 10.0]},
    ],
    objectives={
        obj1_name: ObjectiveProperties(minimize=True),
    },
)


for i in range(19):

    parameterization, trial_index = ax_client.get_next_trial()

    # extract parameters
    x1 = parameterization["x1"]
    x2 = parameterization["x2"]

    results = branin(x1, x2)
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)

best_parameters, metrics = ax_client.get_best_parameters()


# Plot results
objectives = ax_client.objective_names
df = ax_client.get_trials_data_frame()

fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
ax.scatter(df.index, df[objectives], ec="k", fc="none", label="Observed")
ax.plot(
    df.index,
    np.minimum.accumulate(df[objectives]),
    color="#0033FF",
    lw=2,
    label="Best to Trial",
)
ax.set_xlabel("Trial Number")
ax.set_ylabel(objectives[0])

ax.legend()
plt.show()

# Optimizing catalyst calcination for maximum activity (μmol/g·s) using Ax Platform
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from ax.service.ax_client import AxClient, ObjectiveProperties


# Domain-specific names
objective_name = "catalyst_activity"


def evaluate_catalyst_activity(calcination_temperature_celsius: float, calcination_time_hours: float) -> float:
    """
    Deterministic surrogate for catalyst activity (μmol/g·s) as a function of calcination conditions.

    This function is a physics-inspired, noise-free proxy capturing typical behaviors:
    - Activity increases with temperature and time up to an optimal region (crystallization/phase formation).
    - Excessive temperature/time induces sintering and surface area loss, reducing activity.
    - A secondary local optimum may exist (e.g., lower temperature with longer time).

    Replace this surrogate with actual experimental measurement or a validated simulation model
    when integrating with the real production pipeline.

    Parameters
    ----------
    calcination_temperature_celsius : float
        Calcination temperature in °C (expected range: 300–600).
    calcination_time_hours : float
        Calcination time in hours (expected range: 2–8).

    Returns
    -------
    float
        Catalyst activity in μmol/g·s (higher is better).
    """
    T = float(calcination_temperature_celsius)
    t = float(calcination_time_hours)

    # Primary optimum region (e.g., phase formation peak)
    T_opt1, t_opt1 = 520.0, 5.5
    sigma_T1, sigma_t1 = 40.0, 1.2
    peak1 = np.exp(-((T - T_opt1) ** 2) / (2 * sigma_T1**2) - ((t - t_opt1) ** 2) / (2 * sigma_t1**2))

    # Secondary, weaker optimum (e.g., lower T with longer time)
    T_opt2, t_opt2 = 470.0, 7.0
    sigma_T2, sigma_t2 = 35.0, 0.8
    peak2 = np.exp(-((T - T_opt2) ** 2) / (2 * sigma_T2**2) - ((t - t_opt2) ** 2) / (2 * sigma_t2**2))

    # Mild interaction ridge: similar T*t product can yield decent activity
    # Normalize T,t to [0,1] over their ranges and create a ridge near target product
    Tn = (T - 300.0) / (600.0 - 300.0)
    tn = (t - 2.0) / (8.0 - 2.0)
    ridge = np.exp(-((Tn * tn - 0.42) ** 2) / (2 * 0.06**2)) * 0.25

    # Penalties for extreme conditions (sintering/deactivation)
    def sigmoid(x):
        return 1.0 / (1.0 + np.exp(-x))

    penalty = 40.0 * sigmoid((T - 570.0) / 10.0) + 25.0 * sigmoid((t - 7.5) / 0.3)

    # Combine contributions into an activity metric (μmol/g·s)
    baseline = 10.0
    activity = baseline + 180.0 * peak1 + 75.0 * peak2 + 50.0 * ridge - penalty

    # Ensure non-negative activity
    return float(max(activity, 0.0))


def main():
    # Create Ax client and experiment
    ax_client = AxClient()
    ax_client.create_experiment(
        name="catalyst_calcination_optimization",
        parameters=[
            {
                "name": "calcination_temperature_celsius",
                "type": "range",
                "bounds": [300.0, 600.0],
            },
            {
                "name": "calcination_time_hours",
                "type": "range",
                "bounds": [2.0, 8.0],
            },
        ],
        objectives={
            objective_name: ObjectiveProperties(minimize=False),
        },
        # Default model (GPEI), single task, no explicit constraints; data assumed noise-free and reproducible.
    )

    total_trials = 25  # Budget: 25 production batches

    for _ in range(total_trials):
        parameterization, trial_index = ax_client.get_next_trial()

        # Extract parameters with domain-specific names
        temp_c = parameterization["calcination_temperature_celsius"]
        time_h = parameterization["calcination_time_hours"]

        # Run experiment (surrogate here; replace with real measurement)
        activity_value = evaluate_catalyst_activity(temp_c, time_h)

        # Complete the trial with the measured activity
        ax_client.complete_trial(trial_index=trial_index, raw_data=activity_value)

    best_parameters, best_metrics = ax_client.get_best_parameters()

    # Print best result
    best_value = best_metrics[objective_name][0]  # mean
    print("Best parameters found:")
    print(f"  calcination_temperature_celsius = {best_parameters['calcination_temperature_celsius']:.3f} °C")
    print(f"  calcination_time_hours          = {best_parameters['calcination_time_hours']:.3f} h")
    print(f"Best observed catalyst_activity   = {best_value:.3f} μmol/g·s")

    # Plot observed activity over trials and best-so-far curve
    df = ax_client.get_trials_data_frame()
    if objective_name in df.columns:
        y = df[objective_name]
        best_so_far = y.cummax()
        fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
        ax.scatter(df.index, y, ec="k", fc="none", label="Observed")
        ax.plot(df.index, best_so_far, color="#0033FF", lw=2, label="Best to Trial")
        ax.set_xlabel("Trial Number")
        ax.set_ylabel(f"{objective_name} (μmol/g·s)")
        ax.legend()
        plt.tight_layout()
        plt.show()

    # Optional: visualize surrogate landscape sampled via the evaluation function (not model-derived)
    # This is only for demonstration of the synthetic landscape; remove in production with real experiments.
    try:
        T_grid = np.linspace(300.0, 600.0, 60)
        t_grid = np.linspace(2.0, 8.0, 60)
        TT, tt = np.meshgrid(T_grid, t_grid)
        ZZ = np.vectorize(evaluate_catalyst_activity)(TT, tt)

        fig2, ax2 = plt.subplots(figsize=(6, 4.5), dpi=150)
        cs = ax2.contourf(TT, tt, ZZ, levels=20, cmap="viridis")
        cbar = fig2.colorbar(cs, ax=ax2, label="catalyst_activity (μmol/g·s)")
        ax2.set_xlabel("Calcination temperature (°C)")
        ax2.set_ylabel("Calcination time (hours)")
        ax2.set_title("Synthetic activity landscape (for illustration)")
        plt.tight_layout()
        plt.show()
    except Exception:
        pass


if __name__ == "__main__":
    main()