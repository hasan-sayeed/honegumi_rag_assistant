# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from typing import Dict, Tuple

from ax.service.ax_client import AxClient, ObjectiveProperties


# Domain-specific metric names
CONDUCTIVITY_METRIC = "conductivity"     # Units: S/m
PRINTABILITY_METRIC = "printability"     # Units: 1-10 score

# Composition constraint total (fractions must sum to 1.0)
COMPOSITION_TOTAL = 1.0

# Bounds for each component (fractions)
SILVER_BOUNDS = (0.40, 0.70)
SOLVENT_BOUNDS = (0.15, 0.35)
BINDER_BOUNDS = (0.05, 0.20)
ADDITIVE_BOUNDS = (0.02, 0.10)  # Computed as remainder to satisfy composition


# Reproducible randomness for synthetic noise
_rng = np.random.default_rng(seed=2025)


def _gaussian_pref(x: float, mu: float, sigma: float) -> float:
    """Utility: preference curve centered at mu with width sigma."""
    z = (x - mu) / max(sigma, 1e-9)
    return float(np.exp(-0.5 * z * z))


def evaluate_ink_formulation(
    silver_particles: float, solvent: float, binder: float
) -> Dict[str, Tuple[float, float]]:
    """
    Synthetic evaluation for multi-objective ink formulation.

    Inputs:
      - silver_particles: fraction [0.40, 0.70]
      - solvent:          fraction [0.15, 0.35]
      - binder:           fraction [0.05, 0.20]
    The additive fraction is computed as: 1 - (silver + solvent + binder)
      and constrained to [0.02, 0.10] via linear constraints.

    Outputs:
      - conductivity (S/m): higher is better
      - printability (1-10): higher is better

    This function provides a physically-inspired synthetic mapping with noise:
    - Conductivity increases with silver loading and proper dispersant/packing,
      degrades with excessive binder or off-target additive.
    - Printability favors a window in solvent (flow), binder (viscosity/film strength),
      and additive (surface tension), and slightly penalizes very high silver loading.
    """
    additive = COMPOSITION_TOTAL - (silver_particles + solvent + binder)

    # Guard against numeric drift or accidental infeasibility
    if additive < ADDITIVE_BOUNDS[0] - 1e-8 or additive > ADDITIVE_BOUNDS[1] + 1e-8:
        # Return clearly poor outcomes if violated; Ax should avoid these via constraints.
        return {
            CONDUCTIVITY_METRIC: (0.0, 0.0),
            PRINTABILITY_METRIC: (1.0, 0.0),
        }

    # Preference windows (roughly capturing practical ranges)
    g_add = _gaussian_pref(additive, mu=0.06, sigma=0.018)   # dispersant/surfactant sweet spot
    g_bin = _gaussian_pref(binder,   mu=0.12, sigma=0.035)   # binder for film formation
    g_sol = _gaussian_pref(solvent,  mu=0.25, sigma=0.060)   # solvent for jetting/rheology

    # Silver effect (normalized 0..1 over allowed range)
    silver_norm = (silver_particles - SILVER_BOUNDS[0]) / (SILVER_BOUNDS[1] - SILVER_BOUNDS[0])
    silver_norm = float(np.clip(silver_norm, 0.0, 1.0))

    # Conductivity model (S/m): dominated by silver; boosted by good additive/binder tuning.
    # Scales representative of printed silver inks after sintering.
    conductivity_true = (
        5.0e5 * (silver_norm ** 1.6)           # nonlinear benefit of higher silver loading
        * (0.55 + 0.45 * g_add)                # dispersant helps packing/percolation
        * (0.65 + 0.35 * g_bin)                # binder moderated for percolation
        * (0.90 + 0.10 * g_sol)                # slight rheology/process assist
    )

    # Printability model (1-10): favors solvent/binder/additive near targets; mild penalty for very high silver.
    base_pref = 0.40 * g_sol + 0.35 * g_bin + 0.25 * g_add
    penalty_silver = max(0.0, (silver_particles - 0.65) / 0.05)  # penalize above ~65%
    penalty_binder_low = max(0.0, (0.07 - binder) / 0.02)        # penalize too little binder

    printability_true = 1.0 + 9.0 * np.clip(base_pref, 0.0, 1.0)
    printability_true -= 1.5 * penalty_silver + 1.0 * penalty_binder_low
    printability_true = float(np.clip(printability_true, 1.0, 10.0))

    # Add measurement noise and provide SEM to Ax (noisy experiment)
    cond_sigma = 1.0e4 + 0.02 * conductivity_true
    prnt_sigma = 0.25 + 0.04 * printability_true

    conductivity_meas = float(max(0.0, conductivity_true + _rng.normal(0.0, cond_sigma)))
    printability_meas = float(np.clip(printability_true + _rng.normal(0.0, prnt_sigma), 1.0, 10.0))

    return {
        CONDUCTIVITY_METRIC: (conductivity_meas, cond_sigma),
        PRINTABILITY_METRIC: (printability_meas, prnt_sigma),
    }


def compute_additive(silver_particles: float, solvent: float, binder: float) -> float:
    """Compute additive as remainder to satisfy compositional sum to 1.0."""
    return COMPOSITION_TOTAL - (silver_particles + solvent + binder)


def is_feasible(silver_particles: float, solvent: float, binder: float) -> bool:
    """Check component-wise and composition constraints for numerical safety."""
    if not (SILVER_BOUNDS[0] <= silver_particles <= SILVER_BOUNDS[1]):
        return False
    if not (SOLVENT_BOUNDS[0] <= solvent <= SOLVENT_BOUNDS[1]):
        return False
    if not (BINDER_BOUNDS[0] <= binder <= BINDER_BOUNDS[1]):
        return False
    additive = compute_additive(silver_particles, solvent, binder)
    if not (ADDITIVE_BOUNDS[0] - 1e-8 <= additive <= ADDITIVE_BOUNDS[1] + 1e-8):
        return False
    return True


def nondominated_sort(df: pd.DataFrame, cols: Tuple[str, str]) -> pd.DataFrame:
    """Return the non-dominated frontier for two objectives to be maximized."""
    a, b = cols
    pts = df[[a, b]].to_numpy()
    n = len(pts)
    is_pareto = np.ones(n, dtype=bool)
    for i in range(n):
        if not is_pareto[i]:
            continue
        dominates = (pts[:, 0] >= pts[i, 0]) & (pts[:, 1] >= pts[i, 1]) & (
            (pts[:, 0] > pts[i, 0]) | (pts[:, 1] > pts[i, 1])
        )
        is_pareto &= ~dominates
        is_pareto[i] = True
    pareto_df = df.loc[is_pareto].copy()
    return pareto_df.sort_values(a)


def main():
    ax_client = AxClient(random_seed=0, verbose_logging=False)

    # Reparameterized compositional constraint:
    # Optimize over silver/solvent/binder; compute additive as 1 - (sum).
    # Enforce additive in [0.02, 0.10] via two linear constraints on the sum:
    #   additive >= 0.02  ->  silver + solvent + binder <= 0.98
    #   additive <= 0.10  ->  silver + solvent + binder >= 0.90
    ax_client.create_experiment(
        name="ink_formulation_multi_objective",
        parameters=[
            {"name": "silver_particles", "type": "range", "bounds": [SILVER_BOUNDS[0], SILVER_BOUNDS[1]]},
            {"name": "solvent", "type": "range", "bounds": [SOLVENT_BOUNDS[0], SOLVENT_BOUNDS[1]]},
            {"name": "binder", "type": "range", "bounds": [BINDER_BOUNDS[0], BINDER_BOUNDS[1]]},
        ],
        objectives={
            CONDUCTIVITY_METRIC: ObjectiveProperties(minimize=False),
            PRINTABILITY_METRIC: ObjectiveProperties(minimize=False),
        },
        parameter_constraints=[
            "silver_particles + solvent + binder <= 0.98",
            "-silver_particles - solvent - binder <= -0.90",
        ],
    )

    # Budget: 45 trials
    n_trials = 45
    for _ in range(n_trials):
        parameterization, trial_index = ax_client.get_next_trial()

        silver = float(parameterization["silver_particles"])
        solv = float(parameterization["solvent"])
        bind = float(parameterization["binder"])
        addi = compute_additive(silver, solv, bind)

        # Optional: attach computed additive to metadata for convenience
        # (not required by Ax, but useful for downstream analysis)
        metadata = {"additive": addi}
        ax_client.set_trial_properties(trial_index=trial_index, metadata=metadata)

        if not is_feasible(silver, solv, bind):
            # Should not happen due to constraints, but handle defensively
            ax_client.log_trial_failure(trial_index=trial_index)
            continue

        results = evaluate_ink_formulation(silver, solv, bind)
        ax_client.complete_trial(trial_index=trial_index, raw_data=results)

    # Retrieve all observed data
    df = ax_client.get_trials_data_frame()

    # Compute additive for plotting convenience (if not in df)
    if "additive" not in df.columns and {"silver_particles", "solvent", "binder"}.issubset(df.columns):
        additive_vals = 1.0 - (df["silver_particles"] + df["solvent"] + df["binder"])
        df["additive"] = additive_vals

    # Compute Pareto frontier from observed data
    pareto_df = nondominated_sort(df, (CONDUCTIVITY_METRIC, PRINTABILITY_METRIC))

    # Plot observed points and Pareto front
    fig, ax = plt.subplots(figsize=(7, 5), dpi=150)
    ax.scatter(
        df[CONDUCTIVITY_METRIC],
        df[PRINTABILITY_METRIC],
        fc="None",
        ec="k",
        alpha=0.7,
        label="Observed"
    )
    ax.plot(
        pareto_df[CONDUCTIVITY_METRIC],
        pareto_df[PRINTABILITY_METRIC],
        color="#0033FF",
        lw=2,
        label="Pareto Front (observed)"
    )
    ax.set_xlabel(f"{CONDUCTIVITY_METRIC} (S/m)")
    ax.set_ylabel(f"{PRINTABILITY_METRIC} (1-10)")
    ax.set_title("Ink Formulation: Conductivity vs. Printability")
    ax.legend()
    plt.tight_layout()
    plt.show()

    # Print top Pareto candidates with compositions
    top = pareto_df[[CONDUCTIVITY_METRIC, PRINTABILITY_METRIC, "silver_particles", "solvent", "binder", "additive"]]
    print("Top Pareto candidates (sorted by conductivity):")
    print(top.sort_values(CONDUCTIVITY_METRIC, ascending=False).head(10).to_string(index=False))


if __name__ == "__main__":
    main()