# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


obj1_name = "branin"


def branin(x1, x2):
    y = float(
        (x2 - 5.1 / (4 * np.pi**2) * x1**2 + 5.0 / np.pi * x1 - 6.0) ** 2
        + 10 * (1 - 1.0 / (8 * np.pi)) * np.cos(x1)
        + 10
    )

    return y


ax_client = AxClient()

ax_client.create_experiment(
    parameters=[
        {"name": "x1", "type": "range", "bounds": [-5.0, 10.0]},
        {"name": "x2", "type": "range", "bounds": [0.0, 10.0]},
    ],
    objectives={
        obj1_name: ObjectiveProperties(minimize=True),
    },
    parameter_constraints=[
        "x1 + x2 <= 15.0",  # example of a sum constraint
    ],
)


for i in range(19):

    parameterization, trial_index = ax_client.get_next_trial()

    # extract parameters
    x1 = parameterization["x1"]
    x2 = parameterization["x2"]

    results = branin(x1, x2)
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)

best_parameters, metrics = ax_client.get_best_parameters()


# Plot results
objectives = ax_client.objective_names
df = ax_client.get_trials_data_frame()

fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
ax.scatter(df.index, df[objectives], ec="k", fc="none", label="Observed")
ax.plot(
    df.index,
    np.minimum.accumulate(df[objectives]),
    color="#0033FF",
    lw=2,
    label="Best to Trial",
)
ax.set_xlabel("Trial Number")
ax.set_ylabel(objectives[0])

ax.legend()
plt.show()

# Generated by adapting Honegumi skeleton for electrolyte conductivity optimization
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


rng = np.random.default_rng(12345)


def evaluate_ionic_conductivity(
    LiPF6_conc: float,
    LiBF4_conc: float,
    LiClO4_conc: float,
    LiTFSI_conc: float,
) -> dict:
    """
    Simulate ionic conductivity (mS/cm) of a multi-salt electrolyte mixture.

    This stub is designed to be immediately executable for optimization demos.
    Replace the model below with actual experimental measurement logic:
      - Prepare electrolyte with the given salt concentrations (Molarity).
      - Measure ionic conductivity in mS/cm (e.g., with EIS / conductivity meter).
      - Return {"ionic_conductivity": (mean_value, sem_value)}.

    Notes:
    - Enforces total concentration <= 2.0 M (also handled by Ax constraint).
    - Adds realistic saturation, viscosity penalties, and salt interaction terms.
    - Includes measurement noise via SEM to inform the Ax noise model.

    Returns:
      Dict with metric name and a tuple (mean, SEM) in mS/cm.
    """
    # Validate physical constraint (also enforced by Ax during generation)
    total_conc = LiPF6_conc + LiBF4_conc + LiClO4_conc + LiTFSI_conc
    if total_conc > 2.0 + 1e-9:
        raise ValueError("Total salt concentration exceeds 2.0 M.")

    # Saturating contributions for each salt (mS/cm scale)
    # Coefficients chosen to yield typical conductivity ranges (0-15 mS/cm)
    a_pf6, b_pf6 = 5.0, 2.0
    a_bf4, b_bf4 = 2.0, 3.0
    a_clo4, b_clo4 = 3.0, 3.0
    a_tfsi, b_tfsi = 5.5, 2.5

    base_contrib = (
        a_pf6 * (1.0 - np.exp(-b_pf6 * LiPF6_conc))
        + a_bf4 * (1.0 - np.exp(-b_bf4 * LiBF4_conc))
        + a_clo4 * (1.0 - np.exp(-b_clo4 * LiClO4_conc))
        + a_tfsi * (1.0 - np.exp(-b_tfsi * LiTFSI_conc))
    )

    # Viscosity / ion-pairing penalty away from an optimal total concentration
    c_opt, visc_coeff = 1.2, 2.0
    viscosity_penalty = visc_coeff * (total_conc - c_opt) ** 2

    # Interaction terms (synergy/antagonism)
    synergy = 0.0
    synergy += 1.0 * np.sqrt(max(LiPF6_conc, 0.0) * max(LiTFSI_conc, 0.0))
    synergy += 0.6 * np.sqrt(max(LiClO4_conc, 0.0) * max(LiBF4_conc, 0.0))
    antagonism = 0.5 * np.sqrt(max(LiPF6_conc, 0.0) * max(LiBF4_conc, 0.0))

    # Compute conductivity and clamp to physical bounds
    kappa_mean = base_contrib + synergy - antagonism - viscosity_penalty
    kappa_mean = float(np.clip(kappa_mean, 0.0, 20.0))

    # Add measurement noise for realism (SEM provided to Ax)
    # Larger noise near very low/high concentrations is plausible
    noise_scale = 0.15 + 0.05 * (total_conc / 2.0)  # mS/cm
    measured_mean = float(kappa_mean + rng.normal(0.0, noise_scale))
    measured_mean = float(np.clip(measured_mean, 0.0, 20.0))
    measured_sem = float(noise_scale)  # report SEM to Ax model

    return {"ionic_conductivity": (measured_mean, measured_sem)}


# Initialize Ax client
ax_client = AxClient()

# Define the optimization experiment
ax_client.create_experiment(
    name="multi_salt_electrolyte_conductivity",
    parameters=[
        {"name": "LiPF6_conc", "type": "range", "bounds": [0.0, 1.5], "value_type": "float"},
        {"name": "LiBF4_conc", "type": "range", "bounds": [0.0, 0.5], "value_type": "float"},
        {"name": "LiClO4_conc", "type": "range", "bounds": [0.0, 0.3], "value_type": "float"},
        {"name": "LiTFSI_conc", "type": "range", "bounds": [0.0, 0.8], "value_type": "float"},
    ],
    objectives={
        "ionic_conductivity": ObjectiveProperties(minimize=False),
    },
    parameter_constraints=[
        "LiPF6_conc + LiBF4_conc + LiClO4_conc + LiTFSI_conc <= 2.0",
    ],
)

# Optimization budget (number of experimental trials)
num_trials = 35

for _ in range(num_trials):
    parameterization, trial_index = ax_client.get_next_trial()

    # Extract salt concentrations
    LiPF6_conc = float(parameterization["LiPF6_conc"])
    LiBF4_conc = float(parameterization["LiBF4_conc"])
    LiClO4_conc = float(parameterization["LiClO4_conc"])
    LiTFSI_conc = float(parameterization["LiTFSI_conc"])

    # Run experiment or simulation
    results = evaluate_ionic_conductivity(
        LiPF6_conc=LiPF6_conc,
        LiBF4_conc=LiBF4_conc,
        LiClO4_conc=LiClO4_conc,
        LiTFSI_conc=LiTFSI_conc,
    )

    ax_client.complete_trial(trial_index=trial_index, raw_data=results)

best_parameters, best_metrics = ax_client.get_best_parameters()

print("Best electrolyte composition (M):")
for k, v in best_parameters.items():
    print(f"  {k}: {v:.4f}")
print("Best observed ionic conductivity (mS/cm):")
for metric_name, metric_info in best_metrics.items():
    mean = metric_info["mean"]
    sem = metric_info.get("sem", None)
    if sem is not None:
        print(f"  {metric_name}: {mean:.3f} Â± {sem:.3f}")
    else:
        print(f"  {metric_name}: {mean:.3f}")

# Plot results
objective_names = ax_client.objective_names
df = ax_client.get_trials_data_frame()

fig, ax = plt.subplots(figsize=(7, 4), dpi=150)
ax.scatter(df.index, df[objective_names], ec="k", fc="none", label="Observed")
ax.plot(
    df.index,
    np.maximum.accumulate(df[objective_names]),
    color="#0033FF",
    lw=2,
    label="Best to Trial",
)
ax.set_xlabel("Trial Number")
ax.set_ylabel(f"{objective_names[0]} (mS/cm)")
ax.set_title("Bayesian Optimization of Ionic Conductivity")
ax.legend()
plt.tight_layout()
plt.show()