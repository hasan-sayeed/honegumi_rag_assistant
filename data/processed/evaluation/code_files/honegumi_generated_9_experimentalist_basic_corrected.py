# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


obj1_name = "branin"


def branin3(x1, x2, x3):
    y = float(
        (x2 - 5.1 / (4 * np.pi**2) * x1**2 + 5.0 / np.pi * x1 - 6.0) ** 2
        + 10 * (1 - 1.0 / (8 * np.pi)) * np.cos(x1)
        + 10
    )

    # Contrived way to incorporate x3 into the objective
    y = y * (1 + 0.1 * x1 * x2 * x3)

    return y


# Define total for compositional constraint, where x1 + x2 + x3 == total
total = 10.0


ax_client = AxClient()

ax_client.create_experiment(
    parameters=[
        {"name": "x1", "type": "range", "bounds": [0.0, total]},
        {"name": "x2", "type": "range", "bounds": [0.0, total]},
    ],
    objectives={
        obj1_name: ObjectiveProperties(minimize=True),
    },
    parameter_constraints=[
        f"x1 + x2 <= {total}",  # reparameterized compositional constraint, which is a type of sum constraint
        "x1 <= x2",  # example of an order constraint
    ],
)


for i in range(21):

    parameterization, trial_index = ax_client.get_next_trial()

    # extract parameters
    x1 = parameterization["x1"]
    x2 = parameterization["x2"]
    x3 = total - (x1 + x2)  # composition constraint: x1 + x2 + x3 == total

    results = branin3(x1, x2, x3)
    ax_client.complete_trial(trial_index=trial_index, raw_data=results)

best_parameters, metrics = ax_client.get_best_parameters()


# Plot results
objectives = ax_client.objective_names
df = ax_client.get_trials_data_frame()

fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
ax.scatter(df.index, df[objectives], ec="k", fc="none", label="Observed")
ax.plot(
    df.index,
    np.minimum.accumulate(df[objectives]),
    color="#0033FF",
    lw=2,
    label="Best to Trial",
)
ax.set_xlabel("Trial Number")
ax.set_ylabel(objectives[0])

ax.legend()
plt.show()

# Optimizing concrete mix for compressive strength (MPa) with Ax Platform
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt


np.random.seed(123)  # Reproducibility for the simulated evaluation


objective_name = "compressive_strength"  # MPa


def evaluate_concrete_mix(cement: float, water: float) -> float:
    """
    Simulated evaluator for concrete compressive strength (MPa).
    Parameters:
      - cement: wt% (15-25)
      - water: wt% (5-15)
    Aggregate is computed as 100 - (cement + water) and is constrained to [60, 80].

    Model details:
      - Strength increases as water/cement ratio decreases (Abrams' law inspired).
      - Slight benefit with higher cement content within range.
      - Aggregate fraction has an optimum near 70 wt% (packing/ITZ effects).
      - Adds small Gaussian noise to mimic experimental uncertainty.

    Returns:
      - Mean compressive strength in MPa (float).
    """
    aggregate = 100.0 - (cement + water)  # compositional closure
    w_c = water / max(cement, 1e-6)  # avoid divide-by-zero

    # Semi-empirical strength model (MPa)
    # Base inverse relation to w/c, plus mild cement content effect,
    # and a small penalty for deviation from 70 wt% aggregate.
    base_strength = 35.0 / (w_c + 0.25)
    cement_boost = 0.6 * (cement - 20.0)
    aggregate_penalty = 0.4 * abs(aggregate - 70.0)

    mean_strength = base_strength + cement_boost - aggregate_penalty

    # Add experimental noise
    noise = np.random.normal(loc=0.0, scale=1.5)
    return float(mean_strength + noise)


# Ax setup
ax_client = AxClient()

# We parameterize cement and water directly; aggregate is computed via composition:
# aggregate = 100 - (cement + water).
# To keep aggregate within [60, 80] wt%, we enforce:
#   100 - (cement + water) >= 60  -> cement + water <= 40
#   100 - (cement + water) <= 80  -> cement + water >= 20
# Also enforce the order constraint cement > water (encoded as water <= cement).
ax_client.create_experiment(
    parameters=[
        {"name": "cement", "type": "range", "bounds": [15.0, 25.0]},  # wt%
        {"name": "water", "type": "range", "bounds": [5.0, 15.0]},    # wt%
    ],
    objectives={
        objective_name: ObjectiveProperties(minimize=False),
    },
    parameter_constraints=[
        "cement + water <= 40.0",  # ensures aggregate >= 60
        "cement + water >= 20.0",  # ensures aggregate <= 80
        "water <= cement",         # cement > water
    ],
)

# Budget: 20 mix designs
num_trials = 20
for _ in range(num_trials):
    parameterization, trial_index = ax_client.get_next_trial()

    cement = parameterization["cement"]
    water = parameterization["water"]
    # Aggregate is compositional remainder; constraints keep it in [60, 80].
    aggregate = 100.0 - (cement + water)

    # Evaluate compressive strength (MPa)
    strength_mpa = evaluate_concrete_mix(cement=cement, water=water)
    # Provide a measurement standard error to indicate noise (MPa)
    sem_mpa = 2.0

    ax_client.complete_trial(trial_index=trial_index, raw_data=(strength_mpa, sem_mpa))

best_parameters, best_metrics = ax_client.get_best_parameters()
print("Best mix (wt%):", best_parameters)
print("Best estimated metrics:", best_metrics)

# Plot results
objective_names = ax_client.objective_names
df = ax_client.get_trials_data_frame()

fig, ax = plt.subplots(figsize=(6, 4), dpi=150)
ax.scatter(df.index, df[objective_names], ec="k", fc="none", label="Observed")
ax.plot(
    df.index,
    np.maximum.accumulate(df[objective_names]),
    color="#0033FF",
    lw=2,
    label="Best to Trial",
)
ax.set_xlabel("Trial Number")
ax.set_ylabel(f"{objective_names[0]} (MPa)")
ax.legend()
plt.tight_layout()
plt.show()