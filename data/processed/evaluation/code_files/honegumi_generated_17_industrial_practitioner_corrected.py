# Generated by Honegumi (https://arxiv.org/abs/2502.06815)
# %pip install ax-platform==0.4.3 matplotlib
import numpy as np
import pandas as pd
from ax.service.ax_client import AxClient, ObjectiveProperties
import matplotlib.pyplot as plt
from typing import Dict, Tuple


METRIC_EDGE_ROUGHNESS = "edge_roughness_microns"
BUDGET_TRIALS = 30
RNG = np.random.default_rng(12345)


def simulate_edge_roughness(power_watts: float, speed_mm_per_s: float, rng: np.random.Generator) -> float:
    """
    Physics-inspired surrogate for edge roughness (μm) in laser cutting.

    Assumptions:
    - There exists a ridge of (power, speed) combinations where kerf quality is best.
    - Excess power at low speed increases melt and burr (roughness up).
    - Insufficient power at high speed leads to incomplete cut and roughness up.
    - Noise reflects metrology and process variability.

    Returns roughness in microns (μm), lower is better.
    """
    p = float(power_watts)
    v = float(speed_mm_per_s)

    # Optimum manifold approximations (heuristic relationships)
    p_opt = 900.0 + 7.0 * v           # optimal power increases with speed
    v_opt = 0.045 * p - 10.0          # optimal speed increases with power

    # Normalized deviations around the optima
    dp = (p - p_opt) / 300.0
    dv = (v - v_opt) / 20.0

    # Bowl-shaped valley with slight interaction
    valley = 2.0 + 6.0 * (0.6 * dp**2 + 0.6 * dv**2 + 0.2 * dp * dv)

    # Physical penalty regimes:
    # - High power with low speed -> excessive melting
    high_power_low_speed = max(0.0, (p - 1600.0) / 400.0) * max(0.0, (50.0 - v) / 20.0)
    # - Low power with high speed -> incomplete cut/striations
    low_power_high_speed = max(0.0, (100.0 - p / 10.0) / 20.0) * max(0.0, (v - 80.0) / 15.0)
    penalty = 2.0 * high_power_low_speed + 1.0 * low_power_high_speed

    # Heteroscedastic noise: slightly higher at extremes
    sigma = 0.3 + 0.002 * (p - 500.0) / 100.0 + 0.01 * abs(v - 50.0) / 50.0
    noise = rng.normal(0.0, sigma)

    roughness_um = valley + penalty + noise
    return float(max(roughness_um, 0.2))


def evaluate_laser_cut(power_watts: float, speed_mm_per_s: float) -> float:
    """
    Evaluate edge roughness (μm) for given laser power and cutting speed.

    TODO: Replace the simulation call below with actual production measurement logic, e.g.:
      - Send command to laser cutter PLC / API with (power_watts, speed_mm_per_s)
      - Execute cut on standardized coupon
      - Measure edge roughness on metrology station (e.g., stylus profilometer / confocal)
      - Return the measured roughness in microns (float)

    Until wired to hardware, this function uses a physics-inspired simulator with noise.
    """
    return simulate_edge_roughness(power_watts=power_watts, speed_mm_per_s=speed_mm_per_s, rng=RNG)


def main() -> None:
    ax_client = AxClient()

    ax_client.create_experiment(
        parameters=[
            {"name": "power_watts", "type": "range", "bounds": [500.0, 2000.0]},
            {"name": "speed_mm_per_s", "type": "range", "bounds": [10.0, 100.0]},
        ],
        objectives={METRIC_EDGE_ROUGHNESS: ObjectiveProperties(minimize=True)},
    )

    for _ in range(BUDGET_TRIALS):
        parameterization, trial_index = ax_client.get_next_trial()

        power_watts = float(parameterization["power_watts"])
        speed_mm_per_s = float(parameterization["speed_mm_per_s"])

        try:
            roughness_um = evaluate_laser_cut(power_watts=power_watts, speed_mm_per_s=speed_mm_per_s)
            ax_client.complete_trial(trial_index=trial_index, raw_data=roughness_um)
        except Exception as exc:
            # If an evaluation fails (e.g., machine fault), mark trial as failed
            print(f"Trial {trial_index} failed for (power={power_watts}, speed={speed_mm_per_s}): {exc}")
            ax_client.log_trial_failure(trial_index=trial_index)

    best_parameters, metrics = ax_client.get_best_parameters()
    best_roughness = metrics[METRIC_EDGE_ROUGHNESS]["mean"]
    print("Best settings found:")
    print(f"  power_watts: {best_parameters['power_watts']:.2f} W")
    print(f"  speed_mm_per_s: {best_parameters['speed_mm_per_s']:.2f} mm/s")
    print(f"  estimated edge_roughness: {best_roughness:.3f} μm")

    # Plot results over trials
    df = ax_client.get_trials_data_frame()
    if METRIC_EDGE_ROUGHNESS in df.columns:
        df_plot = df.dropna(subset=[METRIC_EDGE_ROUGHNESS]).copy()
        trial_idx = df_plot.index.values
        y = df_plot[METRIC_EDGE_ROUGHNESS].values
        best_so_far = np.minimum.accumulate(y)

        fig, ax = plt.subplots(figsize=(7, 4), dpi=150)
        ax.scatter(trial_idx, y, ec="k", fc="none", label="Observed")
        ax.plot(trial_idx, best_so_far, color="#0033FF", lw=2, label="Best to Trial")
        ax.set_xlabel("Trial Number")
        ax.set_ylabel("Edge Roughness (μm)")
        ax.set_title("Laser Cutting Optimization: Edge Roughness vs. Trial")
        ax.legend()
        plt.tight_layout()
        plt.show()

        # 2D scatter of parameter space colored by roughness
        if {"power_watts", "speed_mm_per_s"}.issubset(df_plot.columns):
            fig2, ax2 = plt.subplots(figsize=(6, 5), dpi=150)
            sc = ax2.scatter(
                df_plot["power_watts"],
                df_plot["speed_mm_per_s"],
                c=df_plot[METRIC_EDGE_ROUGHNESS],
                cmap="viridis_r",
                s=60,
                edgecolor="k",
            )
            ax2.set_xlabel("Laser Power (W)")
            ax2.set_ylabel("Cutting Speed (mm/s)")
            ax2.set_title("Observed Edge Roughness (μm) in Parameter Space")
            cbar = plt.colorbar(sc, ax=ax2)
            cbar.set_label("Edge Roughness (μm)")
            plt.tight_layout()
            plt.show()


if __name__ == "__main__":
    main()